import asyncio
import json
from contextlib import suppress
from datetime import datetime, timedelta, timezone
from typing import List, Optional, Dict, Any

import numpy as np
import pandas as pd
import pandas_ta as ta
import sys
from core.adaptive_strategy_selector import AdaptiveStrategySelector
from core.indicators import crossover_series, crossunder_series
from core.market_regime_detector import MarketRegimeDetector, RegimeCharacteristics, MarketRegime
from core.signal_processor import SignalProcessor
from ml.feature_engineering import unified_feature_engineer, feature_engineer
from ml.volatility_system import VolatilityPredictor, VolatilityPredictionSystem
import joblib
from config.config_manager import ConfigManager
from core.enums import Timeframe
from core.position_manager import PositionManager
from core.signal_filter import SignalFilter
from shadow_trading.signal_tracker import DatabaseMonitor
from strategies.GridStrategy import GridStrategy
from shadow_trading.shadow_trading_manager import ShadowTradingManager, FilterReason
from ml.feature_engineering import AdvancedFeatureEngineer # –î–æ–±–∞–≤–∏—Ç—å –∏–º–ø–æ—Ä—Ç
# from strategies.rl_strategy import RLStrategy # –î–æ–±–∞–≤–∏—Ç—å –∏–º–ø–æ—Ä—Ç


from strategies.dual_thrust_strategy import DualThrustStrategy
from strategies.ensemble_ml_strategy import EnsembleMLStrategy
from strategies.ichimoku_strategy import IchimokuStrategy
from strategies.mean_reversion_strategy import MeanReversionStrategy
from strategies.momentum_strategy import MomentumStrategy
from strategies.sar_strategy import StopAndReverseStrategy
from utils.logging_config import get_logger
from config import trading_params, api_keys, settings
from core.data_fetcher import DataFetcher
from core.bybit_connector import BybitConnector
from core.strategy_manager import StrategyManager  # –ë—É–¥–µ—Ç –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å—Å—è –ø–æ–∑–∂–µ
from core.risk_manager import AdvancedRiskManager # –ë—É–¥–µ—Ç –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å—Å—è –ø–æ–∑–∂–µ
from core.trade_executor import TradeExecutor # –ë—É–¥–µ—Ç –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å—Å—è –ø–æ–∑–∂–µ
from data.database_manager import AdvancedDatabaseManager # –ë—É–¥–µ—Ç –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å—Å—è –ø–æ–∑–∂–µ
from core.enums import Timeframe, SignalType  # –î–ª—è –∑–∞–ø—Ä–æ—Å–∞ —Å–≤–µ—á–µ–π
from core.schemas import RiskMetrics, TradingSignal, GridSignal  # –î–ª—è –æ—Ç–æ–±—Ä–∞–∂–µ–Ω–∏—è –±–∞–ª–∞–Ω—Å–∞
from ml.model_retraining_task import ModelRetrainingManager
from data.state_manager import StateManager
import os
from ml.anomaly_detector import MarketAnomalyDetector, AnomalyType, AnomalyReport
from ml.enhanced_ml_system import EnhancedEnsembleModel, MLPrediction
import logging # <--- –î–æ–±–∞–≤—å—Ç–µ –∏–º–ø–æ—Ä—Ç
from core.correlation_manager import CorrelationManager, PortfolioRiskMetrics
from core.signal_quality_analyzer import SignalQualityAnalyzer, QualityScore
# from shadow_trading import EnhancedShadowTradingManager
import time
signal_logger = logging.getLogger('SignalTrace') # <--- –ü–æ–ª—É—á–∞–µ–º –Ω–∞—à —Å–ø–µ—Ü. –ª–æ–≥–≥–µ—Ä
logger = get_logger(__name__)


class IntegratedTradingSystem:
  def __init__(self, db_manager: AdvancedDatabaseManager = None, config: Dict[str, Any] = None):
    logger.info("–ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è IntegratedTradingSystem...")

    # 1. –ó–∞–≥—Ä—É–∂–∞–µ–º –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏—é
    self.config_manager = ConfigManager()
    self.config = self.config_manager.load_config()

    # 2. –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä—É–µ–º –æ—Å–Ω–æ–≤–Ω—ã–µ –∫–æ–º–ø–æ–Ω–µ–Ω—Ç—ã
    self.connector = BybitConnector()
    self.db_manager = AdvancedDatabaseManager(settings.DATABASE_PATH)
    self.db_monitor = DatabaseMonitor(self.db_manager)
    self._monitoring_tasks = []
    self.state_manager = StateManager()
    self.data_fetcher = DataFetcher(
      self.connector,
      settings=self.config.get('general_settings', {})  # <--- –ò–°–ü–†–ê–í–õ–ï–ù–û
    )


    # 3. –ü–µ—Ä–µ–¥–∞–µ–º —Å–æ–æ—Ç–≤–µ—Ç—Å—Ç–≤—É—é—â–∏–µ —á–∞—Å—Ç–∏ –∫–æ–Ω—Ñ–∏–≥–∞ –≤ –¥–æ—á–µ—Ä–Ω–∏–µ –º–æ–¥—É–ª–∏
    trade_settings = self.config.get('trade_settings', {})
    strategy_settings = self.config.get('strategy_settings', {})

    self.LIVE_MODEL_PATH = "ml_models/live_model.pkl"
    ml_strategy = EnsembleMLStrategy(model_path=self.LIVE_MODEL_PATH, settings=strategy_settings, data_fetcher=self.data_fetcher)

    # –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è –Ω–æ–≤—ã—Ö ML –∫–æ–º–ø–æ–Ω–µ–Ω—Ç–æ–≤
    self.anomaly_detector: Optional[MarketAnomalyDetector] = None
    self.enhanced_ml_model: Optional[EnhancedEnsembleModel] = None
    self._anomaly_check_interval = 300  # –ü—Ä–æ–≤–µ—Ä–∫–∞ –∞–Ω–æ–º–∞–ª–∏–π –∫–∞–∂–¥—ã–µ 5 –º–∏–Ω—É—Ç
    self._last_anomaly_check = {}



    # –ó–∞–≥—Ä—É–∑–∫–∞ —Ä–∞—Å—à–∏—Ä–µ–Ω–Ω–æ–π ML –º–æ–¥–µ–ª–∏
    try:
      self.enhanced_ml_model = EnhancedEnsembleModel.load(
        "ml_models/enhanced_model.pkl",
        anomaly_detector=self.anomaly_detector
      )
      logger.info("‚úÖ –†–∞—Å—à–∏—Ä–µ–Ω–Ω–∞—è ML –º–æ–¥–µ–ª—å —É—Å–ø–µ—à–Ω–æ –∑–∞–≥—Ä—É–∂–µ–Ω–∞")
    except FileNotFoundError:
      logger.warning("–§–∞–π–ª —Ä–∞—Å—à–∏—Ä–µ–Ω–Ω–æ–π ML –º–æ–¥–µ–ª–∏ –Ω–µ –Ω–∞–π–¥–µ–Ω")
    except Exception as e:
      logger.error(f"–û—à–∏–±–∫–∞ –ø—Ä–∏ –∑–∞–≥—Ä—É–∑–∫–µ —Ä–∞—Å—à–∏—Ä–µ–Ω–Ω–æ–π ML –º–æ–¥–µ–ª–∏: {e}")

    # –ó–∞–≥—Ä—É–∑–∫–∞ –¥–µ—Ç–µ–∫—Ç–æ—Ä–∞ –∞–Ω–æ–º–∞–ª–∏–π
    try:
      self.anomaly_detector = MarketAnomalyDetector.load("ml_models/anomaly_detector.pkl")
      logger.info("‚úÖ –î–µ—Ç–µ–∫—Ç–æ—Ä –∞–Ω–æ–º–∞–ª–∏–π —É—Å–ø–µ—à–Ω–æ –∑–∞–≥—Ä—É–∂–µ–Ω")
    except FileNotFoundError:
      logger.warning("–§–∞–π–ª –¥–µ—Ç–µ–∫—Ç–æ—Ä–∞ –∞–Ω–æ–º–∞–ª–∏–π –Ω–µ –Ω–∞–π–¥–µ–Ω. –ë—É–¥–µ—Ç –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å—Å—è —ç–≤—Ä–∏—Å—Ç–∏—á–µ—Å–∫–∏–π —Ä–µ–∂–∏–º")
      self.anomaly_detector = MarketAnomalyDetector()
    except Exception as e:
      logger.error(f"–û—à–∏–±–∫–∞ –ø—Ä–∏ –∑–∞–≥—Ä—É–∑–∫–µ –¥–µ—Ç–µ–∫—Ç–æ—Ä–∞ –∞–Ω–æ–º–∞–ª–∏–π: {e}")



    self.strategy_manager = StrategyManager()
    self.strategy_manager.add_strategy(ml_strategy)

    self.adaptive_selector = AdaptiveStrategySelector(
      db_manager=self.db_manager,
      min_trades_for_evaluation=10
    )
    if hasattr(self, 'adaptive_selector'):
      self.adaptive_selector.integrated_system_ref = self
    self._evaluation_task: Optional[asyncio.Task] = None

    ichimoku_strategy = IchimokuStrategy()
    # "–†–µ–≥–∏—Å—Ç—Ä–∏—Ä—É–µ–º" –µ–µ –≤ –º–µ–Ω–µ–¥–∂–µ—Ä–µ —Å—Ç—Ä–∞—Ç–µ–≥–∏–π
    self.strategy_manager.add_strategy(ichimoku_strategy)

    # –°–æ–∑–¥–∞–µ–º —ç–∫–∑–µ–º–ø–ª—è—Ä Dual Thrust, –ø–µ—Ä–µ–¥–∞–≤–∞—è –µ–º—É –∫–æ–Ω—Ñ–∏–≥ –∏ data_fetcher
    dual_thrust_strategy = DualThrustStrategy(config=self.config, data_fetcher=self.data_fetcher)
    self.strategy_manager.add_strategy(dual_thrust_strategy)

    mean_reversion_strategy = MeanReversionStrategy()
    self.strategy_manager.add_strategy(mean_reversion_strategy)

    grid_strategy = GridStrategy(config=self.config)
    self.strategy_manager.add_strategy(grid_strategy)

    momentum_strategy = MomentumStrategy()
    self.strategy_manager.add_strategy(momentum_strategy)

    try:

      self.sar_strategy = StopAndReverseStrategy(
        config=self.config,
        data_fetcher=self.data_fetcher
      )
      self.strategy_manager.add_strategy(self.sar_strategy)
      logger.info("‚úÖ Stop-and-Reverse —Å—Ç—Ä–∞—Ç–µ–≥–∏—è –∑–∞—Ä–µ–≥–∏—Å—Ç—Ä–∏—Ä–æ–≤–∞–Ω–∞")
    except Exception as e:
      logger.error(f"–û—à–∏–±–∫–∞ –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏–∏ SAR —Å—Ç—Ä–∞—Ç–µ–≥–∏–∏: {e}")
      self.sar_strategy = None

    self.watchlist_symbols = []  # –ü–æ–ª–Ω—ã–π —Å–ø–∏—Å–æ–∫ (200-300 —Å–∏–º–≤–æ–ª–æ–≤)
    self.focus_list_symbols = []  # –ü—Ä–∏–æ—Ä–∏—Ç–µ—Ç–Ω—ã–π —Å–ø–∏—Å–æ–∫ (10-20 —Å–∏–º–≤–æ–ª–æ–≤)
    self.last_focus_update = datetime.now()
    self.priority_monitoring_enabled = self.config.get('general_settings', {}).get('priority_monitoring', {}).get(
      'enabled', True)

    missing_strategy_names = []
    expected_strategies = {
      'Live_ML_Strategy': ml_strategy,
      'Ichimoku_Cloud': ichimoku_strategy,
      'Dual_Thrust': dual_thrust_strategy,
      'Mean_Reversion_BB': mean_reversion_strategy,
      'Grid_Trading': grid_strategy,
      'Momentum_Spike': momentum_strategy,
      'Stop_and_Reverse': self.sar_strategy
    }

    for name, strategy_obj in expected_strategies.items():
      if strategy_obj is None:
        missing_strategy_names.append(name)
        logger.error(f"‚ùå –°—Ç—Ä–∞—Ç–µ–≥–∏—è {name} —Ä–∞–≤–Ω–∞ None - –Ω–µ –±—ã–ª–∞ —Å–æ–∑–¥–∞–Ω–∞!")
        continue

      if name not in self.strategy_manager.strategies:
        try:
          self.strategy_manager.add_strategy(strategy_obj)
          logger.warning(f"üîß –ü–†–ò–ù–£–î–ò–¢–ï–õ–¨–ù–û –∑–∞—Ä–µ–≥–∏—Å—Ç—Ä–∏—Ä–æ–≤–∞–Ω–∞ —Å—Ç—Ä–∞—Ç–µ–≥–∏—è {name}")
        except Exception as e:
          logger.error(f"‚ùå –û—à–∏–±–∫–∞ –ø—Ä–∏–Ω—É–¥–∏—Ç–µ–ª—å–Ω–æ–π —Ä–µ–≥–∏—Å—Ç—Ä–∞—Ü–∏–∏ {name}: {e}")
          missing_strategy_names.append(name)

    if missing_strategy_names:
      logger.error(f"üö® –ö–†–ò–¢–ò–ß–ù–û: –ù–µ —É–¥–∞–ª–æ—Å—å –∑–∞—Ä–µ–≥–∏—Å—Ç—Ä–∏—Ä–æ–≤–∞—Ç—å —Å—Ç—Ä–∞—Ç–µ–≥–∏–∏: {missing_strategy_names}")

    self.volatility_predictor: Optional[VolatilityPredictor] = None
    # --- –ù–û–í–´–ô –ë–õ–û–ö: –ó–ê–ì–†–£–ó–ö–ê –°–ò–°–¢–ï–ú–´ –í–û–õ–ê–¢–ò–õ–¨–ù–û–°–¢–ò ---
    self.volatility_system: Optional[VolatilityPredictionSystem] = None
    try:
      self.volatility_system = joblib.load("ml_models/volatility_system.pkl")
      logger.info("‚úÖ –°–∏—Å—Ç–µ–º–∞ –ø—Ä–æ–≥–Ω–æ–∑–∏—Ä–æ–≤–∞–Ω–∏—è –≤–æ–ª–∞—Ç–∏–ª—å–Ω–æ—Å—Ç–∏ —É—Å–ø–µ—à–Ω–æ –∑–∞–≥—Ä—É–∂–µ–Ω–∞.")
    except FileNotFoundError:
      logger.warning("–§–∞–π–ª volatility_system.pkl –Ω–µ –Ω–∞–π–¥–µ–Ω. SL/TP –±—É–¥—É—Ç —Ä–∞—Å—Å—á–∏—Ç—ã–≤–∞—Ç—å—Å—è –ø–æ —Å—Ç–∞–Ω–¥–∞—Ä—Ç–Ω–æ–π —Å—Ö–µ–º–µ.")
    # --- –ö–û–ù–ï–¶ –ë–õ–û–ö–ê ---

    #–î–û–ë–ê–í–ò–¢–¨: Enhanced Shadow Trading
    # self.shadow_trading = None
    # self.shadow_trading_enabled = True  # –ú–æ–∂–Ω–æ –≤—ã–Ω–µ—Å—Ç–∏ –≤ –∫–æ–Ω—Ñ–∏–≥

    self.shadow_trading = None
    if self.config.get('enhanced_shadow_trading', {}).get('enabled', False):
      try:
        self.shadow_trading = ShadowTradingManager(self.db_manager, self.data_fetcher)
        logger.info("‚úÖ Shadow Trading —Å–∏—Å—Ç–µ–º–∞ –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä–æ–≤–∞–Ω–∞")
      except Exception as e:
        logger.error(f"–û—à–∏–±–∫–∞ –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏–∏ Shadow Trading: {e}")


    self.risk_manager = AdvancedRiskManager(
      db_manager=self.db_manager,
      settings=self.config,
      data_fetcher=self.data_fetcher,
      volatility_predictor=self.volatility_system,

    )
    self.trade_executor = TradeExecutor(
      connector=self.connector,
      db_manager=self.db_manager,
      data_fetcher=self.data_fetcher,
      settings=self.config,
      risk_manager=self.risk_manager
    )

    self.trade_executor.integrated_system = self
    if self.shadow_trading:
      self.trade_executor.shadow_trading = self.shadow_trading

    if self.shadow_trading and self.data_fetcher:
      self.data_fetcher.shadow_trading_manager = self.shadow_trading
    self.market_regime_detector = MarketRegimeDetector(self.data_fetcher)
    # –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è –∫–æ—Ä—Ä–µ–ª—è—Ü–∏–æ–Ω–Ω–æ–≥–æ –º–µ–Ω–µ–¥–∂–µ—Ä–∞
    self.correlation_manager = CorrelationManager(self.data_fetcher)
    self._correlation_update_interval = 3600  # –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ –∫–æ—Ä—Ä–µ–ª—è—Ü–∏–π –∫–∞–∂–¥—ã–π —á–∞—Å
    self._last_correlation_update = 0
    self._correlation_task: Optional[asyncio.Task] = None

    self.signal_quality_analyzer = SignalQualityAnalyzer(self.data_fetcher, self.db_manager)
    self.min_quality_score = 0.6  # –ú–∏–Ω–∏–º–∞–ª—å–Ω—ã–π –±–∞–ª–ª –∫–∞—á–µ—Å—Ç–≤–∞ –¥–ª—è –∏—Å–ø–æ–ª–Ω–µ–Ω–∏—è
    self.signal_filter = SignalFilter(self.config, self.data_fetcher, self.market_regime_detector, self.correlation_manager)
    self.signal_filter._integrated_system = self

    self.position_manager = PositionManager(
      db_manager=self.db_manager,
      trade_executor=self.trade_executor,
      data_fetcher=self.data_fetcher,
      connector=self.connector,
      signal_filter = self.signal_filter,
      risk_manager=self.risk_manager,
      sar_strategy= self.sar_strategy,
    )
    self.position_manager.trading_system = self
    self.active_symbols: List[str] = []
    self.account_balance: Optional[RiskMetrics] = None
    self.is_running = False
    self._monitoring_task: Optional[asyncio.Task] = None
    self._fast_monitoring_task: Optional[asyncio.Task] = None
    self._revalidation_task: Optional[asyncio.Task] = None

    # –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä—É–µ–º RetrainingManager –±–µ–∑ –ª–∏—à–Ω–∏—Ö –∑–∞–≤–∏—Å–∏–º–æ—Å—Ç–µ–π
    self.retraining_manager = ModelRetrainingManager(data_fetcher=self.data_fetcher)
    self._retraining_task: Optional[asyncio.Task] = None
    self._time_sync_task: Optional[asyncio.Task] = None
    self.trade_executor.state_manager = self.state_manager

    # --- –ù–û–í–´–ô –ë–õ–û–ö: –ó–ê–ì–†–£–ó–ö–ê –ü–†–ï–î–ò–ö–¢–û–†–ê –í–û–õ–ê–¢–ò–õ–¨–ù–û–°–¢–ò ---

    try:
      self.volatility_predictor = joblib.load("ml_models/volatility_system.pkl")
      logger.info("–ü—Ä–µ–¥–∏–∫—Ç–æ—Ä –≤–æ–ª–∞—Ç–∏–ª—å–Ω–æ—Å—Ç–∏ —É—Å–ø–µ—à–Ω–æ –∑–∞–≥—Ä—É–∂–µ–Ω.")
    except FileNotFoundError:
      logger.warning("–§–∞–π–ª –ø—Ä–µ–¥–∏–∫—Ç–æ—Ä–∞ –≤–æ–ª–∞—Ç–∏–ª—å–Ω–æ—Å—Ç–∏ –Ω–µ –Ω–∞–π–¥–µ–Ω. –†–∞—Å—á–µ—Ç SL/TP –±—É–¥–µ—Ç –ø—Ä–æ–∏–∑–≤–æ–¥–∏—Ç—å—Å—è –ø–æ —Å—Ç–∞–Ω–¥–∞—Ä—Ç–Ω–æ–π —Å—Ö–µ–º–µ.")
    except Exception as e:
      logger.error(f"–û—à–∏–±–∫–∞ –ø—Ä–∏ –∑–∞–≥—Ä—É–∑–∫–µ –ø—Ä–µ–¥–∏–∫—Ç–æ—Ä–∞ –≤–æ–ª–∞—Ç–∏–ª—å–Ω–æ—Å—Ç–∏: {e}")
    # --- –ö–û–ù–ï–¶ –ù–û–í–û–ì–û –ë–õ–û–ö–ê ---

    # –§–ª–∞–≥–∏ –¥–ª—è –≤–∫–ª—é—á–µ–Ω–∏—è/–≤—ã–∫–ª—é—á–µ–Ω–∏—è ML –º–æ–¥–µ–ª–µ–π (–æ—Å—Ç–∞–≤–ª—è–µ–º –∫–∞–∫ –µ—Å—Ç—å)
    self.use_enhanced_ml = True
    self.use_base_ml = True
    self._last_regime_check = {}
    self._regime_check_interval = 300

    self.signal_filter = SignalFilter(self.config, self.data_fetcher, self.market_regime_detector, self.correlation_manager)
    self.signal_processor = SignalProcessor(self.risk_manager, self.signal_filter, self.signal_quality_analyzer)
    self.feature_engineer_rl = AdvancedFeatureEngineer()


    # –ù–∞—Å—Ç—Ä–æ–π–∫–∞ –ø–æ—Ä–æ–≥–æ–≤ –∫–∞—á–µ—Å—Ç–≤–∞ –ø–æ —É–º–æ–ª—á–∞–Ω–∏—é
    if hasattr(self, 'set_quality_thresholds'):
      self.set_quality_thresholds(min_score=0.6)
      logger.info("‚úÖ –ü–æ—Ä–æ–≥–∏ –∫–∞—á–µ—Å—Ç–≤–∞ —Å–∏–≥–Ω–∞–ª–æ–≤ –Ω–∞—Å—Ç—Ä–æ–µ–Ω—ã")

    # –ü–µ—Ä–∏–æ–¥–∏—á–µ—Å–∫–∞—è –∑–∞–¥–∞—á–∞ –∞–Ω–∞–ª–∏–∑–∞ –∑–¥–æ—Ä–æ–≤—å—è —Å–∏—Å—Ç–µ–º—ã
    self._health_check_interval = 1800  # 30 –º–∏–Ω—É—Ç
    self._last_health_check = 0

    # –î–ò–ê–ì–ù–û–°–¢–ò–ö–ê: –ü—Ä–æ–≤–µ—Ä—è–µ–º —Ä–µ–≥–∏—Å—Ç—Ä–∞—Ü–∏—é –≤—Å–µ—Ö —Å—Ç—Ä–∞—Ç–µ–≥–∏–π
    logger.info("üîç –î–ò–ê–ì–ù–û–°–¢–ò–ö–ê: –ü—Ä–æ–≤–µ—Ä–∫–∞ –∑–∞—Ä–µ–≥–∏—Å—Ç—Ä–∏—Ä–æ–≤–∞–Ω–Ω—ã—Ö —Å—Ç—Ä–∞—Ç–µ–≥–∏–π:")
    if hasattr(self, 'strategy_manager') and self.strategy_manager:
      registered_strategies = list(self.strategy_manager.strategies.keys())
      logger.info(f"üìã –ó–∞—Ä–µ–≥–∏—Å—Ç—Ä–∏—Ä–æ–≤–∞–Ω–Ω—ã–µ —Å—Ç—Ä–∞—Ç–µ–≥–∏–∏ ({len(registered_strategies)}): {registered_strategies}")

      # –ü—Ä–æ–≤–µ—Ä—è–µ–º –∫–∞–∂–¥—É—é —Å—Ç—Ä–∞—Ç–µ–≥–∏—é
      expected_strategies = ['Live_ML_Strategy', 'Ichimoku_Cloud', 'Dual_Thrust', 'Mean_Reversion_BB', 'Grid_Trading',
                             'Momentum_Spike', 'Stop_and_Reverse']

      missing_strategies = []
      for strategy_name in expected_strategies:
        if strategy_name in registered_strategies:
          strategy_obj = self.strategy_manager.strategies[strategy_name]
          logger.info(f"‚úÖ {strategy_name}: {type(strategy_obj).__name__}")
        else:
          missing_strategies.append(strategy_name)
          logger.error(f"‚ùå {strategy_name}: –ù–ï –ó–ê–†–ï–ì–ò–°–¢–†–ò–†–û–í–ê–ù–ê")

      if missing_strategies:
        logger.error(f"üö® –û–¢–°–£–¢–°–¢–í–£–Æ–¢ –°–¢–†–ê–¢–ï–ì–ò–ò: {missing_strategies}")
      else:
        logger.info("‚úÖ –í—Å–µ –æ–∂–∏–¥–∞–µ–º—ã–µ —Å—Ç—Ä–∞—Ç–µ–≥–∏–∏ –∑–∞—Ä–µ–≥–∏—Å—Ç—Ä–∏—Ä–æ–≤–∞–Ω—ã")
    else:
      logger.error("‚ùå Strategy manager –Ω–µ –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä–æ–≤–∞–Ω!")

    # if self.config.get('rl_trading', {}).get('enabled', False):
    #   logger.info("–ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è RL Trading –∫–æ–º–ø–æ–Ω–µ–Ω—Ç–æ–≤...")
    #
    #   try:
    #     from rl.environment import BybitTradingEnvironment
    #     from rl.finrl_agent import EnhancedRLAgent
    #     from rl.feature_processor import RLFeatureProcessor
    #     from rl.portfolio_manager import RLPortfolioManager
    #     from rl.reward_functions import RiskAdjustedRewardFunction
    #     from rl.shadow_learning import ShadowTradingLearner
    #     from strategies.rl_strategy import RLStrategy
    #
    #     # –°–æ–∑–¥–∞–µ–º –ø—Ä–æ—Ü–µ—Å—Å–æ—Ä –ø—Ä–∏–∑–Ω–∞–∫–æ–≤
    #     self.rl_feature_processor = RLFeatureProcessor(
    #       feature_engineer=self.feature_engineer_rl,
    #       config=self.config['rl_trading'].get('feature_config', {})
    #     )
    #
    #     # –°–æ–∑–¥–∞–µ–º –º–µ–Ω–µ–¥–∂–µ—Ä –ø–æ—Ä—Ç—Ñ–µ–ª—è
    #     self.rl_portfolio_manager = RLPortfolioManager(
    #       initial_capital=self.config['rl_trading'].get('initial_capital', 10000),
    #       risk_manager=self.risk_manager,
    #       config=self.config['rl_trading'].get('portfolio_config', {})
    #     )
    #
    #     # –°–æ–∑–¥–∞–µ–º —Ñ—É–Ω–∫—Ü–∏—é –≤–æ–∑–Ω–∞–≥—Ä–∞–∂–¥–µ–Ω–∏—è
    #     reward_function = RiskAdjustedRewardFunction(
    #       risk_manager=self.risk_manager,
    #       config=self.config['rl_trading'].get('reward_config', {})
    #     )
    #
    #     # –°–æ–∑–¥–∞–µ–º —Å—Ä–µ–¥—É (–±—É–¥–µ—Ç –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä–æ–≤–∞–Ω–∞ –ø–æ–∑–∂–µ —Å –¥–∞–Ω–Ω—ã–º–∏)
    #     self.rl_environment = None  # –°–æ–∑–¥–∞–µ—Ç—Å—è –ø—Ä–∏ –ø–æ–ª—É—á–µ–Ω–∏–∏ –¥–∞–Ω–Ω—ã—Ö
    #
    #     # –°–æ–∑–¥–∞–µ–º RL –∞–≥–µ–Ω—Ç–∞
    #     self.rl_agent = EnhancedRLAgent(
    #       environment=None,  # –ë—É–¥–µ—Ç —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–æ –ø–æ–∑–∂–µ
    #       ml_model=self.ml_model,
    #       anomaly_detector=self.anomaly_detector,
    #       volatility_predictor=self.volatility_predictor,
    #       algorithm=self.config['rl_trading'].get('algorithm', 'PPO'),
    #       config=self.config['rl_trading']
    #     )
    #
    #     # –ó–∞–≥—Ä—É–∂–∞–µ–º –ø—Ä–µ–¥–æ–±—É—á–µ–Ω–Ω—É—é –º–æ–¥–µ–ª—å –µ—Å–ª–∏ –µ—Å—Ç—å
    #     model_name = self.config['rl_trading'].get('pretrained_model')
    #     if model_name:
    #       try:
    #         self.rl_agent.load_model(model_name)
    #         logger.info(f"–ó–∞–≥—Ä—É–∂–µ–Ω–∞ –ø—Ä–µ–¥–æ–±—É—á–µ–Ω–Ω–∞—è RL –º–æ–¥–µ–ª—å: {model_name}")
    #       except Exception as e:
    #         logger.warning(f"–ù–µ —É–¥–∞–ª–æ—Å—å –∑–∞–≥—Ä—É–∑–∏—Ç—å RL –º–æ–¥–µ–ª—å: {e}")
    #
    #     # –°–æ–∑–¥–∞–µ–º Shadow Learning –∫–æ–º–ø–æ–Ω–µ–Ω—Ç
    #     if self.shadow_trading_manager:
    #       self.shadow_learner = ShadowTradingLearner(
    #         rl_agent=self.rl_agent,
    #         shadow_trading_manager=self.shadow_trading_manager,
    #         feature_processor=self.rl_feature_processor,
    #         data_fetcher=self.data_fetcher,
    #         config=self.config['rl_trading'].get('shadow_learning_config', {})
    #       )
    #
    #       # –ó–∞–ø—É—Å–∫–∞–µ–º –Ω–µ–ø—Ä–µ—Ä—ã–≤–Ω–æ–µ –æ–±—É—á–µ–Ω–∏–µ –µ—Å–ª–∏ –≤–∫–ª—é—á–µ–Ω–æ
    #       if self.config['rl_trading'].get('continuous_learning', False):
    #         asyncio.create_task(self.shadow_learner.continuous_learning_loop())
    #         logger.info("–ó–∞–ø—É—â–µ–Ω –ø—Ä–æ—Ü–µ—Å—Å –Ω–µ–ø—Ä–µ—Ä—ã–≤–Ω–æ–≥–æ –æ–±—É—á–µ–Ω–∏—è RL")
    #
    #     # –°–æ–∑–¥–∞–µ–º RL —Å—Ç—Ä–∞—Ç–µ–≥–∏—é
    #     rl_strategy = RLStrategy(
    #       rl_agent=self.rl_agent,
    #       feature_processor=self.rl_feature_processor,
    #       data_fetcher=self.data_fetcher,
    #       config=self.config['rl_trading']
    #     )
    #
    #     # –î–æ–±–∞–≤–ª—è–µ–º –≤ –º–µ–Ω–µ–¥–∂–µ—Ä —Å—Ç—Ä–∞—Ç–µ–≥–∏–π
    #     self.strategy_manager.add_strategy('RL_Strategy', rl_strategy)
    #
    #     logger.info("‚úÖ RL Trading –∫–æ–º–ø–æ–Ω–µ–Ω—Ç—ã —É—Å–ø–µ—à–Ω–æ –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä–æ–≤–∞–Ω—ã")
    #
    #   except Exception as e:
    #     logger.error(f"–û—à–∏–±–∫–∞ –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏–∏ RL Trading: {e}", exc_info=True)
    #     # –û—Ç–∫–ª—é—á–∞–µ–º RL –µ—Å–ª–∏ –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è –Ω–µ —É–¥–∞–ª–∞—Å—å
    #     self.config['rl_trading']['enabled'] = False

    logger.info("IntegratedTradingSystem –ø–æ–ª–Ω–æ—Å—Ç—å—é –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä–æ–≤–∞–Ω.")

  @staticmethod
  def calculate_mfi_manual(high: pd.Series, low: pd.Series, close: pd.Series, volume: pd.Series,
                           length: int = 14) -> pd.Series:
    """
    –†—É—á–Ω–æ–π, –Ω–∞–¥–µ–∂–Ω—ã–π —Ä–∞—Å—á–µ—Ç Money Flow Index (MFI).
    """
    # 1. –†–∞—Å—Å—á–∏—Ç—ã–≤–∞–µ–º —Ç–∏–ø–∏—á–Ω—É—é —Ü–µ–Ω—É
    typical_price = (high + low + close) / 3

    # 2. –†–∞—Å—Å—á–∏—Ç—ã–≤–∞–µ–º –¥–µ–Ω–µ–∂–Ω—ã–π –ø–æ—Ç–æ–∫ (Raw Money Flow)
    money_flow = typical_price * volume

    # 3. –û–ø—Ä–µ–¥–µ–ª—è–µ–º –ø–æ–ª–æ–∂–∏—Ç–µ–ª—å–Ω—ã–µ –∏ –æ—Ç—Ä–∏—Ü–∞—Ç–µ–ª—å–Ω—ã–µ –¥–µ–Ω–µ–∂–Ω—ã–µ –ø–æ—Ç–æ–∫–∏
    price_diff = typical_price.diff(1)

    positive_flow = money_flow.where(price_diff > 0, 0)
    negative_flow = money_flow.where(price_diff < 0, 0)

    # 4. –°—É–º–º–∏—Ä—É–µ–º –ø–æ—Ç–æ–∫–∏ –∑–∞ –∑–∞–¥–∞–Ω–Ω—ã–π –ø–µ—Ä–∏–æ–¥
    positive_mf_sum = positive_flow.rolling(window=length, min_periods=1).sum()
    negative_mf_sum = negative_flow.rolling(window=length, min_periods=1).sum()

    # 5. –†–∞—Å—Å—á–∏—Ç—ã–≤–∞–µ–º Money Flow Ratio (MFR) —Å –∑–∞—â–∏—Ç–æ–π –æ—Ç –¥–µ–ª–µ–Ω–∏—è –Ω–∞ –Ω–æ–ª—å
    money_flow_ratio = positive_mf_sum / (negative_mf_sum + 1e-9)  # +1e-9 –¥–ª—è –∏–∑–±–µ–∂–∞–Ω–∏—è –¥–µ–ª–µ–Ω–∏—è –Ω–∞ –Ω–æ–ª—å

    # 6. –†–∞—Å—Å—á–∏—Ç—ã–≤–∞–µ–º MFI –ø–æ —Å—Ç–∞–Ω–¥–∞—Ä—Ç–Ω–æ–π —Ñ–æ—Ä–º—É–ª–µ
    mfi = 100 - (100 / (1 + money_flow_ratio))

    return mfi

  def get_regime_statistics_for_dashboard(self) -> Dict[str, Any]:
    """–ü–æ–ª—É—á–∞–µ—Ç —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫—É —Ä–µ–∂–∏–º–æ–≤ –¥–ª—è –æ—Ç–æ–±—Ä–∞–∂–µ–Ω–∏—è –≤ –¥–∞—à–±–æ—Ä–¥–µ"""
    stats = {}

    for symbol in self.active_symbols:
      if symbol in self.market_regime_detector.current_regimes:
        regime = self.market_regime_detector.current_regimes[symbol]
        stats[symbol] = {
          'regime': regime.primary_regime.value,
          'confidence': regime.confidence,
          'trend_strength': regime.trend_strength,
          'volatility': regime.volatility_level,
          'duration': str(regime.regime_duration)
        }

    return stats

  async def _monitor_symbol_for_entry_enhanced(self, symbol: str):
    """
    –£–õ–£–ß–®–ï–ù–ù–ê–Ø –í–ï–†–°–ò–Ø —Å –º—É–ª—å—Ç–∏—Å—Ç—Ä–∞—Ç–µ–≥–∏–π–Ω—ã–º –∫–æ–Ω—Å–µ–Ω—Å—É—Å–æ–º –∏ –ø–æ–ª–Ω–æ–π –∏–Ω—Ç–µ–≥—Ä–∞—Ü–∏–µ–π
    """
    logger.info(f"üîç –ü–æ–∏—Å–∫ —Å–∏–≥–Ω–∞–ª–∞ –¥–ª—è {symbol}...")
    signal_logger.info(f"====== –ù–ê–ß–ê–õ–û –¶–ò–ö–õ–ê –î–õ–Ø {symbol} ======")

    try:
      # --- –£–†–û–í–ï–ù–¨ 1: –î–ï–¢–ï–ö–¶–ò–Ø –†–ï–ñ–ò–ú–ê –†–´–ù–ö–ê –ò –í–ê–õ–ò–î–ê–¶–ò–Ø ---
      htf_data = await self.data_fetcher.get_historical_candles(symbol, Timeframe.ONE_HOUR, limit=300)
      if htf_data.empty or len(htf_data) < 100:
        logger.debug(f"–ù–µ–¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ –¥–∞–Ω–Ω—ã—Ö –¥–ª—è –∞–Ω–∞–ª–∏–∑–∞ {symbol}")
        signal_logger.info(f"–ê–ù–ê–õ–ò–ó: –ü—Ä–æ–ø—É—â–µ–Ω–æ - –Ω–µ–¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ –¥–∞–Ω–Ω—ã—Ö.")
        return

      regime_characteristics = await self.get_market_regime(symbol, force_check=True)
      if not regime_characteristics:
        logger.warning(f"–ù–µ —É–¥–∞–ª–æ—Å—å –æ–ø—Ä–µ–¥–µ–ª–∏—Ç—å —Ä–µ–∂–∏–º –¥–ª—è {symbol}")
        signal_logger.warning(f"–ê–ù–ê–õ–ò–ó: –ù–µ —É–¥–∞–ª–æ—Å—å –æ–ø—Ä–µ–¥–µ–ª–∏—Ç—å —Ä–µ–∂–∏–º.")
        return

      signal_logger.info(
        f"–†–ï–ñ–ò–ú: {regime_characteristics.primary_regime.value} (–£–≤–µ—Ä–µ–Ω–Ω–æ—Å—Ç—å: {regime_characteristics.confidence:.2f})")

      # –ü—Ä–æ–≤–µ—Ä–∫–∞ –∞–Ω–æ–º–∞–ª–∏–π
      anomalies = await self._check_market_anomalies(symbol, htf_data)
      if any(a.severity > self.config.get('strategy_settings', {}).get('anomaly_severity_threshold', 0.8) for a in
             anomalies):
        logger.warning(f"–¢–æ—Ä–≥–æ–≤–ª—è –ø–æ {symbol} –∑–∞–±–ª–æ–∫–∏—Ä–æ–≤–∞–Ω–∞ –∏–∑-–∑–∞ –∫—Ä–∏—Ç–∏—á–µ—Å–∫–∏—Ö –∞–Ω–æ–º–∞–ª–∏–π.")
        signal_logger.critical(f"–ê–ù–û–ú–ê–õ–ò–Ø: –¢–æ—Ä–≥–æ–≤–ª—è –∑–∞–±–ª–æ–∫–∏—Ä–æ–≤–∞–Ω–∞.")
        return

      # –ü—Ä–æ–≤–µ—Ä–∫–∞ –º–∏–Ω–∏–º–∞–ª—å–Ω–æ–≥–æ –∫–∞—á–µ—Å—Ç–≤–∞ —Ä–µ–∂–∏–º–∞
      regime_params = self.market_regime_detector.get_regime_parameters(symbol)
      if regime_characteristics.confidence < regime_params.min_signal_quality:
        logger.info(
          f"–ü—Ä–æ–ø—É—Å–∫–∞–µ–º {symbol}: –Ω–∏–∑–∫–∞—è —É–≤–µ—Ä–µ–Ω–Ω–æ—Å—Ç—å —Ä–µ–∂–∏–º–∞ ({regime_characteristics.confidence:.2f} < {regime_params.min_signal_quality})")
        return

      if not regime_params.recommended_strategies or 'ALL' in regime_params.avoided_strategies:
        logger.info(f"–¢–æ—Ä–≥–æ–≤–ª—è –≤ —Ä–µ–∂–∏–º–µ '{regime_characteristics.primary_regime.value}' –Ω–µ —Ä–µ–∫–æ–º–µ–Ω–¥—É–µ—Ç—Å—è –¥–ª—è {symbol}.")
        signal_logger.info(f"–†–ï–ñ–ò–ú: –¢–æ—Ä–≥–æ–≤–ª—è –Ω–µ —Ä–µ–∫–æ–º–µ–Ω–¥—É–µ—Ç—Å—è.")
        return

      await self.check_strategy_adaptation(symbol)
      active_strategies_from_dashboard = self.state_manager.get_custom_data('active_strategies') or {}

      # --- –£–†–û–í–ï–ù–¨ 2: –°–ë–û–† –°–ò–ì–ù–ê–õ–û–í –û–¢ –í–°–ï–• –°–¢–†–ê–¢–ï–ì–ò–ô ---
      candidate_signals: Dict[str, TradingSignal] = {}

      # –°–ø–µ—Ü–∏–∞–ª—å–Ω–∞—è –æ–±—Ä–∞–±–æ—Ç–∫–∞ Grid Trading (–ø—Ä–∏–æ—Ä–∏—Ç–µ—Ç)
      if "Grid_Trading" in regime_params.recommended_strategies and active_strategies_from_dashboard.get("Grid_Trading",
                                                                                                         True):
        logger.info(
          f"–†–µ–∂–∏–º {regime_characteristics.primary_regime.value} –ø–æ–¥—Ö–æ–¥–∏—Ç –¥–ª—è —Å–µ—Ç–æ—á–Ω–æ–π —Ç–æ—Ä–≥–æ–≤–ª–∏. –ü—Ä–æ–≤–µ—Ä–∫–∞ GridStrategy...")
        grid_signal = await self.strategy_manager.get_signal(symbol, htf_data, "Grid_Trading")

        if isinstance(grid_signal, GridSignal):
          logger.info(f"–ü–æ–ª—É—á–µ–Ω —Å–µ—Ç–æ—á–Ω—ã–π —Å–∏–≥–Ω–∞–ª –¥–ª—è {symbol}. –û—Ç–ø—Ä–∞–≤–∫–∞ –Ω–∞ –∏—Å–ø–æ–ª–Ω–µ–Ω–∏–µ...")
          await self.trade_executor.execute_grid_trade(grid_signal)
          return

      # –°–±–æ—Ä —Å–∏–≥–Ω–∞–ª–æ–≤ –æ—Ç –≤—Å–µ—Ö —Ä–µ–∫–æ–º–µ–Ω–¥–æ–≤–∞–Ω–Ω—ã—Ö —Å—Ç—Ä–∞—Ç–µ–≥–∏–π
      all_strategies_to_check = list(set(regime_params.recommended_strategies + [
        "Live_ML_Strategy", "Ichimoku_Cloud", "Dual_Thrust",
        "Mean_Reversion_BB", "Momentum_Spike", "Stop_and_Reverse"
      ]))

      signal_logger.info(f"üîç –°–±–æ—Ä —Å–∏–≥–Ω–∞–ª–æ–≤ –æ—Ç {len(all_strategies_to_check)} —Å—Ç—Ä–∞—Ç–µ–≥–∏–π –¥–ª—è {symbol}")
      logger.info(f"üìã –ü—Ä–æ–≤–µ—Ä—è–µ–º —Å—Ç—Ä–∞—Ç–µ–≥–∏–∏: {all_strategies_to_check}")
      logger.info(f"üìã –ó–∞—Ä–µ–≥–∏—Å—Ç—Ä–∏—Ä–æ–≤–∞–Ω–Ω—ã–µ —Å—Ç—Ä–∞—Ç–µ–≥–∏–∏: {list(self.strategy_manager.strategies.keys())}")

      for strategy_name in all_strategies_to_check:
        if strategy_name == "Grid_Trading":
          continue  # –£–∂–µ –æ–±—Ä–∞–±–æ—Ç–∞–Ω–∞ –≤—ã—à–µ

        # –ü—Ä–æ–≤–µ—Ä–∫–∏ –∞–∫—Ç–∏–≤–Ω–æ—Å—Ç–∏ –∏ –¥–æ–ø—É—Å—Ç–∏–º–æ—Å—Ç–∏
        if strategy_name == "Live_ML_Strategy" and not self.use_base_ml:
          continue

        if not active_strategies_from_dashboard.get(strategy_name, True):
          logger.debug(f"–°—Ç—Ä–∞—Ç–µ–≥–∏—è {strategy_name} –æ—Ç–∫–ª—é—á–µ–Ω–∞ –≤ –¥–∞—à–±–æ—Ä–¥–µ")
          continue

        if strategy_name in regime_params.avoided_strategies and regime_characteristics.confidence > 0.8:
          logger.debug(f"–°—Ç—Ä–∞—Ç–µ–≥–∏—è {strategy_name} –∏–∑–±–µ–≥–∞–µ—Ç—Å—è –≤ —Ä–µ–∂–∏–º–µ {regime_characteristics.primary_regime.value}")
          continue

        # –ü—Ä–æ–≤–µ—Ä–∫–∞ –∞–¥–∞–ø—Ç–∏–≤–Ω–æ–π –∞–∫—Ç–∏–≤–Ω–æ—Å—Ç–∏
        if hasattr(self, 'adaptive_selector') and self.adaptive_selector:
          try:
            should_activate = self.adaptive_selector.should_activate_strategy(strategy_name,
                                                                              regime_characteristics.primary_regime.value)
            strategy_weight = self.adaptive_selector.get_strategy_weight(strategy_name,
                                                                         regime_characteristics.primary_regime.value)

            if not should_activate and strategy_weight < 0.2:
              logger.debug(f"–°—Ç—Ä–∞—Ç–µ–≥–∏—è {strategy_name} –Ω–µ–∞–∫—Ç–∏–≤–Ω–∞ –¥–ª—è {symbol} (–≤–µ—Å={strategy_weight:.2f})")
              continue
          except Exception as e:
            logger.warning(f"–û—à–∏–±–∫–∞ –∞–¥–∞–ø—Ç–∏–≤–Ω–æ–≥–æ —Å–µ–ª–µ–∫—Ç–æ—Ä–∞ –¥–ª—è {strategy_name}: {e}")

        try:
          # –ü–æ–ª—É—á–µ–Ω–∏–µ —Å–∏–≥–Ω–∞–ª–∞ –æ—Ç —Å—Ç—Ä–∞—Ç–µ–≥–∏–∏
          if strategy_name == "Stop_and_Reverse" and self.sar_strategy and symbol in self.sar_strategy.monitored_symbols:
            # –°–ø–µ—Ü–∏–∞–ª—å–Ω–∞—è –æ–±—Ä–∞–±–æ—Ç–∫–∞ SAR —Å—Ç—Ä–∞—Ç–µ–≥–∏–∏
            self.sar_strategy._clear_old_cache()
            signal = await self.sar_strategy.generate_signal(symbol, htf_data)

            if signal and signal.signal_type != SignalType.HOLD:
              current_position = self.position_manager.open_positions.get(symbol)
              await self.sar_strategy.update_position_status(symbol, current_position)

              # –ò–Ω—Ç–µ–≥—Ä–∞—Ü–∏—è —Å Shadow Trading –¥–ª—è SAR
              if self.shadow_trading:
                signal_id = await self.shadow_trading.process_signal(
                  signal=signal,
                  metadata={
                    'source': 'sar_strategy',
                    'strategy_name': 'Stop_and_Reverse',
                    'signal_score': signal.metadata.get('signal_score', 0),
                    'sar_components': signal.metadata.get('sar_components', {}),
                    'market_regime': regime_characteristics.primary_regime.value,
                    'confidence_score': signal.confidence
                  },
                  was_filtered=False
                )
                signal.metadata['shadow_tracking_id'] = signal_id
          else:
            # –û–±—ã—á–Ω—ã–µ —Å—Ç—Ä–∞—Ç–µ–≥–∏–∏
            signal = await self.strategy_manager.get_signal(symbol, htf_data, strategy_name)

          # –û–±—Ä–∞–±–æ—Ç–∫–∞ –ø–æ–ª—É—á–µ–Ω–Ω–æ–≥–æ —Å–∏–≥–Ω–∞–ª–∞
          if signal and signal.signal_type != SignalType.HOLD and signal.confidence >= 0.3:
            # –ü—Ä–∏–º–µ–Ω–µ–Ω–∏–µ –∞–¥–∞–ø—Ç–∏–≤–Ω–æ–≥–æ –≤–µ—Å–∞
            weight = 1.0
            if hasattr(self, 'adaptive_selector') and self.adaptive_selector:
              try:
                weight = self.adaptive_selector.get_strategy_weight(strategy_name,
                                                                    regime_characteristics.primary_regime.value)
                signal.confidence *= weight
              except Exception:
                pass

            candidate_signals[strategy_name] = signal
            signal_logger.info(
              f"‚úÖ {strategy_name}: {signal.signal_type.value}, —É–≤–µ—Ä–µ–Ω–Ω–æ—Å—Ç—å: {signal.confidence:.3f}, –≤–µ—Å: {weight:.2f}")
          else:
            signal_logger.debug(f"‚ûñ {strategy_name}: –Ω–µ—Ç —Å–∏–≥–Ω–∞–ª–∞ –∏–ª–∏ –Ω–∏–∑–∫–∞—è —É–≤–µ—Ä–µ–Ω–Ω–æ—Å—Ç—å")

        except Exception as e:
          logger.error(f"–û—à–∏–±–∫–∞ –ø–æ–ª—É—á–µ–Ω–∏—è —Å–∏–≥–Ω–∞–ª–∞ –æ—Ç {strategy_name}: {e}")
          continue

      signal_logger.info(
        f"üìà –°–æ–±—Ä–∞–Ω–æ {len(candidate_signals)} –∫–∞–Ω–¥–∏–¥–∞—Ç–æ–≤ —Å–∏–≥–Ω–∞–ª–æ–≤ –¥–ª—è {symbol}: {list(candidate_signals.keys())}")

      # --- –£–†–û–í–ï–ù–¨ 3: ML –ú–ï–¢–ê-–ê–ù–ê–õ–ò–ó ---
      ml_prediction = None
      data_is_fresh = True

      if self.enhanced_ml_model and self.use_enhanced_ml:
        # –í–∞–ª–∏–¥–∞—Ü–∏—è —Å–≤–µ–∂–µ—Å—Ç–∏ –¥–∞–Ω–Ω—ã—Ö
        if hasattr(self.enhanced_ml_model, 'temporal_manager'):
          try:
            data_validation = self.enhanced_ml_model.temporal_manager.validate_data_freshness(htf_data, symbol)
            data_is_fresh = data_validation['is_fresh']

            if not data_is_fresh and data_validation.get('data_age_minutes', 0) > 30:
              logger.warning(f"–î–∞–Ω–Ω—ã–µ –¥–ª—è {symbol} —Å–ª–∏—à–∫–æ–º —Å—Ç–∞—Ä—ã–µ, –ø—Ä–æ–ø—É—Å–∫–∞–µ–º ML –∞–Ω–∞–ª–∏–∑")
              data_is_fresh = False
          except Exception as validation_error:
            logger.warning(f"–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏ —Å–≤–µ–∂–µ—Å—Ç–∏ –¥–∞–Ω–Ω—ã—Ö –¥–ª—è {symbol}: {validation_error}")

        # –ü–æ–ª—É—á–µ–Ω–∏–µ ML –ø—Ä–µ–¥—Å–∫–∞–∑–∞–Ω–∏—è
        if data_is_fresh:
          try:
            logger.debug(f"–ü–æ–ª—É—á–µ–Ω–∏–µ ML –ø—Ä–µ–¥—Å–∫–∞–∑–∞–Ω–∏—è –¥–ª—è {symbol}...")
            ml_prediction = self.enhanced_ml_model.predict_proba(htf_data)

            if ml_prediction and ml_prediction.signal_type != SignalType.HOLD:
              candidate_signals['ML_Enhanced'] = ml_prediction
              signal_logger.info(
                f"ü§ñ ML_Enhanced: {ml_prediction.signal_type.value}, —É–≤–µ—Ä–µ–Ω–Ω–æ—Å—Ç—å: {ml_prediction.confidence:.3f}")
          except Exception as ml_error:
            logger.error(f"–û—à–∏–±–∫–∞ –ø–æ–ª—É—á–µ–Ω–∏—è ML –ø—Ä–µ–¥—Å–∫–∞–∑–∞–Ω–∏—è –¥–ª—è {symbol}: {ml_error}")

      # --- –£–†–û–í–ï–ù–¨ 4: –ö–û–ù–°–ï–ù–°–£–°–ù–´–ô –ê–ù–ê–õ–ò–ó –ò –ü–†–ò–ù–Ø–¢–ò–ï –†–ï–®–ï–ù–ò–Ø ---
      final_signal: Optional[TradingSignal] = None
      current_price = htf_data['close'].iloc[-1]

      if candidate_signals:
        signal_logger.info(f"üéØ –ê–ù–ê–õ–ò–ó –ö–û–ù–°–ï–ù–°–£–°–ê –¥–ª—è {symbol}: {len(candidate_signals)} –∫–∞–Ω–¥–∏–¥–∞—Ç–æ–≤")

        # –ì—Ä—É–ø–ø–∏—Ä–æ–≤–∫–∞ —Å–∏–≥–Ω–∞–ª–æ–≤ –ø–æ —Ç–∏–ø—É
        buy_signals = [(name, sig) for name, sig in candidate_signals.items() if sig.signal_type == SignalType.BUY]
        sell_signals = [(name, sig) for name, sig in candidate_signals.items() if sig.signal_type == SignalType.SELL]

        signal_logger.info(f"  üìà BUY —Å–∏–≥–Ω–∞–ª–æ–≤: {len(buy_signals)} –æ—Ç {[name for name, _ in buy_signals]}")
        signal_logger.info(f"  üìâ SELL —Å–∏–≥–Ω–∞–ª–æ–≤: {len(sell_signals)} –æ—Ç {[name for name, _ in sell_signals]}")

        # –õ–æ–≥–∏–∫–∞ –ø—Ä–∏–Ω—è—Ç–∏—è —Ä–µ—à–µ–Ω–∏—è –Ω–∞ –æ—Å–Ω–æ–≤–µ –∫–æ–Ω—Å–µ–Ω—Å—É—Å–∞
        if len(buy_signals) > len(sell_signals) and buy_signals:
          # –ö–æ–Ω—Å–µ–Ω—Å—É—Å –Ω–∞ –ø–æ–∫—É–ø–∫—É
          if len(buy_signals) >= 2:
            # –ú–Ω–æ–∂–µ—Å—Ç–≤–µ–Ω–Ω–æ–µ –ø–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–∏–µ - –ø–æ–≤—ã—à–∞–µ–º —É–≤–µ—Ä–µ–Ω–Ω–æ—Å—Ç—å
            total_weight = sum(sig.confidence for _, sig in buy_signals)
            weighted_confidence = total_weight / len(buy_signals)

            best_buy = max(buy_signals, key=lambda x: x[1].confidence)
            final_signal = best_buy[1]

            # –ë–æ–Ω—É—Å –∑–∞ –∫–æ–Ω—Å–µ–Ω—Å—É—Å
            consensus_boost = min(0.2, (len(buy_signals) - 1) * 0.05)
            final_signal.confidence = min(0.95, weighted_confidence + consensus_boost)

            confirming_strategies = [name for name, _ in buy_signals]
            final_signal.metadata = final_signal.metadata or {}
            final_signal.metadata.update({
              'consensus_type': 'multiple_buy',
              'confirming_strategies': confirming_strategies,
              'original_confidence': best_buy[1].confidence,
              'consensus_boost': consensus_boost,
              'weighted_confidence': weighted_confidence
            })
            final_signal.strategy_name = f"Consensus_BUY"

            signal_logger.info(
              f"‚úÖ –ö–û–ù–°–ï–ù–°–£–° BUY –¥–ª—è {symbol}: {confirming_strategies}, –∏—Ç–æ–≥–æ–≤–∞—è —É–≤–µ—Ä–µ–Ω–Ω–æ—Å—Ç—å: {final_signal.confidence:.3f}")
          else:
            # –û–¥–∏–Ω–æ—á–Ω—ã–π BUY —Å–∏–≥–Ω–∞–ª
            final_signal = buy_signals[0][1]
            signal_logger.info(
              f"‚úÖ –û–î–ò–ù–û–ß–ù–´–ô BUY –¥–ª—è {symbol} –æ—Ç {buy_signals[0][0]}, —É–≤–µ—Ä–µ–Ω–Ω–æ—Å—Ç—å: {final_signal.confidence:.3f}")

        elif len(sell_signals) > len(buy_signals) and sell_signals:
          # –ö–æ–Ω—Å–µ–Ω—Å—É—Å –Ω–∞ –ø—Ä–æ–¥–∞–∂—É
          if len(sell_signals) >= 2:
            total_weight = sum(sig.confidence for _, sig in sell_signals)
            weighted_confidence = total_weight / len(sell_signals)

            best_sell = max(sell_signals, key=lambda x: x[1].confidence)
            final_signal = best_sell[1]

            consensus_boost = min(0.2, (len(sell_signals) - 1) * 0.05)
            final_signal.confidence = min(0.95, weighted_confidence + consensus_boost)

            confirming_strategies = [name for name, _ in sell_signals]
            final_signal.metadata = final_signal.metadata or {}
            final_signal.metadata.update({
              'consensus_type': 'multiple_sell',
              'confirming_strategies': confirming_strategies,
              'original_confidence': best_sell[1].confidence,
              'consensus_boost': consensus_boost,
              'weighted_confidence': weighted_confidence
            })
            final_signal.strategy_name = f"Consensus_SELL"

            signal_logger.info(
              f"‚úÖ –ö–û–ù–°–ï–ù–°–£–° SELL –¥–ª—è {symbol}: {confirming_strategies}, –∏—Ç–æ–≥–æ–≤–∞—è —É–≤–µ—Ä–µ–Ω–Ω–æ—Å—Ç—å: {final_signal.confidence:.3f}")
          else:
            final_signal = sell_signals[0][1]
            signal_logger.info(
              f"‚úÖ –û–î–ò–ù–û–ß–ù–´–ô SELL –¥–ª—è {symbol} –æ—Ç {sell_signals[0][0]}, —É–≤–µ—Ä–µ–Ω–Ω–æ—Å—Ç—å: {final_signal.confidence:.3f}")

        elif len(buy_signals) == len(sell_signals) and buy_signals and sell_signals:
          # –ö–æ–Ω—Ñ–ª–∏–∫—Ç —Å–∏–≥–Ω–∞–ª–æ–≤ - –≤—ã–±–∏—Ä–∞–µ–º –ø–æ –Ω–∞–∏–≤—ã—Å—à–µ–π —É–≤–µ—Ä–µ–Ω–Ω–æ—Å—Ç–∏
          all_signals = buy_signals + sell_signals
          best_signal = max(all_signals, key=lambda x: x[1].confidence)

          # –°–Ω–∏–∂–∞–µ–º —É–≤–µ—Ä–µ–Ω–Ω–æ—Å—Ç—å –∏–∑-–∑–∞ –∫–æ–Ω—Ñ–ª–∏–∫—Ç–∞
          final_signal = best_signal[1]
          final_signal.confidence *= 0.7  # –®—Ç—Ä–∞—Ñ –∑–∞ –∫–æ–Ω—Ñ–ª–∏–∫—Ç

          final_signal.metadata = final_signal.metadata or {}
          final_signal.metadata.update({
            'consensus_type': 'conflict_resolved',
            'conflicting_strategies': [name for name, _ in all_signals],
            'conflict_penalty': 0.3
          })
          final_signal.strategy_name = f"Conflict_Resolved_{final_signal.signal_type.value}"

          signal_logger.warning(
            f"‚ö†Ô∏è –ö–û–ù–§–õ–ò–ö–¢ –°–ò–ì–ù–ê–õ–û–í –¥–ª—è {symbol}: –≤—ã–±—Ä–∞–Ω {best_signal[0]} —Å –ø–æ–Ω–∏–∂–µ–Ω–Ω–æ–π —É–≤–µ—Ä–µ–Ω–Ω–æ—Å—Ç—å—é {final_signal.confidence:.3f}")

        # –§–∏–Ω–∞–ª—å–Ω–∞—è –ø—Ä–æ–≤–µ—Ä–∫–∞ –º–∏–Ω–∏–º–∞–ª—å–Ω–æ–≥–æ –ø–æ—Ä–æ–≥–∞
        if final_signal and final_signal.confidence < regime_params.min_signal_quality:
          signal_logger.warning(
            f"‚ùå –§–∏–Ω–∞–ª—å–Ω—ã–π —Å–∏–≥–Ω–∞–ª –æ—Ç–∫–ª–æ–Ω–µ–Ω: —É–≤–µ—Ä–µ–Ω–Ω–æ—Å—Ç—å {final_signal.confidence:.3f} < {regime_params.min_signal_quality}")
          final_signal = None

        # Fallback –Ω–∞ –ª—É—á—à–∏–π —Å–∏–≥–Ω–∞–ª –µ—Å–ª–∏ –∫–æ–Ω—Å–µ–Ω—Å—É—Å –Ω–µ —Å—Ä–∞–±–æ—Ç–∞–ª
        if not final_signal:
          best_signal = max(candidate_signals.values(), key=lambda s: s.confidence)
          if best_signal.confidence >= 0.55:  # –°–Ω–∏–∂–µ–Ω –ø–æ—Ä–æ–≥ –¥–ª—è fallback
            final_signal = best_signal
            signal_logger.info(
              f"üîÑ FALLBACK: –≤—ã–±—Ä–∞–Ω —Å–∏–≥–Ω–∞–ª –æ—Ç {best_signal.strategy_name}, —É–≤–µ—Ä–µ–Ω–Ω–æ—Å—Ç—å: {final_signal.confidence:.3f}")

      else:
        signal_logger.info(f"üì≠ –ù–µ—Ç –∫–∞–Ω–¥–∏–¥–∞—Ç–æ–≤ —Å–∏–≥–Ω–∞–ª–æ–≤ –¥–ª—è {symbol}")

      # --- –£–†–û–í–ï–ù–¨ 5: –û–ë–†–ê–ë–û–¢–ö–ê –§–ò–ù–ê–õ–¨–ù–û–ì–û –°–ò–ì–ù–ê–õ–ê ---
      if final_signal and final_signal.signal_type != SignalType.HOLD:
        logger.info(
          f"üéØ –§–ò–ù–ê–õ–¨–ù–û–ï –†–ï–®–ï–ù–ò–ï –¥–ª—è {symbol}: {final_signal.strategy_name} {final_signal.signal_type.value}, —É–≤–µ—Ä–µ–Ω–Ω–æ—Å—Ç—å: {final_signal.confidence:.3f}")
        signal_logger.info(f"üéØ –ù–û–í–´–ô –°–ò–ì–ù–ê–õ {symbol}: {final_signal.signal_type.value} @ {final_signal.price}")

        try:
          # –î–æ–±–∞–≤–ª—è–µ–º ROI –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é –≤ –º–µ—Ç–∞–¥–∞–Ω–Ω—ã–µ
          if not hasattr(final_signal, 'metadata') or final_signal.metadata is None:
            final_signal.metadata = {}

          try:
            roi_targets = self.risk_manager.convert_roi_to_price_targets(
              entry_price=final_signal.price,
              signal_type=final_signal.signal_type
            )
            if roi_targets:
              signal_logger.info(f"ROI –¶–ï–õ–ò –¥–ª—è {symbol}:")
              signal_logger.info(
                f"  SL: {roi_targets['stop_loss']['price']:.6f} (ROI: {roi_targets['stop_loss']['roi_pct']:.1f}%)")
              signal_logger.info(
                f"  TP: {roi_targets['take_profit']['price']:.6f} (ROI: {roi_targets['take_profit']['roi_pct']:.1f}%)")
              signal_logger.info(f"  Risk/Reward: 1:{roi_targets['risk_reward_ratio']:.2f}")
              final_signal.metadata['roi_targets'] = roi_targets
          except Exception as roi_error:
            logger.debug(f"–û—à–∏–±–∫–∞ –ø–æ–ª—É—á–µ–Ω–∏—è ROI –¥–ª—è {symbol}: {roi_error}")

          # –ü—Ä–æ–≤–µ—Ä–∫–∞ –∫–æ—Ä—Ä–µ–ª—è—Ü–∏–π —Å –æ—Ç–∫—Ä—ã—Ç—ã–º–∏ –ø–æ–∑–∏—Ü–∏—è–º–∏
          open_symbols = list(self.position_manager.open_positions.keys())
          correlation_blocked = False

          if open_symbols and hasattr(self, 'correlation_manager'):
            try:
              should_block, block_reason = self.correlation_manager.should_block_signal_due_to_correlation(symbol,
                                                                                                           open_symbols)
              if should_block:
                logger.warning(f"–°–∏–≥–Ω–∞–ª –¥–ª—è {symbol} –∑–∞–±–ª–æ–∫–∏—Ä–æ–≤–∞–Ω –∫–æ—Ä—Ä–µ–ª—è—Ü–∏—è–º–∏: {block_reason}")
                signal_logger.warning(f"–ö–û–†–†–ï–õ–Ø–¶–ò–Ø: –°–∏–≥–Ω–∞–ª {symbol} –æ—Ç–∫–ª–æ–Ω–µ–Ω - {block_reason}")
                correlation_blocked = True
            except Exception as corr_error:
              logger.debug(f"–û—à–∏–±–∫–∞ –ø—Ä–æ–≤–µ—Ä–∫–∏ –∫–æ—Ä—Ä–µ–ª—è—Ü–∏–π –¥–ª—è {symbol}: {corr_error}")

          # –û–±—Ä–∞–±–æ—Ç–∫–∞ —Å–∏–≥–Ω–∞–ª–∞ –µ—Å–ª–∏ –Ω–µ –∑–∞–±–ª–æ–∫–∏—Ä–æ–≤–∞–Ω
          if not correlation_blocked:
            await self._process_trading_signal(final_signal, symbol, htf_data)

        except Exception as processing_error:
          logger.error(f"–û—à–∏–±–∫–∞ –æ–±—Ä–∞–±–æ—Ç–∫–∏ —Ñ–∏–Ω–∞–ª—å–Ω–æ–≥–æ —Å–∏–≥–Ω–∞–ª–∞ –¥–ª—è {symbol}: {processing_error}", exc_info=True)
          signal_logger.error(f"–û–®–ò–ë–ö–ê: –ù–µ —É–¥–∞–ª–æ—Å—å –æ–±—Ä–∞–±–æ—Ç–∞—Ç—å —Å–∏–≥–Ω–∞–ª {symbol} - {processing_error}")

      else:
        logger.info(f"–î–ª—è {symbol} –Ω–µ –Ω–∞–π–¥–µ–Ω–æ –ø–æ–¥—Ö–æ–¥—è—â–µ–≥–æ —Å–∏–≥–Ω–∞–ª–∞ –≤ —Ç–µ–∫—É—â–µ–º —Ä–µ–∂–∏–º–µ.")
        signal_logger.info(f"–ò–¢–û–ì: –°–∏–≥–Ω–∞–ª –Ω–µ —Å—Ñ–æ—Ä–º–∏—Ä–æ–≤–∞–Ω.")

    except Exception as e:
      logger.error(f"–ö—Ä–∏—Ç–∏—á–µ—Å–∫–∞—è –æ—à–∏–±–∫–∞ –≤ _monitor_symbol_for_entry_enhanced –¥–ª—è {symbol}: {e}", exc_info=True)
      signal_logger.error(f"–ö–†–ò–¢–ò–ß–ï–°–ö–ê–Ø –û–®–ò–ë–ö–ê: {e}")
    finally:
      signal_logger.info(f"====== –ö–û–ù–ï–¶ –¶–ò–ö–õ–ê –î–õ–Ø {symbol} ======\n")

  async def _process_trading_signal(self, signal: TradingSignal, symbol: str, market_data: pd.DataFrame):
    """
    –û–±—Ä–∞–±–æ—Ç–∫–∞ —Ç–æ—Ä–≥–æ–≤–æ–≥–æ —Å–∏–≥–Ω–∞–ª–∞ —Å —É—á–µ—Ç–æ–º –∞–Ω–æ–º–∞–ª–∏–π
    """
    logger.info(
      f"üîÑ –ù–ê–ß–ê–õ–û –û–ë–†–ê–ë–û–¢–ö–ò –°–ò–ì–ù–ê–õ–ê –¥–ª—è {symbol}: {signal.signal_type.value}, confidence={signal.confidence:.3f}")

    # –°—Ç–∞–Ω–¥–∞—Ä—Ç–Ω–∞—è —Ñ–∏–ª—å—Ç—Ä–∞—Ü–∏—è
    logger.info(f"üìã –ü—Ä–æ–≤–µ—Ä–∫–∞ —Å–∏–≥–Ω–∞–ª—å–Ω–æ–≥–æ —Ñ–∏–ª—å—Ç—Ä–∞...")
    is_approved, reason = await self.signal_filter.filter_signal(signal, market_data)
    if not is_approved:
      logger.info(f"‚ùå –°–∏–≥–Ω–∞–ª –¥–ª—è {symbol} –æ—Ç–∫–ª–æ–Ω–µ–Ω —Ñ–∏–ª—å—Ç—Ä–æ–º: {reason}")
      return
    logger.info(f"‚úÖ –°–∏–≥–Ω–∞–ª—å–Ω—ã–π —Ñ–∏–ª—å—Ç—Ä –ø—Ä–æ–π–¥–µ–Ω")

    # === –ù–û–í–´–ô –ë–õ–û–ö: –ë–´–°–¢–†–ê–Ø –û–¶–ï–ù–ö–ê –ö–ê–ß–ï–°–¢–í–ê ===
    try:
      # –ë—ã—Å—Ç—Ä–∞—è –æ—Ü–µ–Ω–∫–∞ –∫–∞—á–µ—Å—Ç–≤–∞ —Å–∏–≥–Ω–∞–ª–∞ –µ—Å–ª–∏ –∞–Ω–∞–ª–∏–∑–∞—Ç–æ—Ä –¥–æ—Å—Ç—É–ø–µ–Ω
      if hasattr(self, 'signal_quality_analyzer') and self.signal_quality_analyzer:
        logger.info(f"üìä –ë—ã—Å—Ç—Ä–∞—è –æ—Ü–µ–Ω–∫–∞ –∫–∞—á–µ—Å—Ç–≤–∞ —Å–∏–≥–Ω–∞–ª–∞ –¥–ª—è {symbol}...")
        signal_logger.info(f"–ö–ê–ß–ï–°–¢–í–û: –ù–∞—á–∞—Ç–∞ –±—ã—Å—Ç—Ä–∞—è –æ—Ü–µ–Ω–∫–∞ —Å–∏–≥–Ω–∞–ª–∞ {symbol}")

        # –ó–∞–≥—Ä—É–∂–∞–µ–º –¥–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω—ã–µ —Ç–∞–π–º—Ñ—Ä–µ–π–º—ã –¥–ª—è –∞–Ω–∞–ª–∏–∑–∞ (–æ–≥—Ä–∞–Ω–∏—á–µ–Ω–Ω—ã–π –Ω–∞–±–æ—Ä –¥–ª—è —Å–∫–æ—Ä–æ—Å—Ç–∏)
        additional_timeframes = {}
        try:
          tf_15m = await self.data_fetcher.get_historical_candles(symbol, Timeframe.FIFTEEN_MINUTES, limit=50)
          if not tf_15m.empty:
            additional_timeframes[Timeframe.FIFTEEN_MINUTES] = tf_15m
        except Exception:
          pass  # –ù–µ –∫—Ä–∏—Ç–∏—á–Ω–æ, –ø—Ä–æ–¥–æ–ª–∂–∞–µ–º –±–µ–∑ –¥–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω—ã—Ö —Ç–∞–π–º—Ñ—Ä–µ–π–º–æ–≤

        quality_metrics = await self.signal_quality_analyzer.rate_signal_quality(
          signal, market_data, additional_timeframes
        )

        # –õ–æ–≥–∏—Ä—É–µ–º —Ä–µ–∑—É–ª—å—Ç–∞—Ç—ã –æ—Ü–µ–Ω–∫–∏
        logger.info(
          f"–ö–∞—á–µ—Å—Ç–≤–æ —Å–∏–≥–Ω–∞–ª–∞ {symbol}: {quality_metrics.overall_score:.2f} ({quality_metrics.quality_category.value})")
        signal_logger.info(
          f"–ö–ê–ß–ï–°–¢–í–û: –û—Ü–µ–Ω–∫–∞ {quality_metrics.overall_score:.2f} - {quality_metrics.quality_category.value}")

        # –ü—Ä–æ–≤–µ—Ä—è–µ–º –º–∏–Ω–∏–º–∞–ª—å–Ω–æ–µ –∫–∞—á–µ—Å—Ç–≤–æ (–±–æ–ª–µ–µ –º—è–≥–∫–∏–π –ø–æ—Ä–æ–≥)
        min_quality_threshold = getattr(self, 'min_quality_score', 0.3)  # –°–Ω–∏–∂–µ–Ω —Å –≤–æ–∑–º–æ–∂–Ω–æ–≥–æ –±–æ–ª–µ–µ –≤—ã—Å–æ–∫–æ–≥–æ –∑–Ω–∞—á–µ–Ω–∏—è

        if quality_metrics.overall_score < min_quality_threshold:
          logger.warning(
            f"–°–∏–≥–Ω–∞–ª {symbol} –æ—Ç–∫–ª–æ–Ω–µ–Ω –∏–∑-–∑–∞ –Ω–∏–∑–∫–æ–≥–æ –∫–∞—á–µ—Å—Ç–≤–∞: {quality_metrics.overall_score:.2f} < {min_quality_threshold}")
          signal_logger.warning(f"–ö–ê–ß–ï–°–¢–í–û: –°–∏–≥–Ω–∞–ª –æ—Ç–∫–ª–æ–Ω–µ–Ω - –Ω–∏–∑–∫–∏–π –±–∞–ª–ª {quality_metrics.overall_score:.2f}")
          return

        # –î–æ–±–∞–≤–ª—è–µ–º –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é –æ –∫–∞—á–µ—Å—Ç–≤–µ –≤ –º–µ—Ç–∞–¥–∞–Ω–Ω—ã–µ
        if hasattr(signal, 'metadata'):
          signal.metadata['quick_quality_check'] = True
          signal.metadata['quality_timestamp'] = datetime.now(timezone.utc).isoformat()
    except Exception as quality_error:
          logger.debug(f"–û—à–∏–±–∫–∞ –±—ã—Å—Ç—Ä–æ–π –æ—Ü–µ–Ω–∫–∏ –∫–∞—á–µ—Å—Ç–≤–∞: {quality_error}")
    #     if hasattr(signal, 'metadata') and signal.metadata:
    #       signal.metadata['quality_score'] = quality_metrics.overall_score
    #       signal.metadata['quality_category'] = quality_metrics.quality_category.value
    #
    #     logger.info(f"‚úÖ –û—Ü–µ–Ω–∫–∞ –∫–∞—á–µ—Å—Ç–≤–∞ –ø—Ä–æ–π–¥–µ–Ω–∞: {quality_metrics.overall_score:.2f}")
    #
    # except Exception as quality_error:
    #   logger.debug(f"–û—à–∏–±–∫–∞ –æ—Ü–µ–Ω–∫–∏ –∫–∞—á–µ—Å—Ç–≤–∞ –¥–ª—è {symbol}: {quality_error}")
      # –ù–µ –±–ª–æ–∫–∏—Ä—É–µ–º —Å–∏–≥–Ω–∞–ª –ø—Ä–∏ –æ—à–∏–±–∫–µ –æ—Ü–µ–Ω–∫–∏ –∫–∞—á–µ—Å—Ç–≤–∞
    # === –ö–û–ù–ï–¶ –ë–õ–û–ö–ê –û–¶–ï–ù–ö–ò –ö–ê–ß–ï–°–¢–í–ê ===

    # –ü—Ä–æ–≤–µ—Ä–∫–∞ —Ä–∏—Å–∫–æ–≤ —Å —É—á–µ—Ç–æ–º –∞–Ω–æ–º–∞–ª–∏–π
    logger.info(f"üí∞ –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ –±–∞–ª–∞–Ω—Å–∞ –∞–∫–∫–∞—É–Ω—Ç–∞...")
    await self.update_account_balance()
    if not self.account_balance or self.account_balance.available_balance_usdt <= 0:
      logger.error(
        f"‚ùå –ù–µ–¥–æ—Å—Ç–∞—Ç–æ—á–Ω—ã–π –±–∞–ª–∞–Ω—Å: {self.account_balance.available_balance_usdt if self.account_balance else 'None'}")
      return
    logger.info(f"‚úÖ –ë–∞–ª–∞–Ω—Å –ø—Ä–æ–≤–µ—Ä–µ–Ω: {self.account_balance.available_balance_usdt:.2f} USDT")

    # –ö–æ—Ä—Ä–µ–∫—Ç–∏—Ä—É–µ–º —Ä–∞–∑–º–µ—Ä –ø–æ–∑–∏—Ü–∏–∏ –Ω–∞ –æ—Å–Ω–æ–≤–µ –æ–±–Ω–∞—Ä—É–∂–µ–Ω–Ω—ã—Ö –∞–Ω–æ–º–∞–ª–∏–π
    position_size_multiplier = 1.0

    if 'anomalies' in signal.metadata:
      anomalies = signal.metadata['anomalies']
      if anomalies:
        # –£–º–µ–Ω—å—à–∞–µ–º —Ä–∞–∑–º–µ—Ä –ø–æ–∑–∏—Ü–∏–∏ –ø—Ä–∏ –∞–Ω–æ–º–∞–ª–∏—è—Ö
        max_severity = max(a['severity'] for a in anomalies)
        position_size_multiplier = max(0.3, 1.0 - max_severity)
        logger.info(f"üîß –†–∞–∑–º–µ—Ä –ø–æ–∑–∏—Ü–∏–∏ —Å–∫–æ—Ä—Ä–µ–∫—Ç–∏—Ä–æ–≤–∞–Ω –Ω–∞ {position_size_multiplier:.2f} –∏–∑-–∑–∞ –∞–Ω–æ–º–∞–ª–∏–π")

    # –í–∞–ª–∏–¥–∞—Ü–∏—è —Å–∏–≥–Ω–∞–ª–∞ —Ä–∏—Å–∫-–º–µ–Ω–µ–¥–∂–µ—Ä–æ–º
    logger.info(f"‚ö†Ô∏è –í–∞–ª–∏–¥–∞—Ü–∏—è —Ä–∏—Å–∫-–º–µ–Ω–µ–¥–∂–µ—Ä–æ–º...")
    risk_decision = await self.risk_manager.validate_signal(
      signal=signal,
      symbol=symbol,
      account_balance=self.account_balance.available_balance_usdt,
      market_data=market_data
    )

    if not risk_decision.get('approved'):
      logger.info(f"‚ùå –°–∏–≥–Ω–∞–ª –¥–ª—è {symbol} –æ—Ç–∫–ª–æ–Ω–µ–Ω —Ä–∏—Å–∫-–º–µ–Ω–µ–¥–∂–µ—Ä–æ–º: {risk_decision.get('reasons')}")
      return

    logger.info(f"‚úÖ –†–∏—Å–∫-–º–µ–Ω–µ–¥–∂–µ—Ä –æ–¥–æ–±—Ä–∏–ª —Å–∏–≥–Ω–∞–ª. –†–µ–∫–æ–º–µ–Ω–¥—É–µ–º—ã–π —Ä–∞–∑–º–µ—Ä: {risk_decision.get('recommended_size', 0):.6f}")

    # –ö–æ—Ä—Ä–µ–∫—Ç–∏—Ä—É–µ–º —Ä–∞–∑–º–µ—Ä —Å —É—á–µ—Ç–æ–º –∞–Ω–æ–º–∞–ª–∏–π
    final_size = risk_decision.get('recommended_size', 0) * position_size_multiplier
    logger.info(f"üìä –§–∏–Ω–∞–ª—å–Ω—ã–π —Ä–∞–∑–º–µ—Ä –ø–æ–∑–∏—Ü–∏–∏: {final_size:.6f}")

    # –°—Ç–∞–≤–∏–º –≤ –æ—á–µ—Ä–µ–¥—å –Ω–∞ –∏—Å–ø–æ–ª–Ω–µ–Ω–∏–µ
    logger.info(f"üì• –ü–æ—Å—Ç–∞–Ω–æ–≤–∫–∞ —Å–∏–≥–Ω–∞–ª–∞ –≤ –æ—á–µ—Ä–µ–¥—å –æ–∂–∏–¥–∞–Ω–∏—è...")
    pending_signals = self.state_manager.get_pending_signals()
    signal_dict = signal.to_dict()
    signal_dict['metadata']['approved_size'] = final_size
    signal_dict['metadata']['signal_time'] = datetime.now(timezone.utc).isoformat()
    signal_dict['metadata']['position_size_multiplier'] = position_size_multiplier

    pending_signals[symbol] = signal_dict
    self.state_manager.update_pending_signals(pending_signals)

    logger.info(f"‚úÖ Enhanced —Å–∏–≥–Ω–∞–ª –¥–ª—è {symbol} –æ–¥–æ–±—Ä–µ–Ω –∏ –ø–æ—Å—Ç–∞–≤–ª–µ–Ω –≤ –æ—á–µ—Ä–µ–¥—å")
    signal_logger.info(f"====== ENHANCED –°–ò–ì–ù–ê–õ –î–õ–Ø {symbol} –ü–û–°–¢–ê–í–õ–ï–ù –í –û–ß–ï–†–ï–î–¨ ======")

  async def _validate_signal_consistency(self, symbol: str, ml_prediction, regime_characteristics,
                                         htf_data: pd.DataFrame) -> tuple[bool, str]:
    """
    –ü—Ä–æ–≤–µ—Ä—è–µ—Ç —Å–æ–≥–ª–∞—Å–æ–≤–∞–Ω–Ω–æ—Å—Ç—å —Å–∏–≥–Ω–∞–ª–∞ –º–µ—Ç–∞-–º–æ–¥–µ–ª–∏ —Å —Ä–µ–∂–∏–º–æ–º —Ä—ã–Ω–∫–∞ –∏ –¥–≤–∏–∂–µ–Ω–∏–µ–º —Ü–µ–Ω—ã

    Returns:
        (is_valid, reason)
    """
    try:
      if not ml_prediction or ml_prediction.signal_type == SignalType.HOLD:
        return True, "HOLD —Å–∏–≥–Ω–∞–ª –≤—Å–µ–≥–¥–∞ –≤–∞–ª–∏–¥–µ–Ω"

      # –ê–Ω–∞–ª–∏–∑ –¥–≤–∏–∂–µ–Ω–∏—è —Ü–µ–Ω—ã
      current_price = htf_data['close'].iloc[-1]
      price_1h_ago = htf_data['close'].iloc[-2] if len(htf_data) >= 2 else current_price
      price_4h_ago = htf_data['close'].iloc[-5] if len(htf_data) >= 5 else current_price

      price_change_1h = ((current_price - price_1h_ago) / price_1h_ago) * 100
      price_change_4h = ((current_price - price_4h_ago) / price_4h_ago) * 100

      # –û–ø—Ä–µ–¥–µ–ª—è–µ–º –Ω–∞–ø—Ä–∞–≤–ª–µ–Ω–∏–µ —Ç—Ä–µ–Ω–¥–∞ –ø–æ —Ä–µ–∂–∏–º—É
      regime_direction = None
      if 'trend_up' in regime_characteristics.primary_regime.value.lower():
        regime_direction = 'BUY'
      elif 'trend_down' in regime_characteristics.primary_regime.value.lower():
        regime_direction = 'SELL'

      # –û–ø—Ä–µ–¥–µ–ª—è–µ–º –Ω–∞–ø—Ä–∞–≤–ª–µ–Ω–∏–µ –ø–æ –¥–≤–∏–∂–µ–Ω–∏—é —Ü–µ–Ω—ã
      price_direction = 'BUY' if price_change_4h > 1 else ('SELL' if price_change_4h < -1 else 'NEUTRAL')

      # –ü—Ä–æ–≤–µ—Ä—è–µ–º —Å–æ–≥–ª–∞—Å–æ–≤–∞–Ω–Ω–æ—Å—Ç—å
      signal_direction = ml_prediction.signal_type.value

      # –ö—Ä–∏—Ç–µ—Ä–∏–∏ –≤–∞–ª–∏–¥–Ω–æ—Å—Ç–∏
      regime_match = regime_direction is None or signal_direction == regime_direction
      price_match = price_direction == 'NEUTRAL' or signal_direction == price_direction

      # –°—Ç—Ä–æ–≥–∞—è –ø—Ä–æ–≤–µ—Ä–∫–∞ –¥–ª—è —Å–∏–ª—å–Ω—ã—Ö —Ä–µ–∂–∏–º–æ–≤
      if regime_characteristics.confidence > 0.8 and regime_direction:
        if not regime_match:
          return False, f"–ö–æ–Ω—Ñ–ª–∏–∫—Ç —Å —Ä–µ–∂–∏–º–æ–º: —Å–∏–≥–Ω–∞–ª {signal_direction}, —Ä–µ–∂–∏–º –æ–∂–∏–¥–∞–µ—Ç {regime_direction}"

      # –ü—Ä–æ–≤–µ—Ä–∫–∞ –ø—Ä–æ—Ç–∏–≤ —Å–∏–ª—å–Ω–æ–≥–æ –¥–≤–∏–∂–µ–Ω–∏—è —Ü–µ–Ω—ã
      if abs(price_change_4h) > 3:  # –°–∏–ª—å–Ω–æ–µ –¥–≤–∏–∂–µ–Ω–∏–µ >3%
        if not price_match:
          return False, f"–ö–æ–Ω—Ñ–ª–∏–∫—Ç —Å —Ü–µ–Ω–æ–π: —Å–∏–≥–Ω–∞–ª {signal_direction}, —Ü–µ–Ω–∞ –¥–≤–∏–∂–µ—Ç—Å—è {price_direction} ({price_change_4h:+.1f}%)"

      # –ü—Ä–æ–≤–µ—Ä–∫–∞ —É–≤–µ—Ä–µ–Ω–Ω–æ—Å—Ç–∏ –≤ –∫–æ–Ω—Ç–µ–∫—Å—Ç–µ
      min_confidence = 0.6 if regime_match and price_match else 0.75
      if ml_prediction.confidence < min_confidence:
        return False, f"–ù–∏–∑–∫–∞—è —É–≤–µ—Ä–µ–Ω–Ω–æ—Å—Ç—å –¥–ª—è —Ç–µ–∫—É—â–∏—Ö —É—Å–ª–æ–≤–∏–π: {ml_prediction.confidence:.3f} < {min_confidence}"

      return True, "–°–∏–≥–Ω–∞–ª —Å–æ–≥–ª–∞—Å–æ–≤–∞–Ω —Å —Ä–µ–∂–∏–º–æ–º –∏ –¥–≤–∏–∂–µ–Ω–∏–µ–º —Ü–µ–Ω—ã"

    except Exception as e:
      logger.error(f"–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏ —Å–æ–≥–ª–∞—Å–æ–≤–∞–Ω–Ω–æ—Å—Ç–∏: {e}")
      return False, f"–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏: {e}"

  async def update_sar_symbols_task(self):
    """–û–±–Ω–æ–≤–ª—è–µ—Ç —Å–ø–∏—Å–æ–∫ —Å–∏–º–≤–æ–ª–æ–≤ –¥–ª—è SAR —Å—Ç—Ä–∞—Ç–µ–≥–∏–∏ –∫–∞–∂–¥—ã–π —á–∞—Å"""
    while self.is_running:
      try:
        if self.sar_strategy:
          # –°–æ—Ö—Ä–∞–Ω—è–µ–º —Ç–µ–∫—É—â–∏–π —Å–ø–∏—Å–æ–∫ –¥–ª—è —Å—Ä–∞–≤–Ω–µ–Ω–∏—è
          old_symbols = set(self.sar_strategy.monitored_symbols.keys())

          # –û–±–Ω–æ–≤–ª—è–µ–º —Å–ø–∏—Å–æ–∫
          updated_symbols = await self.sar_strategy.update_monitored_symbols(self.data_fetcher)
          new_symbols = set(updated_symbols)

          # –û–ø—Ä–µ–¥–µ–ª—è–µ–º –∏–∑–º–µ–Ω–µ–Ω–∏—è
          added_symbols = new_symbols - old_symbols
          removed_symbols = old_symbols - new_symbols

          # –û–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ–º –∏—Å–∫–ª—é—á–µ–Ω–Ω—ã–µ —Å–∏–º–≤–æ–ª—ã
          if removed_symbols:
            await self.sar_strategy.handle_removed_symbols(
              list(removed_symbols), self.position_manager
            )

          # –õ–æ–≥–∏—Ä—É–µ–º –∏–∑–º–µ–Ω–µ–Ω–∏—è
          if added_symbols or removed_symbols:
            logger.info(f"üîÑ SAR —Å–∏–º–≤–æ–ª—ã –æ–±–Ω–æ–≤–ª–µ–Ω—ã: +{len(added_symbols)}, -{len(removed_symbols)}")

          # –û–±–Ω–æ–≤–ª—è–µ–º —Å—Ç–∞—Ç—É—Å –≤ state_manager
          sar_status = self.sar_strategy.get_strategy_status()
          self.state_manager.set_custom_data('sar_strategy_status', sar_status)

      except Exception as e:
        logger.error(f"–û—à–∏–±–∫–∞ –æ–±–Ω–æ–≤–ª–µ–Ω–∏—è SAR —Å–∏–º–≤–æ–ª–æ–≤: {e}")

      await asyncio.sleep(3600)  # 1 —á–∞—Å

  # –ó–∞–¥–∞—á–∞ –æ—á–∏—Å—Ç–∫–∏ –∫—ç—à–∞ SAR —Å—Ç—Ä–∞—Ç–µ–≥–∏–∏
  async def cleanup_sar_cache_task(self):
    """–ü–µ—Ä–∏–æ–¥–∏—á–µ—Å–∫–∏ –æ—á–∏—â–∞–µ—Ç –∫—ç—à SAR —Å—Ç—Ä–∞—Ç–µ–≥–∏–∏"""
    while self.is_running:
      try:
        if self.sar_strategy:
          self.sar_strategy._clear_old_cache()
      except Exception as e:
        logger.error(f"–û—à–∏–±–∫–∞ –æ—á–∏—Å—Ç–∫–∏ –∫—ç—à–∞ SAR: {e}")
      await asyncio.sleep(300)  # 5 –º–∏–Ω—É—Ç

  async def transfer_position_from_strategy(self, symbol: str, position_data: Dict, strategy_name: str):
    """
    –ü—Ä–∏–Ω–∏–º–∞–µ—Ç –ø–æ–∑–∏—Ü–∏—é –æ—Ç —Å—Ç—Ä–∞—Ç–µ–≥–∏–∏ –¥–ª—è –¥–∞–ª—å–Ω–µ–π—à–µ–π –æ–±—Ä–∞–±–æ—Ç–∫–∏ –æ—Å–Ω–æ–≤–Ω–æ–π —Å–∏—Å—Ç–µ–º–æ–π
    """
    try:
      logger.info(f"üì• –ü–æ–ª—É—á–µ–Ω–∞ –ø–æ–∑–∏—Ü–∏—è {symbol} –æ—Ç —Å—Ç—Ä–∞—Ç–µ–≥–∏–∏ {strategy_name}")

      # –î–æ–±–∞–≤–ª—è–µ–º –ø–æ–∑–∏—Ü–∏—é –≤ –æ—Å–Ω–æ–≤–Ω–æ–π —Å–ø–∏—Å–æ–∫ –¥–ª—è –º–æ–Ω–∏—Ç–æ—Ä–∏–Ω–≥–∞
      self.open_positions[symbol] = position_data

      # –õ–æ–≥–∏—Ä—É–µ–º –¥–µ—Ç–∞–ª–∏ –ø–µ—Ä–µ–¥–∞—á–∏
      transfer_reason = position_data.get('transfer_reason', 'unknown')
      logger.info(f"üìã –ü–æ–∑–∏—Ü–∏—è {symbol} –ø—Ä–∏–Ω—è—Ç–∞ –≤ –æ—Å–Ω–æ–≤–Ω—É—é –æ–±—Ä–∞–±–æ—Ç–∫—É. –ü—Ä–∏—á–∏–Ω–∞: {transfer_reason}")

      # –£–≤–µ–¥–æ–º–ª—è–µ–º —Å–∏—Å—Ç–µ–º—É –æ –Ω–µ–æ–±—Ö–æ–¥–∏–º–æ—Å—Ç–∏ –æ—Å–æ–±–æ–≥–æ –≤–Ω–∏–º–∞–Ω–∏—è –∫ —ç—Ç–æ–π –ø–æ–∑–∏—Ü–∏–∏
      if hasattr(self, 'special_monitoring_positions'):
        self.special_monitoring_positions.add(symbol)

      return True

    except Exception as e:
      logger.error(f"–û—à–∏–±–∫–∞ –ø–µ—Ä–µ–¥–∞—á–∏ –ø–æ–∑–∏—Ü–∏–∏ {symbol} –æ—Ç {strategy_name}: {e}")
      return False

  async def train_anomaly_detector(self, symbols: List[str], lookback_days: int = 45):
    """
    –û–±—É—á–∞–µ—Ç –¥–µ—Ç–µ–∫—Ç–æ—Ä –∞–Ω–æ–º–∞–ª–∏–π –Ω–∞ –∏—Å—Ç–æ—Ä–∏—á–µ—Å–∫–∏—Ö –¥–∞–Ω–Ω—ã—Ö
    """
    logger.info(f"–ù–∞—á–∞–ª–æ –æ–±—É—á–µ–Ω–∏—è –¥–µ—Ç–µ–∫—Ç–æ—Ä–∞ –∞–Ω–æ–º–∞–ª–∏–π –Ω–∞ {len(symbols)} —Å–∏–º–≤–æ–ª–∞—Ö...")

    if not self.anomaly_detector:
      self.anomaly_detector = MarketAnomalyDetector()

    all_data = []

    for symbol in symbols:
      try:
        # –ü–æ–ª—É—á–∞–µ–º –∏—Å—Ç–æ—Ä–∏—á–µ—Å–∫–∏–µ –¥–∞–Ω–Ω—ã–µ
        data = await self.data_fetcher.get_historical_candles(
          symbol,
          Timeframe.ONE_HOUR,
          limit=24 * lookback_days
        )

        if not data.empty and len(data) > 100:
          all_data.append(data)
          logger.info(f"–ó–∞–≥—Ä—É–∂–µ–Ω—ã –¥–∞–Ω–Ω—ã–µ –¥–ª—è {symbol}: {len(data)} —Å–≤–µ—á–µ–π")

      except Exception as e:
        logger.error(f"–û—à–∏–±–∫–∞ –∑–∞–≥—Ä—É–∑–∫–∏ –¥–∞–Ω–Ω—ã—Ö –¥–ª—è {symbol}: {e}")

    if all_data:
      # –û–±—ä–µ–¥–∏–Ω—è–µ–º –≤—Å–µ –¥–∞–Ω–Ω—ã–µ
      combined_data = pd.concat(all_data, ignore_index=True)

      # –û–±—É—á–∞–µ–º –¥–µ—Ç–µ–∫—Ç–æ—Ä
      self.anomaly_detector.fit(combined_data)

      # –°–æ—Ö—Ä–∞–Ω—è–µ–º
      self.anomaly_detector.save("ml_models/anomaly_detector.pkl")

      # –í—ã–≤–æ–¥–∏–º —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫—É
      stats = self.anomaly_detector.get_statistics()
      logger.info(f"–î–µ—Ç–µ–∫—Ç–æ—Ä –∞–Ω–æ–º–∞–ª–∏–π –æ–±—É—á–µ–Ω. –°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞: {stats}")
    else:
      logger.error("–ù–µ–¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ –¥–∞–Ω–Ω—ã—Ö –¥–ª—è –æ–±—É—á–µ–Ω–∏—è –¥–µ—Ç–µ–∫—Ç–æ—Ä–∞ –∞–Ω–æ–º–∞–ª–∏–π")

  async def train_enhanced_ml_model(self, symbols: List[str], lookback_days: int = 60):
    """
    –û–±—É—á–∞–µ—Ç —Ä–∞—Å—à–∏—Ä–µ–Ω–Ω—É—é ML –º–æ–¥–µ–ª—å —Å –ø—Ä–∞–≤–∏–ª—å–Ω—ã–º –≤—ã—Ä–∞–≤–Ω–∏–≤–∞–Ω–∏–µ–º –¥–∞–Ω–Ω—ã—Ö
    """
    logger.info(f"–ù–∞—á–∞–ª–æ –æ–±—É—á–µ–Ω–∏—è Enhanced ML –º–æ–¥–µ–ª–∏ –Ω–∞ {len(symbols)} —Å–∏–º–≤–æ–ª–∞—Ö...")

    logger.info("=== –û–¢–õ–ê–î–ö–ê –°–û–ó–î–ê–ù–ò–Ø –î–ê–ù–ù–´–• ===")

    # –¢–µ—Å—Ç–∏—Ä—É–µ–º –Ω–∞ –æ–¥–Ω–æ–º —Å–∏–º–≤–æ–ª–µ
    test_symbol = symbols[0]
    test_data = await self.data_fetcher.get_historical_candles(
      test_symbol, Timeframe.ONE_HOUR, limit=100
    )

    logger.info(f"–¢–µ—Å—Ç–æ–≤—ã–µ –¥–∞–Ω–Ω—ã–µ {test_symbol}:")
    logger.info(f"  –†–∞–∑–º–µ—Ä: {test_data.shape}")
    logger.info(f"  –ò–Ω–¥–µ–∫—Å: {type(test_data.index)}")
    logger.info(f"  –ö–æ–ª–æ–Ω–∫–∏: {test_data.columns.tolist()}")

    test_labels = self._create_ml_labels(test_data)
    if test_labels is not None:
      logger.info(f"–¢–µ—Å—Ç–æ–≤—ã–µ –º–µ—Ç–∫–∏:")
      logger.info(f"  –†–∞–∑–º–µ—Ä: {len(test_labels)}")
      logger.info(f"  –ò–Ω–¥–µ–∫—Å: {type(test_labels.index)}")
      logger.info(f"  –†–∞—Å–ø—Ä–µ–¥–µ–ª–µ–Ω–∏–µ: {test_labels.value_counts().to_dict()}")

    logger.info("=== –ö–û–ù–ï–¶ –û–¢–õ–ê–î–ö–ò ===")

    if not self.enhanced_ml_model:
      self.enhanced_ml_model = EnhancedEnsembleModel(self.anomaly_detector)

    all_features = []
    all_labels = []

    for symbol in symbols:  # –û–≥—Ä–∞–Ω–∏—á–∏–≤–∞–µ–º –¥–ª—è –¥–µ–º–æ–Ω—Å—Ç—Ä–∞—Ü–∏–∏
      try:
        # –ü–æ–ª—É—á–∞–µ–º –¥–∞–Ω–Ω—ã–µ
        data = await self.data_fetcher.get_historical_candles(
          symbol,
          Timeframe.ONE_HOUR,
          limit=24 * lookback_days
        )

        if data.empty or len(data) < 100:
          logger.warning(f"–ù–µ–¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ –¥–∞–Ω–Ω—ã—Ö –¥–ª—è {symbol}: {len(data)} —Å–≤–µ—á–µ–π")
          continue

        # –£–±–µ–∂–¥–∞–µ–º—Å—è, —á—Ç–æ –¥–∞–Ω–Ω—ã–µ –∏–º–µ—é—Ç datetime –∏–Ω–¥–µ–∫—Å
        if not isinstance(data.index, pd.DatetimeIndex):
          if 'timestamp' in data.columns:
            data = data.set_index('timestamp')
          else:
            # –°–æ–∑–¥–∞–µ–º datetime –∏–Ω–¥–µ–∫—Å
            start_time = datetime.now() - timedelta(hours=len(data))
            data.index = pd.date_range(start=start_time, periods=len(data), freq='1H')

        # –°–æ–∑–¥–∞–µ–º –º–µ—Ç–∫–∏
        labels = self._create_ml_labels(data)
        if labels is None or len(labels) < 50:
          logger.warning(f"–ù–µ —É–¥–∞–ª–æ—Å—å —Å–æ–∑–¥–∞—Ç—å –¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ –º–µ—Ç–æ–∫ –¥–ª—è {symbol}")
          continue

        # –£–±–µ–∂–¥–∞–µ–º—Å—è, —á—Ç–æ –¥–∞–Ω–Ω—ã–µ –∏ –º–µ—Ç–∫–∏ –∏–º–µ—é—Ç –ø–µ—Ä–µ—Å–µ–∫–∞—é—â–∏–µ—Å—è –∏–Ω–¥–µ–∫—Å—ã
        common_index = data.index.intersection(labels.index)
        if len(common_index) < 50:
          logger.warning(f"–ú–∞–ª–æ –æ–±—â–∏—Ö –≤—Ä–µ–º–µ–Ω–Ω—ã—Ö —Ç–æ—á–µ–∫ –¥–ª—è {symbol}: {len(common_index)}")
          continue

        # –ë–µ—Ä–µ–º —Ç–æ–ª—å–∫–æ –æ–±—â–∏–µ –¥–∞–Ω–Ω—ã–µ
        data_aligned = data.loc[common_index]
        labels_aligned = labels.loc[common_index]

        # –î–æ–±–∞–≤–ª—è–µ–º —Å–∏–º–≤–æ–ª –∫ –¥–∞–Ω–Ω—ã–º –¥–ª—è –∏–¥–µ–Ω—Ç–∏—Ñ–∏–∫–∞—Ü–∏–∏
        data_aligned = data_aligned.copy()
        data_aligned['symbol'] = symbol

        all_features.append(data_aligned)
        all_labels.append(labels_aligned)

        logger.info(f"–ü–æ–¥–≥–æ—Ç–æ–≤–ª–µ–Ω—ã –¥–∞–Ω–Ω—ã–µ –¥–ª—è {symbol}: {len(data_aligned)} –æ–±—Ä–∞–∑—Ü–æ–≤")

      except Exception as e:
        logger.error(f"–û—à–∏–±–∫–∞ –ø–æ–¥–≥–æ—Ç–æ–≤–∫–∏ –¥–∞–Ω–Ω—ã—Ö –¥–ª—è {symbol}: {e}")
        continue

    if not all_features:
      logger.error("–ù–µ—Ç –¥–∞–Ω–Ω—ã—Ö –¥–ª—è –æ–±—É—á–µ–Ω–∏—è Enhanced ML –º–æ–¥–µ–ª–∏")
      return

    try:
      # –û–±—ä–µ–¥–∏–Ω—è–µ–º –¥–∞–Ω–Ω—ã–µ
      combined_features = pd.concat(all_features, ignore_index=False)
      combined_labels = pd.concat(all_labels, ignore_index=False)

      # –°–±—Ä–∞—Å—ã–≤–∞–µ–º –∏–Ω–¥–µ–∫—Å –¥–ª—è –∏–∑–±–µ–∂–∞–Ω–∏—è –∫–æ–Ω—Ñ–ª–∏–∫—Ç–æ–≤ –ø—Ä–∏ –æ–±—ä–µ–¥–∏–Ω–µ–Ω–∏–∏
      combined_features = combined_features.reset_index(drop=True)
      combined_labels = combined_labels.reset_index(drop=True)

      # –£–±–µ–∂–¥–∞–µ–º—Å—è, —á—Ç–æ –∏–Ω–¥–µ–∫—Å—ã —Å–æ–æ—Ç–≤–µ—Ç—Å—Ç–≤—É—é—Ç
      if len(combined_features) != len(combined_labels):
        min_len = min(len(combined_features), len(combined_labels))
        combined_features = combined_features.iloc[:min_len]
        combined_labels = combined_labels.iloc[:min_len]

      logger.info(f"–§–∏–Ω–∞–ª—å–Ω—ã–µ —Ä–∞–∑–º–µ—Ä—ã –¥–∞–Ω–Ω—ã—Ö: features={combined_features.shape}, labels={combined_labels.shape}")

      # –ü–æ–ª—É—á–∞–µ–º –≤–Ω–µ—à–Ω–∏–µ –¥–∞–Ω–Ω—ã–µ (BTC –∫–∞–∫ –ø—Ä–∏–º–µ—Ä)
      btc_data = await self.data_fetcher.get_historical_candles(
        "BTCUSDT",
        Timeframe.ONE_HOUR,
        limit=24 * lookback_days
      )

      external_data = None
      if not btc_data.empty:
        # –ü—Ä–∏–≤–æ–¥–∏–º BTC –¥–∞–Ω–Ω—ã–µ –∫ —Ç–æ–º—É –∂–µ —Ñ–æ—Ä–º–∞—Ç—É
        if not isinstance(btc_data.index, pd.DatetimeIndex):
          if 'timestamp' in btc_data.columns:
            btc_data = btc_data.set_index('timestamp')
          else:
            start_time = datetime.now() - timedelta(hours=len(btc_data))
            btc_data.index = pd.date_range(start=start_time, periods=len(btc_data), freq='1H')

        external_data = {'BTC': btc_data}

      logger.info(f"–†–∞–∑–º–µ—Ä—ã –¥–∞–Ω–Ω—ã—Ö –ø–µ—Ä–µ–¥ –æ–±—É—á–µ–Ω–∏–µ–º: features={combined_features.shape}, labels={combined_labels.shape}")
      logger.info(f"–ò–Ω–¥–µ–∫—Å—ã: features={combined_features.index.min()} - {combined_features.index.max()}")
      logger.info(f"–ò–Ω–¥–µ–∫—Å—ã: labels={combined_labels.index.min()} - {combined_labels.index.max()}")

      # –£–±–µ–∂–¥–∞–µ–º—Å—è, —á—Ç–æ –∏–Ω–¥–µ–∫—Å—ã –∫–æ—Ä—Ä–µ–∫—Ç–Ω—ã
      if not combined_features.index.equals(combined_labels.index):
        logger.warning("–ò–Ω–¥–µ–∫—Å—ã –ø—Ä–∏–∑–Ω–∞–∫–æ–≤ –∏ –º–µ—Ç–æ–∫ –Ω–µ —Å–æ–≤–ø–∞–¥–∞—é—Ç, –≤—ã–ø–æ–ª–Ω—è–µ–º –≤—ã—Ä–∞–≤–Ω–∏–≤–∞–Ω–∏–µ...")
        common_idx = combined_features.index.intersection(combined_labels.index)
        combined_features = combined_features.loc[common_idx]
        combined_labels = combined_labels.loc[common_idx]
        logger.info(f"–ü–æ—Å–ª–µ –≤—ã—Ä–∞–≤–Ω–∏–≤–∞–Ω–∏—è: {len(common_idx)} –æ–±—â–∏—Ö –æ–±—Ä–∞–∑—Ü–æ–≤")

      diagnosis = self.enhanced_ml_model.diagnose_training_issues(
        combined_features,
        combined_labels,
        )
      try:
        diagnosis_status = diagnosis.get('overall_status', '–ù–ï–ò–ó–í–ï–°–¢–ù–û')
        logger.info(f"–î–∏–∞–≥–Ω–æ—Å—Ç–∏–∫–∞: {diagnosis_status}")

        # –î–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω–∞—è –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—è
        if diagnosis.get('issues_found'):
          logger.warning(f"–û–±–Ω–∞—Ä—É–∂–µ–Ω–æ –ø—Ä–æ–±–ª–µ–º: {len(diagnosis['issues_found'])}")
          for issue in diagnosis['issues_found'][:3]:  # –ü–æ–∫–∞–∑—ã–≤–∞–µ–º –ø–µ—Ä–≤—ã–µ 3
            logger.warning(f"  - {issue}")

        if diagnosis.get('warnings'):
          logger.info(f"–ü—Ä–µ–¥—É–ø—Ä–µ–∂–¥–µ–Ω–∏–π: {len(diagnosis['warnings'])}")

      except Exception as log_error:
        logger.error(f"–û—à–∏–±–∫–∞ –ª–æ–≥–∏—Ä–æ–≤–∞–Ω–∏—è –¥–∏–∞–≥–Ω–æ—Å—Ç–∏–∫–∏: {log_error}")

      # –û–±—É—á–∞–µ–º –º–æ–¥–µ–ª—å
      # self.enhanced_ml_model.fit_with_diagnostics(
      #   combined_features,
      #   combined_labels,
      #   external_data=external_data,
      #   optimize_features=True,
      #   verbose=True
      # )
      # self.enhanced_ml_model.print_training_report(combined_features,
      #   combined_labels, diagnosis)

      # –û–±—É—á–∞–µ–º –º–æ–¥–µ–ª—å —Å –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ–º –ø–æ–¥–±–æ—Ä–∞ –≥–∏–ø–µ—Ä–ø–∞—Ä–∞–º–µ—Ç—Ä–æ–≤
      logger.info("–ó–∞–ø—É—Å–∫ –æ–±—É—á–µ–Ω–∏—è —Å –ø–æ–¥–±–æ—Ä–æ–º –≥–∏–ø–µ—Ä–ø–∞—Ä–∞–º–µ—Ç—Ä–æ–≤...")
      self.enhanced_ml_model.fit_with_hyperparameter_tuning(
        X_train_data=combined_features,  # –ò—Å–ø–æ–ª—å–∑—É–µ–º –ø–æ–¥–≥–æ—Ç–æ–≤–ª–µ–Ω–Ω—ã–µ –¥–∞–Ω–Ω—ã–µ
        y_train_data=combined_labels,  # –ò—Å–ø–æ–ª—å–∑—É–µ–º –ø–æ–¥–≥–æ—Ç–æ–≤–ª–µ–Ω–Ω—ã–µ –º–µ—Ç–∫–∏
        external_data=external_data
      )

      # –û—Ç—á–µ—Ç –º–æ–∂–Ω–æ –æ—Å—Ç–∞–≤–∏—Ç—å, –æ–Ω –ø–æ–∫–∞–∂–µ—Ç —Ä–µ–∑—É–ª—å—Ç–∞—Ç—ã —É–∂–µ –ø–æ—Å–ª–µ —Ç—é–Ω–∏–Ω–≥–∞
      self.enhanced_ml_model.print_training_report(combined_features,
                                                   combined_labels, diagnosis)


      health = self.enhanced_ml_model.get_model_health_status()
      logger.info(f"–ó–¥–æ—Ä–æ–≤—å–µ –º–æ–¥–µ–ª–∏: {health['overall_health']}")


      # –°–æ—Ö—Ä–∞–Ω—è–µ–º
      self.enhanced_ml_model.save("ml_models/enhanced_model.pkl")

      logger.info("Enhanced ML –º–æ–¥–µ–ª—å —É—Å–ø–µ—à–Ω–æ –æ–±—É—á–µ–Ω–∞ –∏ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∞")

    except Exception as e:
      logger.error(f"–û—à–∏–±–∫–∞ –ø—Ä–∏ —Ñ–∏–Ω–∞–ª—å–Ω–æ–º –æ–±—É—á–µ–Ω–∏–∏ –º–æ–¥–µ–ª–∏: {e}")
      raise

  async def get_market_regime(self, symbol: str, force_check: bool = False) -> Optional[RegimeCharacteristics]:
    """
    –ü–æ–ª—É—á–∞–µ—Ç —Ç–µ–∫—É—â–∏–π —Ä—ã–Ω–æ—á–Ω—ã–π —Ä–µ–∂–∏–º –¥–ª—è —Å–∏–º–≤–æ–ª–∞
    """
    try:
      # –ü–æ–ª—É—á–∞–µ–º –¥–∞–Ω–Ω—ã–µ –¥–ª—è –∞–Ω–∞–ª–∏–∑–∞
      data = await self.data_fetcher.get_historical_candles(
        symbol, Timeframe.ONE_HOUR, limit=200
      )

      if data.empty or len(data) < 50:
        return None

      # –ò—Å–ø–æ–ª—å–∑—É–µ–º —Å—É—â–µ—Å—Ç–≤—É—é—â–∏–π –¥–µ—Ç–µ–∫—Ç–æ—Ä
      regime_characteristics = await self.market_regime_detector.detect_regime(symbol, data)

      # –õ–æ–≥–∏—Ä—É–µ–º —Å —É—á–µ—Ç–æ–º –∞–Ω–æ–º–∞–ª–∏–π
      if self.anomaly_detector and regime_characteristics:
        anomalies = self.anomaly_detector.detect_anomalies(data, symbol)
        if anomalies:
          logger.warning(f"‚ö†Ô∏è –†–µ–∂–∏–º {symbol}: {regime_characteristics.primary_regime.value} "
                         f"+ –æ–±–Ω–∞—Ä—É–∂–µ–Ω—ã –∞–Ω–æ–º–∞–ª–∏–∏!")

      return regime_characteristics

    except Exception as e:
      logger.error(f"–û—à–∏–±–∫–∞ –æ–ø—Ä–µ–¥–µ–ª–µ–Ω–∏—è —Ä–µ–∂–∏–º–∞ –¥–ª—è {symbol}: {e}")
      return None


  def _create_ml_labels(self, data: pd.DataFrame) -> Optional[pd.Series]:
    """
    –°–æ–∑–¥–∞–µ—Ç –º–µ—Ç–∫–∏ –¥–ª—è –æ–±—É—á–µ–Ω–∏—è ML —Å –ø—Ä–∞–≤–∏–ª—å–Ω—ã–º–∏ –∏–Ω–¥–µ–∫—Å–∞–º–∏
    """
    try:
      # –£–±–µ–∂–¥–∞–µ–º—Å—è, —á—Ç–æ –¥–∞–Ω–Ω—ã–µ –∏–º–µ—é—Ç –ø—Ä–∞–≤–∏–ª—å–Ω—ã–π –∏–Ω–¥–µ–∫—Å
      if not isinstance(data.index, pd.DatetimeIndex):
        if 'timestamp' in data.columns:
          data = data.set_index('timestamp')
        else:
          # –°–æ–∑–¥–∞–µ–º datetime –∏–Ω–¥–µ–∫—Å –Ω–∞ –æ—Å–Ω–æ–≤–µ –ø–æ–∑–∏—Ü–∏–∏
          start_time = datetime.now() - timedelta(hours=len(data))
          data.index = pd.date_range(start=start_time, periods=len(data), freq='1H')

      if 'close' not in data.columns:
        logger.warning("–ù–µ—Ç –∫–æ–ª–æ–Ω–∫–∏ 'close' –¥–ª—è —Å–æ–∑–¥–∞–Ω–∏—è –º–µ—Ç–æ–∫")
        return None

      # –í—ã—á–∏—Å–ª—è–µ–º –±—É–¥—É—â–∏–µ –¥–æ—Ö–æ–¥–Ω–æ—Å—Ç–∏
      future_periods = 10  # –°–º–æ—Ç—Ä–∏–º –Ω–∞ 10 –ø–µ—Ä–∏–æ–¥–æ–≤ –≤–ø–µ—Ä–µ–¥
      future_returns = data['close'].pct_change(periods=future_periods).shift(-future_periods)

      # –ü–æ—Ä–æ–≥–∏ –¥–ª—è –∫–ª–∞—Å—Å–∏—Ñ–∏–∫–∞—Ü–∏–∏
      buy_threshold = 0.02  # 2% —Ä–æ—Å—Ç
      sell_threshold = -0.02  # 2% –ø–∞–¥–µ–Ω–∏–µ

      # –°–æ–∑–¥–∞–µ–º –º–µ—Ç–∫–∏ —Å —Ç–µ–º –∂–µ –∏–Ω–¥–µ–∫—Å–æ–º, —á—Ç–æ –∏ —É –¥–∞–Ω–Ω—ã—Ö
      labels = pd.Series(index=data.index, dtype=int, name='labels')

      # –ó–∞–ø–æ–ª–Ω—è–µ–º –º–µ—Ç–∫–∏
      labels[future_returns > buy_threshold] = 2  # BUY
      labels[future_returns < sell_threshold] = 0  # SELL
      labels[(future_returns >= sell_threshold) & (future_returns <= buy_threshold)] = 1  # HOLD

      # –£–¥–∞–ª—è–µ–º NaN –≤ –∫–æ–Ω—Ü–µ (–≥–¥–µ –Ω–µ—Ç –±—É–¥—É—â–∏—Ö –¥–∞–Ω–Ω—ã—Ö)
      labels = labels.dropna()

      logger.debug(f"–°–æ–∑–¥–∞–Ω–æ –º–µ—Ç–æ–∫: {len(labels)}, —Ä–∞—Å–ø—Ä–µ–¥–µ–ª–µ–Ω–∏–µ: {labels.value_counts().to_dict()}")

      return labels

    except Exception as e:
      logger.error(f"–û—à–∏–±–∫–∞ –ø—Ä–∏ —Å–æ–∑–¥–∞–Ω–∏–∏ –º–µ—Ç–æ–∫: {e}")
      return None

  async def get_system_health_report(self) -> Dict[str, Any]:
    """
    –†–∞—Å—à–∏—Ä–µ–Ω–Ω—ã–π –æ—Ç—á–µ—Ç –æ —Å–æ—Å—Ç–æ—è–Ω–∏–∏ —Å–∏—Å—Ç–µ–º—ã
    """
    report = {
      'timestamp': datetime.now().isoformat(),
      'components': {
        'anomaly_detector': {
          'loaded': self.anomaly_detector is not None,
          'fitted': self.anomaly_detector.is_fitted if self.anomaly_detector else False,
          'statistics': self.anomaly_detector.get_statistics() if self.anomaly_detector else None
        },
        'enhanced_ml': {
          'loaded': self.enhanced_ml_model is not None,
          'fitted': self.enhanced_ml_model.is_fitted if self.enhanced_ml_model else False
        },
        'performance': {
          'cache_stats': self.data_fetcher.get_cache_stats(),
          'api_requests': getattr(self.connector, 'request_stats', {})
        }
      }
    }

    # –î–æ–±–∞–≤–ª—è–µ–º —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫—É –ø–æ –∞–Ω–æ–º–∞–ª–∏—è–º –∑–∞ –ø–æ—Å–ª–µ–¥–Ω–∏–µ 24 —á–∞—Å–∞
    if self.anomaly_detector and hasattr(self.anomaly_detector, 'anomaly_history'):
      recent_anomalies = [
        a for a in self.anomaly_detector.anomaly_history
        if (datetime.now() - a.timestamp).total_seconds() < 86400
      ]

      report['anomalies_24h'] = {
        'total': len(recent_anomalies),
        'by_type': {},
        'critical': len([a for a in recent_anomalies if a.severity > 0.8])
      }

      for anomaly in recent_anomalies:
        anomaly_type = anomaly.anomaly_type.value
        report['anomalies_24h']['by_type'][anomaly_type] = \
          report['anomalies_24h']['by_type'].get(anomaly_type, 0) + 1

    return report


  async def initialize(self):
    """
    –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è —Å–∏—Å—Ç–µ–º—ã —Å –ì–ò–ë–†–ò–î–ù–û–ô –ª–æ–≥–∏–∫–æ–π –≤—ã–±–æ—Ä–∞ —Å–∏–º–≤–æ–ª–æ–≤.
    """
    logger.info("–ù–∞—á–∞–ª–æ –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏–∏ —Å–∏—Å—Ç–µ–º—ã...")

    # –ó–∞–≥—Ä—É–∂–∞–µ–º –∫–æ–Ω—Ñ–∏–≥
    config_manager = ConfigManager()  # –£–±–µ–¥–∏—Ç–µ—Å—å, —á—Ç–æ ConfigManager –∏–º–ø–æ—Ä—Ç–∏—Ä–æ–≤–∞–Ω
    self.config = config_manager.load_config()

    mode = self.config.get('general_settings', {}).get('symbol_selection_mode', 'dynamic')
    blacklist = self.config.get('general_settings', {}).get('symbol_blacklist', [])

    if mode == 'static':
      logger.info("–í—ã–±—Ä–∞–Ω —Å—Ç–∞—Ç–∏—á–µ—Å–∫–∏–π —Ä–µ–∂–∏–º –≤—ã–±–æ—Ä–∞ —Å–∏–º–≤–æ–ª–æ–≤.")
      self.active_symbols = self.config.get('general_settings', {}).get('static_symbol_list', [])
    else:  # –î–∏–Ω–∞–º–∏—á–µ—Å–∫–∏–π —Ä–µ–∂–∏–º
      logger.info("–í—ã–±—Ä–∞–Ω –¥–∏–Ω–∞–º–∏—á–µ—Å–∫–∏–π —Ä–µ–∂–∏–º –≤—ã–±–æ—Ä–∞ —Å–∏–º–≤–æ–ª–æ–≤.")
      limit = self.config.get('general_settings', {}).get('dynamic_symbols_count', 200)
      all_symbols = await self.data_fetcher.get_active_symbols_by_volume(limit=limit)
      # –ü—Ä–∏–º–µ–Ω—è–µ–º —á–µ—Ä–Ω—ã–π —Å–ø–∏—Å–æ–∫
      self.watchlist_symbols = [s for s in all_symbols if s not in blacklist]

      # –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä—É–µ–º focus list
      if self.priority_monitoring_enabled:
        await self.update_focus_list()
        # –ê–∫—Ç–∏–≤–Ω—ã–µ —Å–∏–º–≤–æ–ª—ã = watchlist –¥–ª—è —Å–æ–≤–º–µ—Å—Ç–∏–º–æ—Å—Ç–∏
        self.active_symbols = self.watchlist_symbols
      else:
        # –ï—Å–ª–∏ –ø—Ä–∏–æ—Ä–∏—Ç–µ—Ç–Ω—ã–π –º–æ–Ω–∏—Ç–æ—Ä–∏–Ω–≥ –≤—ã–∫–ª—é—á–µ–Ω, —Ä–∞–±–æ—Ç–∞–µ–º –ø–æ-—Å—Ç–∞—Ä–æ–º—É
        self.active_symbols = self.watchlist_symbols
        self.focus_list_symbols = []

    if not self.active_symbols:
      logger.error("–ù–µ —É–¥–∞–ª–æ—Å—å –≤—ã–±—Ä–∞—Ç—å –Ω–∏ –æ–¥–Ω–æ–≥–æ –∞–∫—Ç–∏–≤–Ω–æ–≥–æ —Å–∏–º–≤–æ–ª–∞ –¥–ª—è —Ç–æ—Ä–≥–æ–≤–ª–∏. –ü—Ä–æ–≤–µ—Ä—å—Ç–µ config.json.")
      return False

    logger.info(f"–ê–∫—Ç–∏–≤–Ω—ã–µ —Å–∏–º–≤–æ–ª—ã –¥–ª—è —Ç–æ—Ä–≥–æ–≤–ª–∏ ({len(self.active_symbols)}): {self.active_symbols}")

    await self.update_account_balance()

    try:
      # –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è Shadow Trading
      self.shadow_trading = ShadowTradingManager(self.db_manager, self.data_fetcher)
      await self.shadow_trading.start_enhanced_monitoring()
      logger.info("‚úÖ Shadow Trading —Å–∏—Å—Ç–µ–º–∞ –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä–æ–≤–∞–Ω–∞ –∏ –∑–∞–ø—É—â–µ–Ω–∞")
    except Exception as e:
      logger.error(f"–û—à–∏–±–∫–∞ –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏–∏ Shadow Trading: {e}")
      self.shadow_trading = None

    # # –£—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º –ø–ª–µ—á–æ –¥–ª—è –≤—Å–µ—Ö –∞–∫—Ç–∏–≤–Ω—ã—Ö —Å–∏–º–≤–æ–ª–æ–≤
    # leverage = self.config.get('trade_settings', {}).get('leverage', 10)
    # for symbol in self.active_symbols:
    #   # self.current_leverage.setdefault(symbol, leverage) # –≠—Ç–∞ —Å—Ç—Ä–æ–∫–∞ –Ω–µ –Ω—É–∂–Ω–∞
    #   await self.set_leverage_for_symbol(symbol, leverage)

    logger.info("–ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è —Å–∏—Å—Ç–µ–º—ã –∑–∞–≤–µ—Ä—à–µ–Ω–∞.")
    return True

  async def _ensure_model_exists(self):
    """
    –£–õ–£–ß–®–ï–ù–ù–ê–Ø –í–ï–†–°–ò–Ø: –ü—Ä–æ–≤–µ—Ä—è–µ—Ç, –∑–∞–≥—Ä—É–∂–µ–Ω–∞ –ª–∏ –º–æ–¥–µ–ª—å –≤ —Å–∞–º—É —Å—Ç—Ä–∞—Ç–µ–≥–∏—é,
    –∞ –Ω–µ –ø—Ä–æ—Å—Ç–æ –Ω–∞–ª–∏—á–∏–µ —Ñ–∞–π–ª–∞ –Ω–∞ –¥–∏—Å–∫–µ.
    """
    # –ù–∞—Ö–æ–¥–∏–º –Ω–∞—à—É ML-—Å—Ç—Ä–∞—Ç–µ–≥–∏—é –≤ –º–µ–Ω–µ–¥–∂–µ—Ä–µ
    ml_strategy = self.strategy_manager.strategies.get('Live_ML_Strategy')

    # –ü—Ä–æ–≤–µ—Ä—è–µ–º, –µ—Å—Ç—å –ª–∏ —É —Å—Ç—Ä–∞—Ç–µ–≥–∏–∏ –∑–∞–≥—Ä—É–∂–µ–Ω–Ω–∞—è –º–æ–¥–µ–ª—å –≤ –ø–∞–º—è—Ç–∏
    if ml_strategy and ml_strategy.model is not None:
      logger.info("–†–∞–±–æ—á–∞—è –º–æ–¥–µ–ª—å —É–∂–µ –∑–∞–≥—Ä—É–∂–µ–Ω–∞ –≤ —Å—Ç—Ä–∞—Ç–µ–≥–∏—é. –ü—Ä–æ–ø—É—Å–∫ –ø–µ—Ä–≤–∏—á–Ω–æ–≥–æ –æ–±—É—á–µ–Ω–∏—è.")
      return True  # –ú–æ–¥–µ–ª—å –Ω–∞ –º–µ—Å—Ç–µ, –≤—Å–µ –≤ –ø–æ—Ä—è–¥–∫–µ

    # –ï—Å–ª–∏ –º–æ–¥–µ–ª—å –Ω–µ –∑–∞–≥—Ä—É–∂–µ–Ω–∞, –∑–∞–ø—É—Å–∫–∞–µ–º –ø–µ—Ä–≤–∏—á–Ω–æ–µ –æ–±—É—á–µ–Ω–∏–µ
    logger.warning("–†–∞–±–æ—á–∞—è –º–æ–¥–µ–ª—å –Ω–µ –∑–∞–≥—Ä—É–∂–µ–Ω–∞ –≤ —Å—Ç—Ä–∞—Ç–µ–≥–∏—é. –ó–∞–ø—É—Å–∫ –ø–µ—Ä–≤–∏—á–Ω–æ–≥–æ –æ–±—É—á–µ–Ω–∏—è...")

    limit = self.config.get('general_settings', {}).get('dynamic_symbols_count', 20)
    symbols_for_training = await self.data_fetcher.get_active_symbols_by_volume(limit=limit)

    if not symbols_for_training:
      logger.error("–ù–µ —É–¥–∞–ª–æ—Å—å –ø–æ–ª—É—á–∏—Ç—å —Å–∏–º–≤–æ–ª—ã –¥–ª—è –ø–µ—Ä–≤–∏—á–Ω–æ–≥–æ –æ–±—É—á–µ–Ω–∏—è. –ë–æ—Ç –Ω–µ –º–æ–∂–µ—Ç –ø—Ä–æ–¥–æ–ª–∂–∏—Ç—å.")
      return False

    # –ó–∞–ø—É—Å–∫–∞–µ–º –ø–µ—Ä–µ–æ–±—É—á–µ–Ω–∏–µ
    success, message = await self.retraining_manager.retrain_model(
      symbols_for_training, timeframe=Timeframe.ONE_HOUR
    )

    if not success:
      logger.error(f"–ü–µ—Ä–≤–∏—á–Ω–æ–µ –æ–±—É—á–µ–Ω–∏–µ –º–æ–¥–µ–ª–∏ –ø—Ä–æ–≤–∞–ª–∏–ª–æ—Å—å: {message}")
      return False

    # –ü–æ—Å–ª–µ —É—Å–ø–µ—à–Ω–æ–≥–æ –æ–±—É—á–µ–Ω–∏—è –ü–ï–†–ï–ó–ê–ì–†–£–ñ–ê–ï–ú –º–æ–¥–µ–ª—å –≤ –Ω–∞—à–µ–π —Å—Ç—Ä–∞—Ç–µ–≥–∏–∏
    logger.info("–ü–µ—Ä–≤–∏—á–Ω–æ–µ –æ–±—É—á–µ–Ω–∏–µ –º–æ–¥–µ–ª–∏ —É—Å–ø–µ—à–Ω–æ –∑–∞–≤–µ—Ä—à–µ–Ω–æ. –ü–µ—Ä–µ–∑–∞–≥—Ä—É–∑–∫–∞ –º–æ–¥–µ–ª–∏ –≤ —Å—Ç—Ä–∞—Ç–µ–≥–∏—é...")
    if ml_strategy:
      ml_strategy.model = ml_strategy._load_model()
      if not ml_strategy.model:
        logger.error("–ù–µ —É–¥–∞–ª–æ—Å—å –∑–∞–≥—Ä—É–∑–∏—Ç—å —Ç–æ–ª—å–∫–æ —á—Ç–æ –æ–±—É—á–µ–Ω–Ω—É—é –º–æ–¥–µ–ª—å –≤ —Å—Ç—Ä–∞—Ç–µ–≥–∏—é!")
        return False

    return True

  async def update_account_balance(self):
    logger.info("–ó–∞–ø—Ä–æ—Å –±–∞–ª–∞–Ω—Å–∞ –∞–∫–∫–∞—É–Ω—Ç–∞...")
    # –ó–∞–ø—Ä–∞—à–∏–≤–∞–µ–º –±–∞–ª–∞–Ω—Å –¥–ª—è UNIFIED –∞–∫–∫–∞—É–Ω—Ç–∞ –ø–æ USDT
    balance_data = await self.connector.get_account_balance(account_type="UNIFIED", coin="USDT")

    # >>> –ù–ê–ß–ê–õ–û –ü–ê–¢–ß–ê <<<
    # –ù–æ–≤–∞—è, –±–æ–ª–µ–µ –Ω–∞–¥–µ–∂–Ω–∞—è –ª–æ–≥–∏–∫–∞ –æ–±—Ä–∞–±–æ—Ç–∫–∏ –æ—Ç–≤–µ—Ç–∞
    if balance_data and balance_data.get('coin'):
      coin_data_list = balance_data.get('coin', [])
      if coin_data_list:
        coin_data = coin_data_list[0]
        try:
          self.account_balance = RiskMetrics(
            total_balance_usdt=float(coin_data.get('walletBalance', 0)),
            available_balance_usdt=float(balance_data.get('totalAvailableBalance', 0)),
            unrealized_pnl_total=float(coin_data.get('unrealisedPnl', 0)),
            realized_pnl_total=float(coin_data.get('cumRealisedPnl', 0))
          )
          # –ü–æ—Å–ª–µ —É—Å–ø–µ—à–Ω–æ–≥–æ –æ–±–Ω–æ–≤–ª–µ–Ω–∏—è –±–∞–ª–∞–Ω—Å–∞, –æ–±–Ω–æ–≤–ª—è–µ–º state_manager
          self.state_manager.update_metrics(self.account_balance)

          logger.info(f"–ë–∞–ª–∞–Ω—Å –æ–±–Ω–æ–≤–ª–µ–Ω: –í—Å–µ–≥–æ={self.account_balance.total_balance_usdt:.2f} USDT, "
                      f"–î–æ—Å—Ç—É–ø–Ω–æ={self.account_balance.available_balance_usdt:.2f} USDT")
          return  # –Ø–≤–Ω—ã–π –≤—ã—Ö–æ–¥ –ø–æ—Å–ª–µ —É—Å–ø–µ—Ö–∞

        except (ValueError, TypeError) as e:
          logger.error(f"–û—à–∏–±–∫–∞ –ø—Ä–µ–æ–±—Ä–∞–∑–æ–≤–∞–Ω–∏—è –¥–∞–Ω–Ω—ã—Ö –±–∞–ª–∞–Ω—Å–∞: {e}. –û—Ç–≤–µ—Ç: {coin_data}")
          self.account_balance = self.account_balance or RiskMetrics()  # –°–æ—Ö—Ä–∞–Ω—è–µ–º —Å—Ç–∞—Ä–æ–µ –∑–Ω–∞—á–µ–Ω–∏–µ, –µ—Å–ª–∏ –µ—Å—Ç—å
      else:
        logger.error(f"–°–ø–∏—Å–æ–∫ 'coin' –≤ –æ—Ç–≤–µ—Ç–µ –æ –±–∞–ª–∞–Ω—Å–µ –ø—É—Å—Ç. –û—Ç–≤–µ—Ç: {balance_data}")
        self.account_balance = self.account_balance or RiskMetrics()
    else:
      logger.error(f"–ù–µ —É–¥–∞–ª–æ—Å—å –ø–æ–ª—É—á–∏—Ç—å –∏–ª–∏ —Ä–∞—Å–ø–∞—Ä—Å–∏—Ç—å –¥–∞–Ω–Ω—ã–µ –æ –±–∞–ª–∞–Ω—Å–µ. –û—Ç–≤–µ—Ç: {balance_data}")
      # –ï—Å–ª–∏ –Ω–µ —É–¥–∞–ª–æ—Å—å –æ–±–Ω–æ–≤–∏—Ç—å, –æ—Å—Ç–∞–≤–ª—è–µ–º —Å—Ç–∞—Ä–æ–µ –∑–Ω–∞—á–µ–Ω–∏–µ, —á—Ç–æ–±—ã –Ω–µ –æ–±–Ω—É–ª—è—Ç—å –±–∞–ª–∞–Ω—Å
      self.account_balance = self.account_balance or RiskMetrics()


  async def set_leverage_for_symbol(self, symbol: str, leverage: int) -> bool:
    """–ò–°–ü–†–ê–í–õ–ï–ù–û: –û–±–Ω–æ–≤–ª–µ–Ω –¥–ª—è —Ä–∞–±–æ—Ç—ã —Å –Ω–æ–≤—ã–º –º–µ—Ç–æ–¥–æ–º connector.set_leverage"""
    logger.info(f"–ü–æ–ø—ã—Ç–∫–∞ —É—Å—Ç–∞–Ω–æ–≤–∏—Ç—å –ø–ª–µ—á–æ {leverage}x –¥–ª—è {symbol}")
    if not (1 <= leverage <= 100):  # –ü—Ä–∏–º–µ—Ä–Ω—ã–π –¥–∏–∞–ø–∞–∑–æ–Ω, —É—Ç–æ—á–Ω–∏—Ç—å –¥–ª—è Bybit
      logger.error(f"–ù–µ–∫–æ—Ä—Ä–µ–∫—Ç–Ω–æ–µ –∑–Ω–∞—á–µ–Ω–∏–µ –ø–ª–µ—á–∞: {leverage}. –î–æ–ª–∂–Ω–æ –±—ã—Ç—å –≤ –¥–∏–∞–ø–∞–∑–æ–Ω–µ [1-100].")
      return False

    try:
      success = await self.connector.set_leverage(symbol, leverage, leverage)
      if success:
        logger.info(f"–ö—Ä–µ–¥–∏—Ç–Ω–æ–µ –ø–ª–µ—á–æ {leverage}x —É—Å–ø–µ—à–Ω–æ —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–æ –¥–ª—è {symbol}.")

        return True
      else:
        logger.error(f"–ù–µ —É–¥–∞–ª–æ—Å—å —É—Å—Ç–∞–Ω–æ–≤–∏—Ç—å –ø–ª–µ—á–æ –¥–ª—è {symbol}.")
        return False
    except Exception as e:
      logger.error(f"–û—à–∏–±–∫–∞ –ø—Ä–∏ —É—Å—Ç–∞–Ω–æ–≤–∫–µ –ø–ª–µ—á–∞ –¥–ª—è {symbol}: {e}", exc_info=True)
      return False

  async def _prepare_signal_metadata(self, symbol: str, signal: TradingSignal, data: pd.DataFrame) -> Dict[str, Any]:
      """–ü–æ–¥–≥–æ—Ç–æ–≤–∫–∞ –º–µ—Ç–∞–¥–∞–Ω–Ω—ã—Ö —Å–∏–≥–Ω–∞–ª–∞ –¥–ª—è Shadow Trading"""
      try:
        metadata = {
          'source': self._determine_signal_source(signal),
          'indicators_triggered': self._get_triggered_indicators(symbol, data),
          'market_regime': await self._determine_market_regime(data, symbol),
          'volatility_level': self._determine_volatility_level(data),
          'confidence_score': signal.confidence,
          'strategy_name': signal.strategy_name or 'unknown',
          'volume': float(data['volume'].iloc[-1]) if 'volume' in data.columns else 0,
          'price_action_score': self._calculate_price_action_score(data),
          'market_session': self._determine_market_session(),
          'correlation_data': await self._get_correlation_data(symbol) if hasattr(self,
                                                                                  '_get_correlation_data') else {},
          'liquidity_score': self._calculate_liquidity_score(data) if hasattr(self,
                                                                              '_calculate_liquidity_score') else 0,
          'signal_timestamp': signal.timestamp.isoformat(),
          'symbol': symbol
        }
        # –ï—Å–ª–∏ –¥–æ—Å—Ç—É–ø–µ–Ω –ø—Ä–æ–¥–≤–∏–Ω—É—Ç—ã–π –¥–µ—Ç–µ–∫—Ç–æ—Ä —Ä–µ–∂–∏–º–æ–≤, –¥–æ–±–∞–≤–ª—è–µ–º —Ä–∞—Å—à–∏—Ä–µ–Ω–Ω—ã–µ –¥–∞–Ω–Ω—ã–µ
        if hasattr(self, 'market_regime_detector') and self.market_regime_detector:
          try:
            regime_characteristics = await self.market_regime_detector.detect_regime(symbol, data)
            if regime_characteristics:
              metadata.update({
                'regime_confidence': regime_characteristics.confidence,
                'trend_strength': regime_characteristics.trend_strength,
                'volatility_level_detailed': regime_characteristics.volatility_level,
                'momentum_score': regime_characteristics.momentum_score,
                'regime_duration_hours': regime_characteristics.regime_duration.total_seconds() / 3600,
                'secondary_regime': regime_characteristics.secondary_regime.value if regime_characteristics.secondary_regime else None,
                'supporting_indicators': regime_characteristics.supporting_indicators
              })
          except Exception as e:
            logger.debug(f"–ù–µ —É–¥–∞–ª–æ—Å—å –ø–æ–ª—É—á–∏—Ç—å —Ä–∞—Å—à–∏—Ä–µ–Ω–Ω—ã–µ –¥–∞–Ω–Ω—ã–µ —Ä–µ–∂–∏–º–∞: {e}")


        # ML –¥–∞–Ω–Ω—ã–µ –µ—Å–ª–∏ –¥–æ—Å—Ç—É–ø–Ω—ã
        if hasattr(signal, 'metadata') and signal.metadata:
          metadata['ml_prediction_data'] = signal.metadata

        # –î–æ–±–∞–≤–ª—è–µ–º —Ç–µ—Ö–Ω–∏—á–µ—Å–∫–∏–µ —É—Ä–æ–≤–Ω–∏
        metadata['technical_levels'] = self._get_technical_levels(data)

        return metadata

      except Exception as e:
        logger.warning(f"–û—à–∏–±–∫–∞ –ø–æ–¥–≥–æ—Ç–æ–≤–∫–∏ –º–µ—Ç–∞–¥–∞–Ω–Ω—ã—Ö –¥–ª—è {symbol}: {e}")
        return {'source': 'unknown', 'error': str(e)}

  async def _update_dashboard_metrics(self):
    """–û–±–Ω–æ–≤–ª—è–µ—Ç –º–µ—Ç—Ä–∏–∫–∏ –¥–ª—è –¥–∞—à–±–æ—Ä–¥–∞"""
    try:
      # 1. –û–±–Ω–æ–≤–ª—è–µ–º SAR –º–µ—Ç—Ä–∏–∫–∏
      if hasattr(self, 'sar_strategy') and self.sar_strategy:
        try:
          sar_metrics = self.sar_strategy.get_dashboard_metrics()
          self.state_manager.set_custom_data('sar_strategy_performance', sar_metrics)
          logger.debug(f"SAR –º–µ—Ç—Ä–∏–∫–∏ –æ–±–Ω–æ–≤–ª–µ–Ω—ã: {len(sar_metrics)} –ø–∞—Ä–∞–º–µ—Ç—Ä–æ–≤")
        except Exception as e:
          logger.error(f"–û—à–∏–±–∫–∞ –æ–±–Ω–æ–≤–ª–µ–Ω–∏—è SAR –º–µ—Ç—Ä–∏–∫: {e}")

      # 2. –û–±–Ω–æ–≤–ª—è–µ–º –∞–¥–∞–ø—Ç–∏–≤–Ω—ã–µ –≤–µ—Å–∞
      if hasattr(self, 'adaptive_selector') and self.adaptive_selector:
        try:
          performance_summary = self.adaptive_selector.get_performance_summary()

          # –ò–∑–≤–ª–µ–∫–∞–µ–º –≤–µ—Å–∞
          weights = {}
          for strategy_name, perf in performance_summary.items():
            weights[strategy_name] = perf.get('weight', 1.0)

          self.state_manager.set_custom_data('adaptive_weights', weights)
          self.state_manager.set_custom_data('strategy_performance_summary', performance_summary)
          logger.debug(f"–ê–¥–∞–ø—Ç–∏–≤–Ω—ã–µ –≤–µ—Å–∞ –æ–±–Ω–æ–≤–ª–µ–Ω—ã: {len(weights)} —Å—Ç—Ä–∞—Ç–µ–≥–∏–π")
        except Exception as e:
          logger.error(f"–û—à–∏–±–∫–∞ –æ–±–Ω–æ–≤–ª–µ–Ω–∏—è –∞–¥–∞–ø—Ç–∏–≤–Ω—ã—Ö –≤–µ—Å–æ–≤: {e}")

      # 3. –û–±–Ω–æ–≤–ª—è–µ–º —Å—Ç–∞—Ç—É—Å SAR —Å—Ç—Ä–∞—Ç–µ–≥–∏–∏
      if hasattr(self, 'sar_strategy') and self.sar_strategy:
        try:
          sar_status = self.sar_strategy.get_strategy_status()
          self.state_manager.set_custom_data('sar_strategy_status', sar_status)
        except Exception as e:
          logger.error(f"–û—à–∏–±–∫–∞ –æ–±–Ω–æ–≤–ª–µ–Ω–∏—è —Å—Ç–∞—Ç—É—Å–∞ SAR: {e}")

    except Exception as e:
      logger.error(f"–û—à–∏–±–∫–∞ –æ–±–Ω–æ–≤–ª–µ–Ω–∏—è –º–µ—Ç—Ä–∏–∫ –¥–∞—à–±–æ—Ä–¥–∞: {e}")

  def _determine_signal_source(self, signal: TradingSignal) -> str:
    """–û–ø—Ä–µ–¥–µ–ª–∏—Ç—å –∏—Å—Ç–æ—á–Ω–∏–∫ —Å–∏–≥–Ω–∞–ª–∞ —Å –ø–æ–ª–Ω—ã–º —Å–æ–ø–æ—Å—Ç–∞–≤–ª–µ–Ω–∏–µ–º —Å—Ç—Ä–∞—Ç–µ–≥–∏–π"""
    if not signal or not hasattr(signal, 'strategy_name'):
      return 'unknown'

    strategy_name = str(getattr(signal, 'strategy_name', '')).lower().strip()

    if not strategy_name or strategy_name == 'unknown':
      return 'unknown'

    # –¢–æ—á–Ω–æ–µ —Å–æ–ø–æ—Å—Ç–∞–≤–ª–µ–Ω–∏–µ –ø–æ –Ω–∞–∑–≤–∞–Ω–∏—è–º —Å—Ç—Ä–∞—Ç–µ–≥–∏–π –∏–∑ —Å–∏—Å—Ç–µ–º—ã
    strategy_mapping = {
      'live_ml_strategy': 'ml_model',
      'ensemble_confirmed': 'ml_ensemble',
      'enhanced_ml': 'ml_enhanced',
      'reversalsar': 'sar_strategy',
      'sar_strategy': 'sar_strategy',
      'stop_and_reverse': 'sar_strategy',
      'ichimoku_cloud': 'ichimoku_cloud',
      'dual_thrust': 'dual_thrust',
      'momentum_spike': 'momentum_spike',
      'mean_reversion_bb': 'mean_reversion',
      'bollinger_bands': 'mean_reversion',
      'grid_trading': 'grid_trading',
      'scalping_strategy': 'scalping',
      'swing_strategy': 'swing_trading',
      'arbitrage_strategy': 'arbitrage'
    }

    # –ü—Ä—è–º–æ–µ —Å–æ–ø–æ—Å—Ç–∞–≤–ª–µ–Ω–∏–µ
    if strategy_name in strategy_mapping:
      return strategy_mapping[strategy_name]

    # –ß–∞—Å—Ç–∏—á–Ω–æ–µ —Å–æ–ø–æ—Å—Ç–∞–≤–ª–µ–Ω–∏–µ –¥–ª—è —Å–æ—Å—Ç–∞–≤–Ω—ã—Ö –Ω–∞–∑–≤–∞–Ω–∏–π
    for pattern, source in strategy_mapping.items():
      if pattern in strategy_name:
        return source

    # –ï—Å–ª–∏ —Ç–æ—á–Ω–æ–µ —Å–æ–ø–æ—Å—Ç–∞–≤–ª–µ–Ω–∏–µ –Ω–µ –Ω–∞–π–¥–µ–Ω–æ, –∫–ª–∞—Å—Å–∏—Ñ–∏—Ü–∏—Ä—É–µ–º –ø–æ –∫–ª—é—á–µ–≤—ã–º —Å–ª–æ–≤–∞–º
    if any(word in strategy_name for word in ['ml', 'machine', 'neural', 'ensemble']):
      return 'ml_model'
    elif any(word in strategy_name for word in ['sar', 'parabolic', 'reversal']):
      return 'sar_strategy'
    elif any(word in strategy_name for word in ['bollinger', 'mean_reversion', 'reversion']):
      return 'mean_reversion'
    elif any(word in strategy_name for word in ['momentum', 'breakout', 'spike']):
      return 'breakout'
    elif any(word in strategy_name for word in ['ichimoku', 'cloud']):
      return 'ichimoku_cloud'
    elif any(word in strategy_name for word in ['dual', 'thrust']):
      return 'dual_thrust'
    elif any(word in strategy_name for word in ['grid', 'martingale']):
      return 'grid_trading'
    elif any(word in strategy_name for word in ['scalp']):
      return 'scalping'
    elif any(word in strategy_name for word in ['swing']):
      return 'swing_trading'
    else:
      # –í–æ–∑–≤—Ä–∞—â–∞–µ–º –æ—Ä–∏–≥–∏–Ω–∞–ª—å–Ω–æ–µ –Ω–∞–∑–≤–∞–Ω–∏–µ –µ—Å–ª–∏ –Ω–µ —É–¥–∞–ª–æ—Å—å –∫–ª–∞—Å—Å–∏—Ñ–∏—Ü–∏—Ä–æ–≤–∞—Ç—å
      return strategy_name.replace(' ', '_')

  def _get_triggered_indicators(self, symbol: str, data: pd.DataFrame) -> List[str]:
    """–ü–æ–ª—É—á–∏—Ç—å —Å–ø–∏—Å–æ–∫ —Å—Ä–∞–±–æ—Ç–∞–≤—à–∏—Ö –∏–Ω–¥–∏–∫–∞—Ç–æ—Ä–æ–≤"""
    triggered = []

    try:
      latest = data.iloc[-1]

      # RSI –∞–Ω–∞–ª–∏–∑
      if 'rsi_14' in data.columns:
        rsi = latest['rsi_14']
        if rsi > 70:
          triggered.append('rsi_overbought')
        elif rsi < 30:
          triggered.append('rsi_oversold')
        elif 50 < rsi < 60:
          triggered.append('rsi_bullish_zone')
        elif 40 < rsi < 50:
          triggered.append('rsi_bearish_zone')

      # MACD –∞–Ω–∞–ª–∏–∑
      if all(col in data.columns for col in ['macd', 'macd_signal', 'macd_histogram']):
        macd = latest['macd']
        macd_signal = latest['macd_signal']
        macd_hist = latest['macd_histogram']

        if macd > macd_signal:
          triggered.append('macd_bullish')
        else:
          triggered.append('macd_bearish')

        if macd_hist > 0 and data['macd_histogram'].iloc[-2] <= 0:
          triggered.append('macd_histogram_cross_up')
        elif macd_hist < 0 and data['macd_histogram'].iloc[-2] >= 0:
          triggered.append('macd_histogram_cross_down')

      # Bollinger Bands
      if all(col in data.columns for col in ['bb_upper', 'bb_lower', 'bb_middle']):
        price = latest['close']
        bb_upper = latest['bb_upper']
        bb_lower = latest['bb_lower']
        bb_middle = latest['bb_middle']

        if price > bb_upper:
          triggered.append('bb_upper_breach')
        elif price < bb_lower:
          triggered.append('bb_lower_breach')
        elif price > bb_middle:
          triggered.append('bb_above_middle')
        else:
          triggered.append('bb_below_middle')

      # Moving Averages
      if all(col in data.columns for col in ['ema_20', 'ema_50']):
        ema_20 = latest['ema_20']
        ema_50 = latest['ema_50']
        price = latest['close']

        if ema_20 > ema_50:
          triggered.append('ema_bullish_alignment')
        else:
          triggered.append('ema_bearish_alignment')

        if price > ema_20:
          triggered.append('price_above_ema20')
        if price > ema_50:
          triggered.append('price_above_ema50')

      # Volume –∞–Ω–∞–ª–∏–∑
      if 'volume' in data.columns:
        volume = latest['volume']
        avg_volume = data['volume'].rolling(20).mean().iloc[-1]

        if volume > avg_volume * 1.5:
          triggered.append('high_volume')
        elif volume < avg_volume * 0.5:
          triggered.append('low_volume')

      # ADX –¥–ª—è –æ–ø—Ä–µ–¥–µ–ª–µ–Ω–∏—è —Ç—Ä–µ–Ω–¥–∞
      if 'adx' in data.columns:
        adx = latest['adx']
        if adx > 25:
          triggered.append('strong_trend')
        elif adx < 20:
          triggered.append('weak_trend')

      # Stochastic
      if all(col in data.columns for col in ['stoch_k', 'stoch_d']):
        stoch_k = latest['stoch_k']
        stoch_d = latest['stoch_d']

        if stoch_k > 80 and stoch_d > 80:
          triggered.append('stoch_overbought')
        elif stoch_k < 20 and stoch_d < 20:
          triggered.append('stoch_oversold')

        if stoch_k > stoch_d:
          triggered.append('stoch_bullish_cross')
        else:
          triggered.append('stoch_bearish_cross')

    except Exception as e:
      logger.warning(f"–û—à–∏–±–∫–∞ –∞–Ω–∞–ª–∏–∑–∞ –∏–Ω–¥–∏–∫–∞—Ç–æ—Ä–æ–≤ –¥–ª—è {symbol}: {e}")
      triggered.append('indicator_analysis_error')

    return triggered

  async def _determine_market_regime(self, data: pd.DataFrame, symbol: str = None) -> str:
    """–û–ø—Ä–µ–¥–µ–ª–∏—Ç—å —Ä—ã–Ω–æ—á–Ω—ã–π —Ä–µ–∂–∏–º —á–µ—Ä–µ–∑ –ø—Ä–æ–¥–≤–∏–Ω—É—Ç—ã–π –¥–µ—Ç–µ–∫—Ç–æ—Ä"""
    try:
      # –ò—Å–ø–æ–ª—å–∑—É–µ–º –ø—Ä–æ–¥–≤–∏–Ω—É—Ç—ã–π MarketRegimeDetector –µ—Å–ª–∏ –¥–æ—Å—Ç—É–ø–µ–Ω
      if hasattr(self, 'market_regime_detector') and self.market_regime_detector and symbol:
        # –ü–æ–ª—É—á–∞–µ–º —Ö–∞—Ä–∞–∫—Ç–µ—Ä–∏—Å—Ç–∏–∫–∏ —Ä–µ–∂–∏–º–∞
        regime_characteristics = await self.market_regime_detector.detect_regime(symbol, data)

        if regime_characteristics:
          # –í–æ–∑–≤—Ä–∞—â–∞–µ–º —Å—Ç—Ä–æ–∫–æ–≤–æ–µ –ø—Ä–µ–¥—Å—Ç–∞–≤–ª–µ–Ω–∏–µ —Ä–µ–∂–∏–º–∞
          regime_name = regime_characteristics.primary_regime.value.lower()

          # –õ–æ–≥–∏—Ä—É–µ–º –¥–µ—Ç–∞–ª–∏ –¥–ª—è –æ—Ç–ª–∞–¥–∫–∏
          logger.debug(f"–†–µ–∂–∏–º –¥–ª—è {symbol}: {regime_name} "
                       f"(—É–≤–µ—Ä–µ–Ω–Ω–æ—Å—Ç—å: {regime_characteristics.confidence:.2f}, "
                       f"—Å–∏–ª–∞ —Ç—Ä–µ–Ω–¥–∞: {regime_characteristics.trend_strength:.2f})")

          return regime_name

      # Fallback –∫ –ø—Ä–æ—Å—Ç–æ–º—É –º–µ—Ç–æ–¥—É –µ—Å–ª–∏ –ø—Ä–æ–¥–≤–∏–Ω—É—Ç—ã–π –Ω–µ–¥–æ—Å—Ç—É–ø–µ–Ω
      return self._simple_market_regime_fallback(data)

    except Exception as e:
      logger.warning(f"–û—à–∏–±–∫–∞ –æ–ø—Ä–µ–¥–µ–ª–µ–Ω–∏—è —Ä–µ–∂–∏–º–∞: {e}")
      return self._simple_market_regime_fallback(data)

  def _simple_market_regime_fallback(self, data: pd.DataFrame) -> str:
    """–ü—Ä–æ—Å—Ç–æ–µ –æ–ø—Ä–µ–¥–µ–ª–µ–Ω–∏–µ —Ä–µ–∂–∏–º–∞ –∫–∞–∫ fallback"""
    try:
      if len(data) < 50:
        return 'insufficient_data'

      close_prices = data['close'].tail(50)
      sma_20 = close_prices.rolling(20).mean()
      sma_50 = close_prices.rolling(50).mean()

      current_price = close_prices.iloc[-1]
      sma_20_current = sma_20.iloc[-1]
      sma_50_current = sma_50.iloc[-1]

      volatility = close_prices.pct_change().std() * 100

      # –ö–ª–∞—Å—Å–∏—Ñ–∏–∫–∞—Ü–∏—è —Ä–µ–∂–∏–º–∞
      if current_price > sma_20_current > sma_50_current:
        return 'strong_trend_up' if volatility > 3.0 else 'trend_up'
      elif current_price < sma_20_current < sma_50_current:
        return 'strong_trend_down' if volatility > 3.0 else 'trend_down'
      elif volatility > 4.0:
        return 'volatile'
      else:
        return 'ranging'

    except Exception:
      return 'unknown'

  def _determine_volatility_level(self, data: pd.DataFrame) -> str:
    """–û–ø—Ä–µ–¥–µ–ª–∏—Ç—å —É—Ä–æ–≤–µ–Ω—å –≤–æ–ª–∞—Ç–∏–ª—å–Ω–æ—Å—Ç–∏"""
    try:
      latest = data.iloc[-1]

      if 'atr' in data.columns:
        atr = latest['atr']
        price = latest['close']
        atr_pct = (atr / price) * 100

        if atr_pct > 4:
          return 'very_high'
        elif atr_pct > 2.5:
          return 'high'
        elif atr_pct > 1.5:
          return 'normal'
        elif atr_pct > 0.8:
          return 'low'
        else:
          return 'very_low'

      # Fallback: –∞–Ω–∞–ª–∏–∑ –ø–æ Bollinger Bands
      if all(col in data.columns for col in ['bb_upper', 'bb_lower']):
        bb_width = (latest['bb_upper'] - latest['bb_lower']) / latest['close'] * 100

        if bb_width > 5:
          return 'high'
        elif bb_width > 2:
          return 'normal'
        else:
          return 'low'

    except Exception as e:
      logger.warning(f"–û—à–∏–±–∫–∞ –æ–ø—Ä–µ–¥–µ–ª–µ–Ω–∏—è –≤–æ–ª–∞—Ç–∏–ª—å–Ω–æ—Å—Ç–∏: {e}")

    return 'unknown'

  def _calculate_price_action_score(self, data: pd.DataFrame) -> float:
    """–†–∞—Å—Å—á–∏—Ç–∞—Ç—å –æ—Ü–µ–Ω–∫—É price action"""
    try:
      # –ê–Ω–∞–ª–∏–∑ –ø–æ—Å–ª–µ–¥–Ω–∏—Ö 10 —Å–≤–µ—á–µ–π
      recent_data = data.tail(10)
      score = 0.0

      # –ê–Ω–∞–ª–∏–∑ –ø–∞—Ç—Ç–µ—Ä–Ω–æ–≤ —Å–≤–µ—á–µ–π
      for i in range(len(recent_data)):
        candle = recent_data.iloc[i]

        # –†–∞–∑–º–µ—Ä —Ç–µ–ª–∞ —Å–≤–µ—á–∏
        body_size = abs(candle['close'] - candle['open']) / candle['open']

        # –†–∞–∑–º–µ—Ä —Ç–µ–Ω–µ–π
        upper_shadow = candle['high'] - max(candle['open'], candle['close'])
        lower_shadow = min(candle['open'], candle['close']) - candle['low']
        total_range = candle['high'] - candle['low']

        if total_range > 0:
          upper_shadow_pct = upper_shadow / total_range
          lower_shadow_pct = lower_shadow / total_range

          # –û—Ü–µ–Ω–∫–∞ —Å–∏–ª—ã —Å–≤–µ—á–∏
          if body_size > 0.02:  # –°–∏–ª—å–Ω–æ–µ —Ç–µ–ª–æ
            score += 0.3

          # –î–æ–¥–∂–∏ –∏–ª–∏ spinning top
          if body_size < 0.005:
            score += 0.1

          # Hammer/Shooting star patterns
          if lower_shadow_pct > 0.6 and upper_shadow_pct < 0.2:
            score += 0.2  # Hammer
          elif upper_shadow_pct > 0.6 and lower_shadow_pct < 0.2:
            score += 0.2  # Shooting star

      # –ù–æ—Ä–º–∞–ª–∏–∑—É–µ–º –∫ –¥–∏–∞–ø–∞–∑–æ–Ω—É 0-1
      return min(score / len(recent_data), 1.0)

    except Exception as e:
      logger.warning(f"–û—à–∏–±–∫–∞ —Ä–∞—Å—á–µ—Ç–∞ price action score: {e}")
      return 0.0

  def _determine_market_session(self) -> str:
    """–û–ø—Ä–µ–¥–µ–ª–∏—Ç—å —Ç–µ–∫—É—â—É—é —Ç–æ—Ä–≥–æ–≤—É—é —Å–µ—Å—Å–∏—é"""
    try:
      current_hour = datetime.now().hour

      # UTC –≤—Ä–µ–º—è —Å–µ—Å—Å–∏–π
      if 22 <= current_hour or current_hour < 8:
        return 'asian'
      elif 8 <= current_hour < 16:
        return 'european'
      elif 16 <= current_hour < 22:
        return 'american'
      else:
        return 'overnight'

    except Exception as e:
      logger.warning(f"–û—à–∏–±–∫–∞ –æ–ø—Ä–µ–¥–µ–ª–µ–Ω–∏—è —Å–µ—Å—Å–∏–∏: {e}")
      return 'unknown'

  async def _get_correlation_data(self, symbol: str) -> Dict[str, float]:
    """–ü–æ–ª—É—á–∏—Ç—å –¥–∞–Ω–Ω—ã–µ –∫–æ—Ä—Ä–µ–ª—è—Ü–∏–∏ —Å –æ—Å–Ω–æ–≤–Ω—ã–º–∏ –∞–∫—Ç–∏–≤–∞–º–∏"""
    try:
      correlation_data = {}

      # –ü–æ–ª—É—á–∞–µ–º –¥–∞–Ω–Ω—ã–µ BTC –¥–ª—è –∫–æ—Ä—Ä–µ–ª—è—Ü–∏–∏
      if symbol != "BTCUSDT":
        try:
          btc_data = await self.data_fetcher.get_historical_candles(
            "BTCUSDT", Timeframe.ONE_HOUR, limit=100
          )

          symbol_data = await self.data_fetcher.get_historical_candles(
            symbol, Timeframe.ONE_HOUR, limit=100
          )

          if not btc_data.empty and not symbol_data.empty:
            # –í—ã—Ä–∞–≤–Ω–∏–≤–∞–µ–º –¥–∞–Ω–Ω—ã–µ –ø–æ –≤—Ä–µ–º–µ–Ω–∏
            btc_returns = btc_data['close'].pct_change().dropna()
            symbol_returns = symbol_data['close'].pct_change().dropna()

            if len(btc_returns) > 10 and len(symbol_returns) > 10:
              # –û–±—Ä–µ–∑–∞–µ–º –¥–æ –æ–¥–∏–Ω–∞–∫–æ–≤–æ–≥–æ —Ä–∞–∑–º–µ—Ä–∞
              min_length = min(len(btc_returns), len(symbol_returns))
              btc_returns = btc_returns.tail(min_length)
              symbol_returns = symbol_returns.tail(min_length)

              correlation = btc_returns.corr(symbol_returns)
              if not np.isnan(correlation):
                correlation_data['btc_correlation'] = float(correlation)

        except Exception as corr_error:
          logger.debug(f"–û—à–∏–±–∫–∞ —Ä–∞—Å—á–µ—Ç–∞ –∫–æ—Ä—Ä–µ–ª—è—Ü–∏–∏ —Å BTC: {corr_error}")

      return correlation_data

    except Exception as e:
      logger.warning(f"–û—à–∏–±–∫–∞ –ø–æ–ª—É—á–µ–Ω–∏—è –¥–∞–Ω–Ω—ã—Ö –∫–æ—Ä—Ä–µ–ª—è—Ü–∏–∏: {e}")
      return {}

  def _calculate_liquidity_score(self, data: pd.DataFrame) -> float:
    """–†–∞—Å—Å—á–∏—Ç–∞—Ç—å –æ—Ü–µ–Ω–∫—É –ª–∏–∫–≤–∏–¥–Ω–æ—Å—Ç–∏"""
    try:
      if 'volume' not in data.columns:
        return 0.0

      # –ê–Ω–∞–ª–∏–∑ –æ–±—ä–µ–º–æ–≤ –∑–∞ –ø–æ—Å–ª–µ–¥–Ω–∏–µ 20 –ø–µ—Ä–∏–æ–¥–æ–≤
      recent_volumes = data['volume'].tail(20)

      # –°—Ä–µ–¥–Ω–∏–π –æ–±—ä–µ–º
      avg_volume = recent_volumes.mean()

      # –°—Ç–∞–±–∏–ª—å–Ω–æ—Å—Ç—å –æ–±—ä–µ–º–æ–≤ (–Ω–∏–∑–∫–∞—è –≤–æ–ª–∞—Ç–∏–ª—å–Ω–æ—Å—Ç—å = —Ö–æ—Ä–æ—à–∞—è –ª–∏–∫–≤–∏–¥–Ω–æ—Å—Ç—å)
      volume_std = recent_volumes.std()
      volume_cv = volume_std / avg_volume if avg_volume > 0 else 1.0

      # –¢–µ–∫—É—â–∏–π –æ–±—ä–µ–º –æ—Ç–Ω–æ—Å–∏—Ç–µ–ª—å–Ω–æ —Å—Ä–µ–¥–Ω–µ–≥–æ
      current_volume = recent_volumes.iloc[-1]
      volume_ratio = current_volume / avg_volume if avg_volume > 0 else 0.0

      # –û—Ü–µ–Ω–∫–∞ –ª–∏–∫–≤–∏–¥–Ω–æ—Å—Ç–∏ (0-1)
      liquidity_score = min(volume_ratio * (1 - min(volume_cv, 1.0)), 2.0) / 2.0

      return float(liquidity_score)

    except Exception as e:
      logger.warning(f"–û—à–∏–±–∫–∞ —Ä–∞—Å—á–µ—Ç–∞ –ª–∏–∫–≤–∏–¥–Ω–æ—Å—Ç–∏: {e}")
      return 0.0

  def _get_technical_levels(self, data: pd.DataFrame) -> Dict[str, float]:
    """–ü–æ–ª—É—á–∏—Ç—å —Ç–µ—Ö–Ω–∏—á–µ—Å–∫–∏–µ —É—Ä–æ–≤–Ω–∏ –ø–æ–¥–¥–µ—Ä–∂–∫–∏/—Å–æ–ø—Ä–æ—Ç–∏–≤–ª–µ–Ω–∏—è"""
    try:
      levels = {}
      latest = data.iloc[-1]
      current_price = latest['close']

      # Pivot Points
      if len(data) >= 2:
        prev_candle = data.iloc[-2]
        high = prev_candle['high']
        low = prev_candle['low']
        close = prev_candle['close']

        pivot = (high + low + close) / 3
        levels['pivot_point'] = float(pivot)

        # –£—Ä–æ–≤–Ω–∏ –ø–æ–¥–¥–µ—Ä–∂–∫–∏ –∏ —Å–æ–ø—Ä–æ—Ç–∏–≤–ª–µ–Ω–∏—è
        levels['resistance_1'] = float(2 * pivot - low)
        levels['support_1'] = float(2 * pivot - high)
        levels['resistance_2'] = float(pivot + (high - low))
        levels['support_2'] = float(pivot - (high - low))

      # –ü—Ä–æ—Å—Ç—ã–µ —É—Ä–æ–≤–Ω–∏ –Ω–∞ –æ—Å–Ω–æ–≤–µ –º–∞–∫—Å–∏–º—É–º–æ–≤/–º–∏–Ω–∏–º—É–º–æ–≤
      if len(data) >= 20:
        recent_data = data.tail(20)
        levels['recent_high'] = float(recent_data['high'].max())
        levels['recent_low'] = float(recent_data['low'].min())

      return levels

    except Exception as e:
      logger.warning(f"–û—à–∏–±–∫–∞ –ø–æ–ª—É—á–µ–Ω–∏—è —Ç–µ—Ö–Ω–∏—á–µ—Å–∫–∏—Ö —É—Ä–æ–≤–Ω–µ–π: {e}")
      return {}

  def _convert_rejection_reasons_to_filter_reasons(self, reasons: List[str]) -> List[FilterReason]:
    """–ö–æ–Ω–≤–µ—Ä—Ç–∏—Ä–æ–≤–∞—Ç—å –ø—Ä–∏—á–∏–Ω—ã –æ—Ç–∫–ª–æ–Ω–µ–Ω–∏—è –≤ –ø—Ä–∏—á–∏–Ω—ã —Ñ–∏–ª—å—Ç—Ä–∞—Ü–∏–∏"""
    filter_reasons = []

    for reason in reasons:
      reason_lower = reason.lower()

      if any(word in reason_lower for word in ['confidence', '—É–≤–µ—Ä–µ–Ω–Ω–æ—Å—Ç—å', 'certainty']):
        filter_reasons.append(FilterReason.LOW_CONFIDENCE)
      elif any(word in reason_lower for word in ['risk', '—Ä–∏—Å–∫', 'exposure']):
        filter_reasons.append(FilterReason.RISK_MANAGER)
      elif any(word in reason_lower for word in ['market', '—Ä—ã–Ω–æ–∫', 'condition', '—É—Å–ª–æ–≤–∏—è']):
        filter_reasons.append(FilterReason.MARKET_CONDITIONS)
      elif any(word in reason_lower for word in ['position', '–ø–æ–∑–∏—Ü–∏—è', 'limit', '–ª–∏–º–∏—Ç']):
        filter_reasons.append(FilterReason.POSITION_LIMIT)
      elif any(word in reason_lower for word in ['correlation', '–∫–æ—Ä—Ä–µ–ª—è—Ü–∏—è']):
        filter_reasons.append(FilterReason.CORRELATION_FILTER)
      elif any(word in reason_lower for word in ['volatility', '–≤–æ–ª–∞—Ç–∏–ª—å–Ω–æ—Å—Ç—å', '–≤–æ–ª–∞—Ç']):
        filter_reasons.append(FilterReason.VOLATILITY_FILTER)
      else:
        filter_reasons.append(FilterReason.RISK_MANAGER)  # –ü–æ —É–º–æ–ª—á–∞–Ω–∏—é

    return filter_reasons if filter_reasons else [FilterReason.RISK_MANAGER]

  async def initialize_symbols_if_empty(self):
    if not self.active_symbols:
      logger.info("–°–ø–∏—Å–æ–∫ –∞–∫—Ç–∏–≤–Ω—ã—Ö —Å–∏–º–≤–æ–ª–æ–≤ –ø—É—Å—Ç, –ø–æ–ø—ã—Ç–∫–∞ –ø–æ–≤—Ç–æ—Ä–Ω–æ–π –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏–∏...")
      self.active_symbols = await self.data_fetcher.get_active_symbols_by_volume(100)
      if self.active_symbols:
        logger.info(f"–°–∏–º–≤–æ–ª—ã —É—Å–ø–µ—à–Ω–æ —Ä–µ–∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä–æ–≤–∞–Ω—ã: {self.active_symbols}")
      else:
        logger.warning("–ù–µ —É–¥–∞–ª–æ—Å—å —Ä–µ–∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä–æ–≤–∞—Ç—å —Å–∏–º–≤–æ–ª—ã.")

  async def periodic_regime_analysis(self):
    """–ü–µ—Ä–∏–æ–¥–∏—á–µ—Å–∫–∏–π –∞–Ω–∞–ª–∏–∑ –∏ —ç–∫—Å–ø–æ—Ä—Ç —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∏ —Ä–µ–∂–∏–º–æ–≤"""
    # –ñ–¥–µ–º –Ω–µ–º–Ω–æ–≥–æ –ø–µ—Ä–µ–¥ –ø–µ—Ä–≤—ã–º –∑–∞–ø—É—Å–∫–æ–º
    await asyncio.sleep(300)  # 5 –º–∏–Ω—É—Ç

    while self.is_running:
      try:
        # –≠–∫—Å–ø–æ—Ä—Ç–∏—Ä—É–µ–º —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫—É
        await self.export_regime_statistics()

        # –ê–Ω–∞–ª–∏–∑–∏—Ä—É–µ–º —ç—Ñ—Ñ–µ–∫—Ç–∏–≤–Ω–æ—Å—Ç—å —Ä–µ–∂–∏–º–æ–≤ –¥–ª—è —Ç–æ–ø-50 —Å–∏–º–≤–æ–ª–æ–≤
        symbols_to_analyze = self.active_symbols[:50]  # –û–≥—Ä–∞–Ω–∏—á–∏–≤–∞–µ–º –¥–ª—è –ø—Ä–æ–∏–∑–≤–æ–¥–∏—Ç–µ–ª—å–Ω–æ—Å—Ç–∏

        for symbol in symbols_to_analyze:
          if not self.is_running:  # –ü—Ä–æ–≤–µ—Ä–∫–∞ –Ω–∞ –æ—Å—Ç–∞–Ω–æ–≤–∫—É
            break

          stats = self.market_regime_detector.get_regime_statistics(symbol)
          if stats and stats.get('total_observations', 0) > 100:
            logger.info(f"–°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞ —Ä–µ–∂–∏–º–æ–≤ –¥–ª—è {symbol}:")
            logger.info(f"  –†–∞—Å–ø—Ä–µ–¥–µ–ª–µ–Ω–∏–µ: {stats.get('regime_distribution')}")
            logger.info(f"  –°—Ä–µ–¥–Ω–∏–µ –º–µ—Ç—Ä–∏–∫–∏: {stats.get('average_metrics')}")

        # –ñ–¥–µ–º 4 —á–∞—Å–∞ –¥–æ —Å–ª–µ–¥—É—é—â–µ–≥–æ –∞–Ω–∞–ª–∏–∑–∞
        await asyncio.sleep(3600 * 4)

      except asyncio.CancelledError:
        logger.info("–ü–µ—Ä–∏–æ–¥–∏—á–µ—Å–∫–∏–π –∞–Ω–∞–ª–∏–∑ —Ä–µ–∂–∏–º–æ–≤ –æ—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω")
        break
      except Exception as e:
        logger.error(f"–û—à–∏–±–∫–∞ –ø–µ—Ä–∏–æ–¥–∏—á–µ—Å–∫–æ–≥–æ –∞–Ω–∞–ª–∏–∑–∞ —Ä–µ–∂–∏–º–æ–≤: {e}")
        await asyncio.sleep(600)  # –ü—Ä–∏ –æ—à–∏–±–∫–µ –∂–¥–µ–º 10 –º–∏–Ω—É—Ç

  async def stop(self):
    """–ö–æ—Ä—Ä–µ–∫—Ç–Ω–∞—è –æ—Å—Ç–∞–Ω–æ–≤–∫–∞ –≤—Å–µ—Ö –∫–æ–º–ø–æ–Ω–µ–Ω—Ç–æ–≤ —Å–∏—Å—Ç–µ–º—ã"""
    if not self.is_running:
      logger.warning("–°–∏—Å—Ç–µ–º–∞ –Ω–µ –∑–∞–ø—É—â–µ–Ω–∞.")
      return

    logger.info("–ò–Ω–∏—Ü–∏–∏—Ä–æ–≤–∞–Ω–∞ –æ—Å—Ç–∞–Ω–æ–≤–∫–∞ —Ç–æ—Ä–≥–æ–≤–æ–π —Å–∏—Å—Ç–µ–º—ã...")
    self.is_running = False

    # –°–ø–∏—Å–æ–∫ –≤—Å–µ—Ö –∑–∞–¥–∞—á –¥–ª—è –æ—Å—Ç–∞–Ω–æ–≤–∫–∏
    tasks_to_cancel = []

    # –°–æ–±–∏—Ä–∞–µ–º –≤—Å–µ –∞–∫—Ç–∏–≤–Ω—ã–µ –∑–∞–¥–∞—á–∏
    if hasattr(self, '_monitoring_task') and self._monitoring_task:
      tasks_to_cancel.append(self._monitoring_task)

    if hasattr(self, '_fast_monitoring_task') and self._fast_monitoring_task:
      tasks_to_cancel.append(self._fast_monitoring_task)

    if hasattr(self, '_retraining_task') and self._retraining_task:
      tasks_to_cancel.append(self._retraining_task)

    if hasattr(self, '_time_sync_task') and self._time_sync_task:
      tasks_to_cancel.append(self._time_sync_task)

    if hasattr(self, '_time_sync_loop_task') and self._time_sync_loop_task:
      tasks_to_cancel.append(self._time_sync_loop_task)

    if hasattr(self, '_cache_cleanup_task') and self._cache_cleanup_task:
      tasks_to_cancel.append(self._cache_cleanup_task)

    if hasattr(self, '_correlation_task') and self._correlation_task:
      tasks_to_cancel.append(self._correlation_task)

    if hasattr(self, '_evaluation_task') and self._evaluation_task:
      tasks_to_cancel.append(self._evaluation_task)

    if hasattr(self, '_regime_analysis_task') and self._regime_analysis_task:
      tasks_to_cancel.append(self._regime_analysis_task)

    if hasattr(self, '_fast_pending_check_task') and self._fast_pending_check_task:
      tasks_to_cancel.append(self._fast_pending_check_task)

    if self._revalidation_task:
        self._revalidation_task.cancel()
        with suppress(asyncio.CancelledError):
            await self._revalidation_task


    if self.shadow_trading:
      try:
        # –ì–µ–Ω–µ—Ä–∏—Ä—É–µ–º —Ñ–∏–Ω–∞–ª—å–Ω—ã–π –æ—Ç—á–µ—Ç
        final_report = await self.shadow_trading.force_comprehensive_report()
        logger.info("üìä === –§–ò–ù–ê–õ–¨–ù–´–ô –û–¢–ß–ï–¢ SHADOW TRADING ===")
        logger.info(final_report)

        # –ì–µ–Ω–µ—Ä–∏—Ä—É–µ–º —Ñ–∏–Ω–∞–ª—å–Ω—ã–π –æ—Ç—á–µ—Ç
        final_report = await self.shadow_trading.generate_daily_report()
        logger.info("üìä === –§–ò–ù–ê–õ–¨–ù–´–ô –û–¢–ß–ï–¢ SHADOW TRADING ===")

        overall = final_report.get('overall_performance', {})
        if overall and 'error' not in overall:
          logger.info(f"üéØ –í—Å–µ–≥–æ —Å–∏–≥–Ω–∞–ª–æ–≤: {overall.get('total_signals', 0)}")
          logger.info(f"‚úÖ Win Rate: {overall.get('win_rate_pct', 0)}%")
          logger.info(f"üí∞ –û–±—â–∏–π P&L: {overall.get('total_pnl_pct', 0):+.2f}%")
          logger.info(f"‚öñÔ∏è Profit Factor: {overall.get('profit_factor', 0)}")

        logger.info("=" * 50)
        await self.shadow_trading.stop_shadow_trading()
        logger.info("üåü Shadow Trading —Å–∏—Å—Ç–µ–º–∞ –æ—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–∞")

      except Exception as e:
        logger.error(f"–û—à–∏–±–∫–∞ –æ—Å—Ç–∞–Ω–æ–≤–∫–∏ Shadow Trading: {e}")

    # # –ó–∞–∫—Ä—ã–≤–∞–µ–º —Å–æ–µ–¥–∏–Ω–µ–Ω–∏—è –∫–æ–Ω–Ω–µ–∫—Ç–æ—Ä–∞
    # if self.connector:
    #   await self.connector.close()
    # –≠–∫—Å–ø–æ—Ä—Ç–∏—Ä—É–µ–º —Ñ–∏–Ω–∞–ª—å–Ω—É—é —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫—É
    if hasattr(self, 'adaptive_selector'):
      self.adaptive_selector.export_adaptation_history(
        f"logs/final_adaptation_{datetime.now().strftime('%Y%m%d_%H%M%S')}.csv"
      )
    # –û—Ç–º–µ–Ω—è–µ–º –≤—Å–µ –∑–∞–¥–∞—á–∏
    for task in tasks_to_cancel:
      if not task.done():
        task.cancel()

    # –ñ–¥–µ–º –∑–∞–≤–µ—Ä—à–µ–Ω–∏—è –≤—Å–µ—Ö –∑–∞–¥–∞—á
    if tasks_to_cancel:
      await asyncio.gather(*tasks_to_cancel, return_exceptions=True)

    # –û–±–Ω–æ–≤–ª—è–µ–º —Å–æ—Å—Ç–æ—è–Ω–∏–µ
    self.state_manager.set_status('stopped')

    # –ó–∞–∫—Ä—ã–≤–∞–µ–º —Å–æ–µ–¥–∏–Ω–µ–Ω–∏—è
    if hasattr(self.db_manager, 'close'):
      await self.db_manager.close()


    logger.info("–¢–æ—Ä–≥–æ–≤–∞—è —Å–∏—Å—Ç–µ–º–∞ –æ—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–∞.")

  # –ú–µ—Ç–æ–¥—ã –¥–ª—è –≤–∑–∞–∏–º–æ–¥–µ–π—Å—Ç–≤–∏—è —Å GUI (–ø–æ–∫–∞ –±—É–¥—É—Ç –≤—ã–≤–æ–¥–∏—Ç—å –≤ –∫–æ–Ω—Å–æ–ª—å)
  def display_balance(self):
    if self.account_balance:
      print(f"\n--- –¢–µ–∫—É—â–∏–π –±–∞–ª–∞–Ω—Å ---")
      print(f"–û–±—â–∏–π –±–∞–ª–∞–Ω—Å USDT: {self.account_balance.total_balance_usdt:.2f}")
      print(f"–î–æ—Å—Ç—É–ø–Ω—ã–π –±–∞–ª–∞–Ω—Å USDT: {self.account_balance.available_balance_usdt:.2f}")
      print(f"–ù–µ—Ä–µ–∞–ª–∏–∑–æ–≤–∞–Ω–Ω—ã–π PNL: {self.account_balance.unrealized_pnl_total:.2f}")
      print(f"–†–µ–∞–ª–∏–∑–æ–≤–∞–Ω–Ω—ã–π PNL: {self.account_balance.realized_pnl_total:.2f}")
      print(f"----------------------\n")
    else:
      print("–ë–∞–ª–∞–Ω—Å –µ—â–µ –Ω–µ –∑–∞–≥—Ä—É–∂–µ–Ω.")

  def display_active_symbols(self):
    print(f"\n--- –ê–∫—Ç–∏–≤–Ω—ã–µ —Ç–æ—Ä–≥–æ–≤—ã–µ –ø–∞—Ä—ã ---")
    if self.active_symbols:
      # –ü–æ–ª—É—á–∞–µ–º –∞–∫—Ç—É–∞–ª—å–Ω–æ–µ –ø–ª–µ—á–æ –∏–∑ –Ω–∞—à–µ–≥–æ –∫–æ–Ω—Ñ–∏–≥–∞
      leverage = self.config.get('trade_settings', {}).get('leverage', 'N/A')
      for i, symbol in enumerate(self.active_symbols):
        # –ë–æ–ª—å—à–µ –Ω–µ –∏—Å–ø–æ–ª—å–∑—É–µ–º self.current_leverage
        print(f"{i + 1}. {symbol} (–ü–ª–µ—á–æ: {leverage}x)")
    else:
      print("–ù–µ—Ç –∞–∫—Ç–∏–≤–Ω—ã—Ö —Ç–æ—Ä–≥–æ–≤—ã—Ö –ø–∞—Ä.")
    print(f"----------------------------\n")

  # –ó–∞–≥–ª—É—à–∫–∏ –¥–ª—è —É–ø—Ä–∞–≤–ª–µ–Ω–∏—è —Å–∏–º–≤–æ–ª–∞–º–∏ –∏ –ø–ª–µ—á–æ–º (–ø–æ–∑–∂–µ –±—É–¥—É—Ç –≤—ã–∑—ã–≤–∞—Ç—å—Å—è –∏–∑ GUI)
  async def add_symbol_manual(self, symbol: str):
    if symbol not in self.active_symbols:
      # TODO: –î–æ–±–∞–≤–∏—Ç—å –ø—Ä–æ–≤–µ—Ä–∫—É, —Å—É—â–µ—Å—Ç–≤—É–µ—Ç –ª–∏ —Ç–∞–∫–æ–π —Å–∏–º–≤–æ–ª –Ω–∞ –±–∏—Ä–∂–µ
      self.active_symbols.append(symbol)
      self.current_leverage.setdefault(symbol, trading_params.DEFAULT_LEVERAGE)
      logger.info(f"–°–∏–º–≤–æ–ª {symbol} –¥–æ–±–∞–≤–ª–µ–Ω –≤—Ä—É—á–Ω—É—é.")
      # await self.set_leverage_for_symbol(symbol, self.current_leverage[symbol])
    else:
      logger.info(f"–°–∏–º–≤–æ–ª {symbol} —É–∂–µ –≤ —Å–ø–∏—Å–∫–µ –∞–∫—Ç–∏–≤–Ω—ã—Ö.")

  async def remove_symbol_manual(self, symbol: str):
    if symbol in self.active_symbols:
      self.active_symbols.remove(symbol)
      if symbol in self.current_leverage:
        del self.current_leverage[symbol]
      logger.info(f"–°–∏–º–≤–æ–ª {symbol} —É–¥–∞–ª–µ–Ω –∏–∑ —Å–ø–∏—Å–∫–∞ –∞–∫—Ç–∏–≤–Ω—ã—Ö.")
    else:
      logger.warning(f"–°–∏–º–≤–æ–ª {symbol} –Ω–µ –Ω–∞–π–¥–µ–Ω –≤ —Å–ø–∏—Å–∫–µ –∞–∫—Ç–∏–≤–Ω—ã—Ö.")


  def get_risk_metrics(self, symbol: str = None):
    """–ü–æ–ª—É—á–∏—Ç—å —Ä–∏—Å–∫-–º–µ—Ç—Ä–∏–∫–∏ –¥–ª—è —Å–∏–º–≤–æ–ª–∞"""
    try:
      metrics = RiskMetrics()

      # –ü–æ–ª—É—á–∞–µ–º —Å–¥–µ–ª–∫–∏
      if symbol:
        trades = self.get_trades_for_symbol(symbol)
      else:
        trades = self.get_all_trades(limit=1000)

      if not trades:
        return metrics

      # –û—Å–Ω–æ–≤–Ω—ã–µ –º–µ—Ç—Ä–∏–∫–∏
      metrics.total_trades = len(trades)
      profitable_trades = [t for t in trades if t.get('pnl', 0) > 0]
      losing_trades = [t for t in trades if t.get('pnl', 0) < 0]

      metrics.winning_trades = len(profitable_trades)
      metrics.losing_trades = len(losing_trades)

      if metrics.total_trades > 0:
        metrics.win_rate = metrics.winning_trades / metrics.total_trades

      # PnL –º–µ—Ç—Ä–∏–∫–∏
      all_pnl = [t.get('pnl', 0) for t in trades]
      metrics.total_pnl = sum(all_pnl)

      if profitable_trades:
        metrics.avg_win = sum(t.get('pnl', 0) for t in profitable_trades) / len(profitable_trades)

      if losing_trades:
        metrics.avg_loss = sum(t.get('pnl', 0) for t in losing_trades) / len(losing_trades)

      # Profit Factor
      total_profit = sum(t.get('pnl', 0) for t in profitable_trades)
      total_loss = abs(sum(t.get('pnl', 0) for t in losing_trades))

      if total_loss > 0:
        metrics.profit_factor = total_profit / total_loss

      # –í—Ä–µ–º–µ–Ω–Ω—ã–µ PnL
      metrics.daily_pnl = self._calculate_daily_pnl(trades)
      metrics.weekly_pnl = self._calculate_weekly_pnl(trades)
      metrics.monthly_pnl = self._calculate_monthly_pnl(trades)

      # –†–∏—Å–∫ –º–µ—Ç—Ä–∏–∫–∏
      metrics.max_drawdown = self._calculate_max_drawdown(all_pnl)
      metrics.sharpe_ratio = self._calculate_sharpe_ratio(all_pnl)
      metrics.volatility = self._calculate_volatility(all_pnl)

      # –î–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω—ã–µ –º–µ—Ç—Ä–∏–∫–∏
      metrics.max_consecutive_wins = self._calculate_max_consecutive_wins(trades)
      metrics.max_consecutive_losses = self._calculate_max_consecutive_losses(trades)

      if metrics.avg_loss != 0:
        metrics.risk_reward_ratio = abs(metrics.avg_win / metrics.avg_loss)

      return metrics

    except Exception as e:
      print(f"–û—à–∏–±–∫–∞ –ø—Ä–∏ —Ä–∞—Å—á–µ—Ç–µ —Ä–∏—Å–∫-–º–µ—Ç—Ä–∏–∫: {e}")
      return RiskMetrics()

  def _calculate_daily_pnl(self, trades: list) -> float:
      """–†–∞—Å—Å—á–∏—Ç–∞—Ç—å –¥–Ω–µ–≤–Ω–æ–π PnL"""
      try:
        from datetime import datetime, timedelta

        today = datetime.now().date()
        daily_trades = []

        for trade in trades:
          # –ü–æ–ø—Ä–æ–±—É–µ–º –∏–∑–≤–ª–µ—á—å –¥–∞—Ç—É –∏–∑ —Ä–∞–∑–Ω—ã—Ö –≤–æ–∑–º–æ–∂–Ω—ã—Ö –ø–æ–ª–µ–π
          trade_date = None

          if 'created_at' in trade and trade['created_at']:
            try:
              if isinstance(trade['created_at'], str):
                trade_date = datetime.strptime(trade['created_at'][:10], '%Y-%m-%d').date()
              else:
                trade_date = trade['created_at'].date()
            except:
              pass

          if trade_date and trade_date == today:
            daily_trades.append(trade)

        return sum(t.get('pnl', 0) for t in daily_trades)

      except Exception as e:
        print(f"–û—à–∏–±–∫–∞ –ø—Ä–∏ —Ä–∞—Å—á–µ—Ç–µ –¥–Ω–µ–≤–Ω–æ–≥–æ PnL: {e}")
        return 0.0

  def _calculate_weekly_pnl(self, trades: list) -> float:
    """–†–∞—Å—Å—á–∏—Ç–∞—Ç—å –Ω–µ–¥–µ–ª—å–Ω—ã–π PnL"""
    try:
      from datetime import datetime, timedelta

      today = datetime.now().date()
      week_ago = today - timedelta(days=7)
      weekly_trades = []

      for trade in trades:
        trade_date = None

        if 'created_at' in trade and trade['created_at']:
          try:
            if isinstance(trade['created_at'], str):
              trade_date = datetime.strptime(trade['created_at'][:10], '%Y-%m-%d').date()
            else:
              trade_date = trade['created_at'].date()
          except:
            pass

        if trade_date and week_ago <= trade_date <= today:
          weekly_trades.append(trade)

      return sum(t.get('pnl', 0) for t in weekly_trades)

    except Exception as e:
      print(f"–û—à–∏–±–∫–∞ –ø—Ä–∏ —Ä–∞—Å—á–µ—Ç–µ –Ω–µ–¥–µ–ª—å–Ω–æ–≥–æ PnL: {e}")
      return 0.0

  def _calculate_monthly_pnl(self, trades: list) -> float:
    """–†–∞—Å—Å—á–∏—Ç–∞—Ç—å –º–µ—Å—è—á–Ω—ã–π PnL"""
    try:
      from datetime import datetime, timedelta

      today = datetime.now().date()
      month_ago = today - timedelta(days=30)
      monthly_trades = []

      for trade in trades:
        trade_date = None

        if 'created_at' in trade and trade['created_at']:
          try:
            if isinstance(trade['created_at'], str):
              trade_date = datetime.strptime(trade['created_at'][:10], '%Y-%m-%d').date()
            else:
              trade_date = trade['created_at'].date()
          except:
            pass

        if trade_date and month_ago <= trade_date <= today:
          monthly_trades.append(trade)

      return sum(t.get('pnl', 0) for t in monthly_trades)

    except Exception as e:
      print(f"–û—à–∏–±–∫–∞ –ø—Ä–∏ —Ä–∞—Å—á–µ—Ç–µ –º–µ—Å—è—á–Ω–æ–≥–æ PnL: {e}")
      return 0.0

  def _calculate_sharpe_ratio(self, pnl_series: list) -> float:
    """–†–∞—Å—Å—á–∏—Ç–∞—Ç—å –∫–æ—ç—Ñ—Ñ–∏—Ü–∏–µ–Ω—Ç –®–∞—Ä–ø–∞"""
    try:
      if len(pnl_series) < 2:
        return 0.0

      import statistics

      mean_return = statistics.mean(pnl_series)
      std_return = statistics.stdev(pnl_series)

      if std_return == 0:
        return 0.0

      return mean_return / std_return

    except Exception as e:
      print(f"–û—à–∏–±–∫–∞ –ø—Ä–∏ —Ä–∞—Å—á–µ—Ç–µ –∫–æ—ç—Ñ—Ñ–∏—Ü–∏–µ–Ω—Ç–∞ –®–∞—Ä–ø–∞: {e}")
      return 0.0

  def _calculate_volatility(self, pnl_series: list) -> float:
    """–†–∞—Å—Å—á–∏—Ç–∞—Ç—å –≤–æ–ª–∞—Ç–∏–ª—å–Ω–æ—Å—Ç—å"""
    try:
      if len(pnl_series) < 2:
        return 0.0

      import statistics
      return statistics.stdev(pnl_series)

    except Exception as e:
      print(f"–û—à–∏–±–∫–∞ –ø—Ä–∏ —Ä–∞—Å—á–µ—Ç–µ –≤–æ–ª–∞—Ç–∏–ª—å–Ω–æ—Å—Ç–∏: {e}")
      return 0.0

  def _calculate_max_consecutive_wins(self, trades: list) -> int:
    """–†–∞—Å—Å—á–∏—Ç–∞—Ç—å –º–∞–∫—Å–∏–º–∞–ª—å–Ω–æ–µ –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ –ø–æ—Å–ª–µ–¥–æ–≤–∞—Ç–µ–ª—å–Ω—ã—Ö –≤—ã–∏–≥—Ä—ã—à–µ–π"""
    try:
      max_wins = 0
      current_wins = 0

      for trade in trades:
        if trade.get('pnl', 0) > 0:
          current_wins += 1
          max_wins = max(max_wins, current_wins)
        else:
          current_wins = 0

      return max_wins

    except Exception as e:
      print(f"–û—à–∏–±–∫–∞ –ø—Ä–∏ —Ä–∞—Å—á–µ—Ç–µ –º–∞–∫—Å–∏–º–∞–ª—å–Ω—ã—Ö –ø–æ—Å–ª–µ–¥–æ–≤–∞—Ç–µ–ª—å–Ω—ã—Ö –≤—ã–∏–≥—Ä—ã—à–µ–π: {e}")
      return 0

  def _calculate_max_consecutive_losses(self, trades: list) -> int:
    """–†–∞—Å—Å—á–∏—Ç–∞—Ç—å –º–∞–∫—Å–∏–º–∞–ª—å–Ω–æ–µ –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ –ø–æ—Å–ª–µ–¥–æ–≤–∞—Ç–µ–ª—å–Ω—ã—Ö –ø—Ä–æ–∏–≥—Ä—ã—à–µ–π"""
    try:
      max_losses = 0
      current_losses = 0

      for trade in trades:
        if trade.get('pnl', 0) < 0:
          current_losses += 1
          max_losses = max(max_losses, current_losses)
        else:
          current_losses = 0

      return max_losses

    except Exception as e:
      print(f"–û—à–∏–±–∫–∞ –ø—Ä–∏ —Ä–∞—Å—á–µ—Ç–µ –º–∞–∫—Å–∏–º–∞–ª—å–Ω—ã—Ö –ø–æ—Å–ª–µ–¥–æ–≤–∞—Ç–µ–ª—å–Ω—ã—Ö –ø—Ä–æ–∏–≥—Ä—ã—à–µ–π: {e}")
      return 0

  def _calculate_max_drawdown(self, pnl_series: list) -> float:
    """–í—ã—á–∏—Å–ª–∏—Ç—å –º–∞–∫—Å–∏–º–∞–ª—å–Ω—É—é –ø—Ä–æ—Å–∞–¥–∫—É"""
    if not pnl_series:
      return 0.0

    try:
      cumulative_pnl = []
      running_total = 0

      for pnl in pnl_series:
        running_total += pnl
        cumulative_pnl.append(running_total)

      if not cumulative_pnl:
        return 0.0

      max_drawdown = 0.0
      peak = cumulative_pnl[0]

      for current_value in cumulative_pnl:
        if current_value > peak:
          peak = current_value

        if peak > 0:
          drawdown = (peak - current_value) / peak
          max_drawdown = max(max_drawdown, drawdown)

      return max_drawdown

    except Exception as e:
      print(f"–û—à–∏–±–∫–∞ –ø—Ä–∏ —Ä–∞—Å—á–µ—Ç–µ –º–∞–∫—Å–∏–º–∞–ª—å–Ω–æ–π –ø—Ä–æ—Å–∞–¥–∫–∏: {e}")
      return 0.0

  def _calculate_drawdown(self, profits: List[float]) -> float:
    """–í—ã—á–∏—Å–ª—è–µ—Ç —Ç–µ–∫—É—â—É—é –ø—Ä–æ—Å–∞–¥–∫—É"""
    if not profits:
      return 0

    cumulative = np.cumsum(profits)
    running_max = np.maximum.accumulate(cumulative)
    drawdown = (cumulative - running_max) / (running_max + 1e-8)
    return float(np.min(drawdown))

  def get_trades_for_symbol(self, symbol: str) -> List[Dict]:
    """–ó–∞–≥–ª—É—à–∫–∞ –¥–ª—è –ø–æ–ª—É—á–µ–Ω–∏—è —Å–¥–µ–ª–æ–∫ –ø–æ —Å–∏–º–≤–æ–ª—É"""
    # TODO: –†–µ–∞–ª–∏–∑–æ–≤–∞—Ç—å –∫–æ–≥–¥–∞ –±—É–¥–µ—Ç –ø–æ–¥–∫–ª—é—á–µ–Ω–∞ –±–∞–∑–∞ –¥–∞–Ω–Ω—ã—Ö
    logger.debug(f"–ó–∞–≥–ª—É—à–∫–∞: –∑–∞–ø—Ä–æ—Å —Å–¥–µ–ª–æ–∫ –¥–ª—è —Å–∏–º–≤–æ–ª–∞ {symbol}")
    return []

  def get_all_trades(self, limit: int = 1000) -> List[Dict]:
    """–ó–∞–≥–ª—É—à–∫–∞ –¥–ª—è –ø–æ–ª—É—á–µ–Ω–∏—è –≤—Å–µ—Ö —Å–¥–µ–ª–æ–∫"""
    # TODO: –†–µ–∞–ª–∏–∑–æ–≤–∞—Ç—å –∫–æ–≥–¥–∞ –±—É–¥–µ—Ç –ø–æ–¥–∫–ª—é—á–µ–Ω–∞ –±–∞–∑–∞ –¥–∞–Ω–Ω—ã—Ö
    logger.debug(f"–ó–∞–≥–ª—É—à–∫–∞: –∑–∞–ø—Ä–æ—Å –≤—Å–µ—Ö —Å–¥–µ–ª–æ–∫ —Å –ª–∏–º–∏—Ç–æ–º {limit}")
    return []

  async def _time_sync_loop(self):
    """
    –§–æ–Ω–æ–≤—ã–π —Ü–∏–∫–ª, –∫–æ—Ç–æ—Ä—ã–π –ø–µ—Ä–∏–æ–¥–∏—á–µ—Å–∫–∏ —Ä–µ—Å–∏–Ω—Ö—Ä–æ–Ω–∏–∑–∏—Ä—É–µ—Ç –≤—Ä–µ–º—è —Å —Å–µ—Ä–≤–µ—Ä–æ–º –±–∏—Ä–∂–∏.
    """
    while self.is_running:
      try:
        # –ü–∞—É–∑–∞ –≤ 5 –º–∏–Ω (300 —Å–µ–∫—É–Ω–¥) –ø–µ—Ä–µ–¥ —Å–ª–µ–¥—É—é—â–µ–π —Å–∏–Ω—Ö—Ä–æ–Ω–∏–∑–∞—Ü–∏–µ–π
        await asyncio.sleep(300)

        logger.info("–í—ã–ø–æ–ª–Ω–µ–Ω–∏–µ –ø–ª–∞–Ω–æ–≤–æ–π —Ä–µ—Å–∏–Ω—Ö—Ä–æ–Ω–∏–∑–∞—Ü–∏–∏ –≤—Ä–µ–º–µ–Ω–∏...")
        await self.connector.sync_time()

      except asyncio.CancelledError:
        logger.info("–¶–∏–∫–ª —Å–∏–Ω—Ö—Ä–æ–Ω–∏–∑–∞—Ü–∏–∏ –≤—Ä–µ–º–µ–Ω–∏ –æ—Ç–º–µ–Ω–µ–Ω.")
        break
      except Exception as e:
        logger.error(f"–û—à–∏–±–∫–∞ –≤ —Ü–∏–∫–ª–µ —Å–∏–Ω—Ö—Ä–æ–Ω–∏–∑–∞—Ü–∏–∏ –≤—Ä–µ–º–µ–Ω–∏: {e}", exc_info=True)
        # –í —Å–ª—É—á–∞–µ –æ—à–∏–±–∫–∏ –ø–æ–ø—Ä–æ–±—É–µ–º —Å–Ω–æ–≤–∞ —á–µ—Ä–µ–∑ 5 –º–∏–Ω—É—Ç
        await asyncio.sleep(300)
  #
  # def _check_ltf_entry_trigger(self, data: pd.DataFrame, signal_type: SignalType) -> bool:
  #   """
  #   –£–õ–£–ß–®–ï–ù–ù–ê–Ø –í–ï–†–°–ò–Ø: –ü—Ä–æ–≤–µ—Ä—è–µ—Ç —Ç—Ä–∏–≥–≥–µ—Ä –¥–ª—è –≤—Ö–æ–¥–∞ –Ω–∞ –º–∞–ª–æ–º —Ç–∞–π–º—Ñ—Ä–µ–π–º–µ (LTF),
  #   –∏—Å–ø–æ–ª—å–∑—É—è –∫–æ–º–ø–ª–µ–∫—Å–Ω—É—é –ª–æ–≥–∏–∫—É "MFI + RSI + EMA Dynamic Signals".
  #   """
  #   if data.empty or len(data) < 30:  # –ù—É–∂–Ω–æ –¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ –¥–∞–Ω–Ω—ã—Ö –¥–ª—è –≤—Å–µ—Ö –∏–Ω–¥–∏–∫–∞—Ç–æ—Ä–æ–≤
  #     return False
  #
  #   try:
  #     df = data.copy()
  #     # --- –®–ê–ì 1: –ê–ì–†–ï–°–°–ò–í–ù–ê–Ø –û–ß–ò–°–¢–ö–ê –î–ê–ù–ù–´–• (–∫–∞–∫ –º—ã –¥–µ–ª–∞–ª–∏ –≤ FeatureEngineer) ---
  #     required_cols = ['open', 'high', 'low', 'close', 'volume']
  #     for col in required_cols:
  #       if col in df.columns:
  #         df[col] = pd.to_numeric(df[col], errors='coerce')
  #     df.dropna(subset=required_cols, inplace=True)
  #     if len(df) < 30: return False
  #     # --- –ö–û–ù–ï–¶ –û–ß–ò–°–¢–ö–ò ---
  #
  #
  #     # --- 1. –†–∞—Å—Å—á–∏—Ç—ã–≤–∞–µ–º –≤—Å–µ –Ω–µ–æ–±—Ö–æ–¥–∏–º—ã–µ –∏–Ω–¥–∏–∫–∞—Ç–æ—Ä—ã ---
  #
  #     # –ù–∞—Å—Ç—Ä–æ–π–∫–∏, –≤–∑—è—Ç—ã–µ –∏–∑ Pine Script –∏–Ω–¥–∏–∫–∞—Ç–æ—Ä–∞
  #     mfi_length = 14
  #     mfi_overbought = 70
  #     mfi_oversold = 30
  #     rsi_length = 14
  #     rsi_buy_threshold = 45
  #     rsi_sell_threshold = 55
  #     fast_ema_length = 9
  #     slow_ema_length = 21
  #     ema_proximity_pct = 0.5
  #
  #     df['mfi'] = self.calculate_mfi_manual(df['high'], df['low'], df['close'], df['volume'], length=mfi_length)
  #     df['rsi'] = ta.rsi(df['close'], length=rsi_length)
  #     df['ema_fast'] = ta.ema(df['close'], length=fast_ema_length)
  #     df['ema_slow'] = ta.ema(df['close'], length=slow_ema_length)
  #
  #     if df.isnull().any().any():  # –ï—Å–ª–∏ –µ—Å—Ç—å –ø—Ä–æ–ø—É—Å–∫–∏ –ø–æ—Å–ª–µ —Ä–∞—Å—á–µ—Ç–æ–≤
  #       df.ffill(inplace=True)
  #       df.bfill(inplace=True)
  #       if df.isnull().any().any():  # –ï—Å–ª–∏ –ø—Ä–æ–ø—É—Å–∫–∏ –æ—Å—Ç–∞–ª–∏—Å—å
  #         logger.warning(f"–ù–µ —É–¥–∞–ª–æ—Å—å —Ä–∞—Å—Å—á–∏—Ç–∞—Ç—å –≤—Å–µ –∏–Ω–¥–∏–∫–∞—Ç–æ—Ä—ã –¥–ª—è —Ç—Ä–∏–≥–≥–µ—Ä–∞ LTF.")
  #         return False
  #
  #     # --- 2. –û–ø—Ä–µ–¥–µ–ª—è–µ–º –ª–æ–≥–∏—á–µ—Å–∫–∏–µ —É—Å–ª–æ–≤–∏—è, –∫–∞–∫ –≤ –∏–Ω–¥–∏–∫–∞—Ç–æ—Ä–µ ---
  #
  #     # –£—Å–ª–æ–≤–∏—è –∏–º–ø—É–ª—å—Å–∞
  #     bullish_momentum = df['rsi'].iloc[-1] > rsi_buy_threshold
  #     bearish_momentum = df['rsi'].iloc[-1] < rsi_sell_threshold
  #
  #     # –£—Å–ª–æ–≤–∏—è –±–ª–∏–∑–æ—Å—Ç–∏ EMA
  #     ema_diff = abs((df['ema_fast'].iloc[-1] - df['ema_slow'].iloc[-1]) / df['ema_slow'].iloc[-1]) * 100
  #     ema_near_crossover = ema_diff <= ema_proximity_pct
  #
  #     # –£—Å–ª–æ–≤–∏—è –ø–µ—Ä–µ—Å–µ—á–µ–Ω–∏—è (–∏—Å–ø–æ–ª—å–∑—É–µ–º [-2], —á—Ç–æ–±—ã –ø–æ–π–º–∞—Ç—å —Å–∞–º–æ–µ —Å–≤–µ–∂–µ–µ –ø–µ—Ä–µ—Å–µ—á–µ–Ω–∏–µ)
  #     ema_crossover = crossover_series(df['ema_fast'], df['ema_slow']).iloc[-2]
  #     ema_crossunder = crossunder_series(df['ema_fast'], df['ema_slow']).iloc[-2]
  #     mfi_oversold_crossover = crossover_series(df['mfi'], pd.Series(mfi_oversold, index=df.index)).iloc[-2]
  #     mfi_overbought_crossunder = crossunder_series(df['mfi'], pd.Series(mfi_overbought, index=df.index)).iloc[-2]
  #
  #     # –î–æ–±–∞–≤–ª—è–µ–º –ø—Ä–æ–≤–µ—Ä–∫—É –≤–æ–ª–∞—Ç–∏–ª—å–Ω–æ—Å—Ç–∏ –¥–ª—è —Ñ–∏–ª—å—Ç—Ä–∞—Ü–∏–∏ —à—É–º–Ω—ã—Ö —Å–∏–≥–Ω–∞–ª–æ–≤
  #     atr = ta.atr(df['high'], df['low'], df['close'], length=14)
  #     if atr is not None and len(atr) > 0:
  #       current_atr = atr.iloc[-1]
  #       avg_price = df['close'].mean()
  #       volatility_pct = (current_atr / avg_price) * 100
  #
  #       # –ï—Å–ª–∏ –≤–æ–ª–∞—Ç–∏–ª—å–Ω–æ—Å—Ç—å —Å–ª–∏—à–∫–æ–º –Ω–∏–∑–∫–∞—è, –Ω–µ –≤—Ö–æ–¥–∏–º
  #       if volatility_pct < 0.1:  # –º–µ–Ω–µ–µ 0.1%
  #         logger.debug(f"–í–æ–ª–∞—Ç–∏–ª—å–Ω–æ—Å—Ç—å —Å–ª–∏—à–∫–æ–º –Ω–∏–∑–∫–∞—è ({volatility_pct:.3f}%), –ø—Ä–æ–ø—É—Å–∫–∞–µ–º –≤—Ö–æ–¥")
  #         return False
  #
  #     # --- 3. –§–∏–Ω–∞–ª—å–Ω–∞—è –ª–æ–≥–∏–∫–∞ —Ç—Ä–∏–≥–≥–µ—Ä–∞ ---
  #
  #     # –î–æ–±–∞–≤–ª—è–µ–º –¥–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω—ã–µ –ø—Ä–æ–≤–µ—Ä–∫–∏ –¥–ª—è –±–æ–ª–µ–µ –≥–∏–±–∫–æ–≥–æ –≤—Ö–æ–¥–∞
  #     price_momentum = False
  #     volume_confirmation = False
  #     volatility_ok = True
  #
  #     # –ü—Ä–æ–≤–µ—Ä–∫–∞ –∏–º–ø—É–ª—å—Å–∞ —Ü–µ–Ω—ã (–ø–æ—Å–ª–µ–¥–Ω–∏–µ 5 —Å–≤–µ—á–µ–π)
  #     if len(df) >= 5:
  #       recent_move = (df['close'].iloc[-1] - df['close'].iloc[-5]) / df['close'].iloc[-5] * 100
  #       if signal_type == SignalType.BUY and recent_move > 0.2:  # –†–æ—Å—Ç > 0.2%
  #         price_momentum = True
  #       elif signal_type == SignalType.SELL and recent_move < -0.2:  # –ü–∞–¥–µ–Ω–∏–µ > 0.2%
  #         price_momentum = True
  #
  #     # –ü—Ä–æ–≤–µ—Ä–∫–∞ –æ–±—ä–µ–º–∞ (–µ—Å–ª–∏ –¥–æ—Å—Ç—É–ø–µ–Ω)
  #     if 'volume' in df.columns and len(df) >= 20:
  #       vol_ma = df['volume'].rolling(20).mean().iloc[-1]
  #       current_vol = df['volume'].iloc[-1]
  #       if current_vol > vol_ma * 1.1:  # –û–±—ä–µ–º –≤—ã—à–µ —Å—Ä–µ–¥–Ω–µ–≥–æ –Ω–∞ 10%
  #         volume_confirmation = True
  #
  #     # –ü—Ä–æ–≤–µ—Ä–∫–∞ –≤–æ–ª–∞—Ç–∏–ª—å–Ω–æ—Å—Ç–∏
  #     if 'atr' in locals() and atr is not None and len(atr) > 0:
  #       current_atr = atr.iloc[-1]
  #       avg_price = df['close'].mean()
  #       volatility_pct = (current_atr / avg_price) * 100
  #
  #       # –ë–ª–æ–∫–∏—Ä—É–µ–º —Ç–æ–ª—å–∫–æ –ø—Ä–∏ –û–ß–ï–ù–¨ –Ω–∏–∑–∫–æ–π –≤–æ–ª–∞—Ç–∏–ª—å–Ω–æ—Å—Ç–∏
  #       if volatility_pct < 0.05:  # –º–µ–Ω–µ–µ 0.05% (–≤–º–µ—Å—Ç–æ 0.1%)
  #         volatility_ok = False
  #         logger.debug(f"–í–æ–ª–∞—Ç–∏–ª—å–Ω–æ—Å—Ç—å –∫—Ä–∏—Ç–∏—á–µ—Å–∫–∏ –Ω–∏–∑–∫–∞—è ({volatility_pct:.3f}%)")
  #
  #     # –°–ò–õ–¨–ù–´–ï —Ç—Ä–∏–≥–≥–µ—Ä—ã (–æ—Å–Ω–æ–≤–Ω—ã–µ —É—Å–ª–æ–≤–∏—è –∏–∑ –æ—Ä–∏–≥–∏–Ω–∞–ª–∞)
  #     strong_buy_trigger = False
  #     strong_sell_trigger = False
  #
  #     if signal_type == SignalType.BUY:
  #       strong_buy_trigger = (mfi_oversold_crossover or ema_crossover) and (bullish_momentum or ema_near_crossover)
  #     elif signal_type == SignalType.SELL:
  #       strong_sell_trigger = (mfi_overbought_crossunder or ema_crossunder) and (
  #             bearish_momentum or ema_near_crossover)
  #
  #     # –°–†–ï–î–ù–ò–ï —Ç—Ä–∏–≥–≥–µ—Ä—ã (—É–ø—Ä–æ—â–µ–Ω–Ω—ã–µ —É—Å–ª–æ–≤–∏—è)
  #     medium_buy_trigger = False
  #     medium_sell_trigger = False
  #
  #     if signal_type == SignalType.BUY:
  #       medium_buy_trigger = (
  #           (df['mfi'].iloc[-1] < 40 and bullish_momentum) or  # MFI –Ω–∏–∑–∫–∏–π + RSI —Ä–∞—Å—Ç–µ—Ç
  #           (ema_crossover and price_momentum) or  # EMA –ø–µ—Ä–µ—Å–µ—á–µ–Ω–∏–µ + –∏–º–ø—É–ª—å—Å —Ü–µ–Ω—ã
  #           (df['rsi'].iloc[-1] > 50 and df['rsi'].iloc[-1] > df['rsi'].iloc[-2])  # RSI —Ä–∞—Å—Ç–µ—Ç –≤—ã—à–µ 50
  #       )
  #     elif signal_type == SignalType.SELL:
  #       medium_sell_trigger = (
  #           (df['mfi'].iloc[-1] > 60 and bearish_momentum) or  # MFI –≤—ã—Å–æ–∫–∏–π + RSI –ø–∞–¥–∞–µ—Ç
  #           (ema_crossunder and price_momentum) or  # EMA –ø–µ—Ä–µ—Å–µ—á–µ–Ω–∏–µ + –∏–º–ø—É–ª—å—Å —Ü–µ–Ω—ã
  #           (df['rsi'].iloc[-1] < 50 and df['rsi'].iloc[-1] < df['rsi'].iloc[-2])  # RSI –ø–∞–¥–∞–µ—Ç –Ω–∏–∂–µ 50
  #       )
  #
  #     # –°–õ–ê–ë–´–ï —Ç—Ä–∏–≥–≥–µ—Ä—ã (–¥–ª—è —Å—Ç–∞—Ä—ã—Ö —Å–∏–≥–Ω–∞–ª–æ–≤)
  #     weak_trigger = False
  #     signal_age_minutes = 0
  #
  #     # –ü—Ä–æ–≤–µ—Ä—è–µ–º –≤–æ–∑—Ä–∞—Å—Ç —Å–∏–≥–Ω–∞–ª–∞ –µ—Å–ª–∏ –µ—Å—Ç—å –¥–æ—Å—Ç—É–ø –∫ pending_signals
  #     try:
  #       if hasattr(self, 'state_manager'):
  #         pending_signals = self.state_manager.get_pending_signals()
  #         for sym, sig_data in pending_signals.items():
  #           if 'metadata' in sig_data and 'signal_time' in sig_data['metadata']:
  #             signal_time = datetime.fromisoformat(sig_data['metadata']['signal_time'])
  #             signal_age_minutes = (datetime.now() - signal_time).seconds / 60
  #             break
  #     except:
  #       pass
  #
  #     # –ï—Å–ª–∏ —Å–∏–≥–Ω–∞–ª —Å—Ç–∞—Ä—à–µ 30 –º–∏–Ω—É—Ç - —Å–º—è–≥—á–∞–µ–º —É—Å–ª–æ–≤–∏—è
  #     if signal_age_minutes > 30:
  #       if signal_type == SignalType.BUY:
  #         weak_trigger = df['rsi'].iloc[-1] > 40 and price_momentum
  #       else:
  #         weak_trigger = df['rsi'].iloc[-1] < 60 and price_momentum
  #
  #     # –§–ò–ù–ê–õ–¨–ù–û–ï –†–ï–®–ï–ù–ò–ï
  #     trigger_fired = False
  #     trigger_reason = ""
  #
  #     if strong_buy_trigger or strong_sell_trigger:
  #       trigger_fired = True
  #       trigger_reason = "STRONG"
  #     elif medium_buy_trigger or medium_sell_trigger:
  #       trigger_fired = True
  #       trigger_reason = "MEDIUM"
  #     elif weak_trigger and signal_age_minutes > 30:
  #       trigger_fired = True
  #       trigger_reason = f"WEAK (age: {signal_age_minutes:.0f}m)"
  #     elif (volume_confirmation and price_momentum and volatility_ok):
  #       # –≠–∫—Å—Ç—Ä–µ–Ω–Ω—ã–π —Ä–µ–∂–∏–º - –µ—Å–ª–∏ –µ—Å—Ç—å –æ–±—ä–µ–º –∏ –∏–º–ø—É–ª—å—Å
  #       trigger_fired = True
  #       trigger_reason = "EMERGENCY"
  #
  #     # –ü—Ä–æ–≤–µ—Ä–∫–∞ –≤–æ–ª–∞—Ç–∏–ª—å–Ω–æ—Å—Ç–∏ –±–ª–æ–∫–∏—Ä—É–µ—Ç –≤—Å–µ —Ç—Ä–∏–≥–≥–µ—Ä—ã
  #     if not volatility_ok:
  #       trigger_fired = False
  #       trigger_reason = "BLOCKED_BY_VOLATILITY"
  #
  #     # –†–∞—Å—à–∏—Ä–µ–Ω–Ω–æ–µ –ª–æ–≥–∏—Ä–æ–≤–∞–Ω–∏–µ
  #     if trigger_fired:
  #       logger.info(f"‚úÖ –¢–†–ò–ì–ì–ï–† LTF –¥–ª—è {signal_type.value} —Å—Ä–∞–±–æ—Ç–∞–ª! –ü—Ä–∏—á–∏–Ω–∞: {trigger_reason}")
  #       logger.debug(f"–î–µ—Ç–∞–ª–∏: MFI={df['mfi'].iloc[-1]:.1f}, RSI={df['rsi'].iloc[-1]:.1f}, "
  #                    f"Momentum={'‚úì' if price_momentum else '‚úó'}, "
  #                    f"Volume={'‚úì' if volume_confirmation else '‚úó'}")
  #     else:
  #       logger.debug(f"–¢—Ä–∏–≥–≥–µ—Ä LTF –Ω–µ —Å—Ä–∞–±–æ—Ç–∞–ª. RSI={df['rsi'].iloc[-1]:.1f}, "
  #                    f"MFI={df['mfi'].iloc[-1]:.1f}, Volatility={'OK' if volatility_ok else 'LOW'}")
  #
  #     return trigger_fired
  #
  #   except Exception as e:
  #     logger.error(f"–û—à–∏–±–∫–∞ –≤ —Ç—Ä–∏–≥–≥–µ—Ä–µ LTF: {e}", exc_info=True)
  #     return False
  #

  def _check_ltf_entry_trigger(self, data: pd.DataFrame, signal_type: SignalType) -> bool:
      """
      –£–õ–£–ß–®–ï–ù–ù–ê–Ø –í–ï–†–°–ò–Ø: –ü—Ä–æ–≤–µ—Ä—è–µ—Ç —Ç—Ä–∏–≥–≥–µ—Ä –¥–ª—è –≤—Ö–æ–¥–∞ –Ω–∞ –º–∞–ª–æ–º —Ç–∞–π–º—Ñ—Ä–µ–π–º–µ,
      –∏—Å–ø–æ–ª—å–∑—É—è –∞–Ω–∞–ª–∏–∑ —É—Ä–æ–≤–Ω–µ–π –ø–æ–¥–¥–µ—Ä–∂–∫–∏/—Å–æ–ø—Ä–æ—Ç–∏–≤–ª–µ–Ω–∏—è –∏ —Å–≤–µ—á–Ω—ã—Ö –ø–∞—Ç—Ç–µ—Ä–Ω–æ–≤
      —Å–æ–≥–ª–∞—Å–Ω–æ –¥–æ–∫—É–º–µ–Ω—Ç—É "–ü—Ä–∞–≤–∏–ª–∞ –≤—Ö–æ–¥–∞ –≤ —Å–¥–µ–ª–∫—É"
      """
      if data.empty or len(data) < 50:  # –ù—É–∂–Ω–æ –±–æ–ª—å—à–µ –¥–∞–Ω–Ω—ã—Ö –¥–ª—è –∞–Ω–∞–ª–∏–∑–∞ —É—Ä–æ–≤–Ω–µ–π
        return False

      try:
        df = data.copy()

        # –û—á–∏—Å—Ç–∫–∞ –¥–∞–Ω–Ω—ã—Ö
        required_cols = ['open', 'high', 'low', 'close', 'volume']
        for col in required_cols:
          if col in df.columns:
            df[col] = pd.to_numeric(df[col], errors='coerce')
        df.dropna(subset=required_cols, inplace=True)

        if len(df) < 50:
          return False

        # === –®–ê–ì 1: –ü–û–ò–°–ö –£–†–û–í–ù–ï–ô –ü–û–î–î–ï–†–ñ–ö–ò –ò –°–û–ü–†–û–¢–ò–í–õ–ï–ù–ò–Ø ===
        support_levels, resistance_levels = self._find_support_resistance_levels(df)
        current_price = df['close'].iloc[-1]

        # –ü—Ä–æ–≤–µ—Ä—è–µ–º –±–ª–∏–∑–æ—Å—Ç—å –∫ —É—Ä–æ–≤–Ω—è–º (–≤ –ø—Ä–µ–¥–µ–ª–∞—Ö 0.3% –¥–ª—è –∫—Ä–∏–ø—Ç–æ)
        price_range = df['high'].max() - df['low'].min()
        proximity_threshold = price_range * 0.003  # 0.3% –æ—Ç –¥–∏–∞–ø–∞–∑–æ–Ω–∞

        near_support = any(abs(current_price - level) < proximity_threshold for level in support_levels)
        near_resistance = any(abs(current_price - level) < proximity_threshold for level in resistance_levels)

        logger.debug(
          f"–£—Ä–æ–≤–Ω–∏ –¥–ª—è {signal_type.value}: –ü–æ–¥–¥–µ—Ä–∂–∫–∞={support_levels[:3]}, –°–æ–ø—Ä–æ—Ç–∏–≤–ª–µ–Ω–∏–µ={resistance_levels[:3]}")
        logger.debug(
          f"–¢–µ–∫—É—â–∞—è —Ü–µ–Ω–∞: {current_price}, –ë–ª–∏–∑–∫–æ –∫ –ø–æ–¥–¥–µ—Ä–∂–∫–µ: {near_support}, –ë–ª–∏–∑–∫–æ –∫ —Å–æ–ø—Ä–æ—Ç–∏–≤–ª–µ–Ω–∏—é: {near_resistance}")

        # === –®–ê–ì 2: –ü–†–û–í–ï–†–ö–ê –°–¢–†–£–ö–¢–£–†–´ –†–´–ù–ö–ê (Higher Highs/Lower Lows) ===
        market_structure = self._analyze_market_structure(df)

        # === –®–ê–ì 3: –ü–û–ò–°–ö –°–í–ï–ß–ù–´–• –ü–ê–¢–¢–ï–†–ù–û–í ===
        reversal_pattern = self._check_reversal_patterns(df, signal_type)

        # === –®–ê–ì 4: –†–ê–°–ß–ï–¢ –¢–ï–•–ù–ò–ß–ï–°–ö–ò–• –ò–ù–î–ò–ö–ê–¢–û–†–û–í ===
        # RSI
        df['rsi'] = ta.rsi(df['close'], length=14)
        # MACD
        macd = ta.macd(df['close'], fast=12, slow=26, signal=9)
        if macd is not None and not macd.empty:
          df['macd_line'] = macd.iloc[:, 0]
          df['macd_signal'] = macd.iloc[:, 1]
          df['macd_hist'] = macd.iloc[:, 2]

        # Stochastic
        stoch = ta.stoch(df['high'], df['low'], df['close'], k=14, d=3)
        if stoch is not None and not stoch.empty:
          df['stoch_k'] = stoch.iloc[:, 0]
          df['stoch_d'] = stoch.iloc[:, 1]

        # Volume analysis
        df['volume_sma'] = df['volume'].rolling(20).mean()
        volume_spike = df['volume'].iloc[-1] > df['volume_sma'].iloc[-1] * 1.5

        # === –®–ê–ì 5: –ü–†–û–í–ï–†–ö–ê –î–ò–í–ï–†–ì–ï–ù–¶–ò–ô ===
        divergence = self._check_divergence(df, signal_type)

        # === –®–ê–ì 6: –ö–û–ú–ü–õ–ï–ö–°–ù–ê–Ø –û–¶–ï–ù–ö–ê –£–°–õ–û–í–ò–ô –î–õ–Ø –í–•–û–î–ê ===

        if signal_type == SignalType.BUY:
          # –£—Å–ª–æ–≤–∏—è –¥–ª—è –ø–æ–∫—É–ø–∫–∏ —Å–æ–≥–ª–∞—Å–Ω–æ –¥–æ–∫—É–º–µ–Ω—Ç—É:

          # 1. –ò–î–ï–ê–õ–¨–ù–´–ô –í–•–û–î: –£ –ø–æ–¥–¥–µ—Ä–∂–∫–∏ + —Ä–∞–∑–≤–æ—Ä–æ—Ç–Ω—ã–π –ø–∞—Ç—Ç–µ—Ä–Ω + –ø–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–∏–µ –∏–Ω–¥–∏–∫–∞—Ç–æ—Ä–∞–º–∏
          if near_support and reversal_pattern == 'bullish':
            if (df['rsi'].iloc[-1] < 40 or  # RSI –≤—ã—Ö–æ–¥–∏—Ç –∏–∑ –ø–µ—Ä–µ–ø—Ä–æ–¥–∞–Ω–Ω–æ—Å—Ç–∏
                divergence == 'bullish' or  # –ë—ã—á—å—è –¥–∏–≤–µ—Ä–≥–µ–Ω—Ü–∏—è
                (df.get('stoch_k', pd.Series()).iloc[-1] < 30 and
                 df.get('stoch_k', pd.Series()).iloc[-1] > df.get('stoch_d', pd.Series()).iloc[
                   -1])):  # Stoch –ø–µ—Ä–µ—Å–µ—á–µ–Ω–∏–µ

              logger.info(f"‚úÖ –ò–î–ï–ê–õ–¨–ù–´–ô –≤—Ö–æ–¥ BUY: –ø–æ–¥–¥–µ—Ä–∂–∫–∞ + {reversal_pattern} –ø–∞—Ç—Ç–µ—Ä–Ω + –∏–Ω–¥–∏–∫–∞—Ç–æ—Ä—ã")
              return True

          # 2. –•–û–†–û–®–ò–ô –í–•–û–î: –°—Ç—Ä—É–∫—Ç—É—Ä–∞ —Ä—ã–Ω–∫–∞ –±—ã—á—å—è + –æ—Ç–∫–∞—Ç –∫ —É—Ä–æ–≤–Ω—é
          if market_structure == 'uptrend' and near_support:
            if df['rsi'].iloc[-1] < 50 and volume_spike:
              logger.info(f"‚úÖ –•–û–†–û–®–ò–ô –≤—Ö–æ–¥ BUY: –≤–æ—Å—Ö–æ–¥—è—â–∏–π —Ç—Ä–µ–Ω–¥ + –æ—Ç–∫–∞—Ç –∫ –ø–æ–¥–¥–µ—Ä–∂–∫–µ")
              return True

          # 3. –ü–†–ò–ï–ú–õ–ï–ú–´–ô –í–•–û–î: –°–∏–ª—å–Ω—ã–π –∏–º–ø—É–ª—å—Å –æ—Ç —É—Ä–æ–≤–Ω—è
          if near_support:
            # –ü—Ä–æ–≤–µ—Ä—è–µ–º –∏–º–ø—É–ª—å—Å–Ω–æ–µ –¥–≤–∏–∂–µ–Ω–∏–µ –æ—Ç —É—Ä–æ–≤–Ω—è
            last_3_candles = df.tail(3)
            price_momentum = (last_3_candles['close'].iloc[-1] - last_3_candles['low'].min()) / last_3_candles[
              'low'].min()

            if price_momentum > 0.005 and volume_spike:  # 0.5% –¥–≤–∏–∂–µ–Ω–∏–µ —Å –æ–±—ä–µ–º–æ–º
              logger.info(f"‚úÖ –ü–†–ò–ï–ú–õ–ï–ú–´–ô –≤—Ö–æ–¥ BUY: –∏–º–ø—É–ª—å—Å –æ—Ç –ø–æ–¥–¥–µ—Ä–∂–∫–∏ —Å –æ–±—ä–µ–º–æ–º")
              return True

        else:  # SignalType.SELL
          # –£—Å–ª–æ–≤–∏—è –¥–ª—è –ø—Ä–æ–¥–∞–∂–∏ (–∑–µ—Ä–∫–∞–ª—å–Ω–æ):

          # 1. –ò–î–ï–ê–õ–¨–ù–´–ô –í–•–û–î: –£ —Å–æ–ø—Ä–æ—Ç–∏–≤–ª–µ–Ω–∏—è + —Ä–∞–∑–≤–æ—Ä–æ—Ç–Ω—ã–π –ø–∞—Ç—Ç–µ—Ä–Ω
          if near_resistance and reversal_pattern == 'bearish':
            if (df['rsi'].iloc[-1] > 60 or  # RSI –≤—ã—Ö–æ–¥–∏—Ç –∏–∑ –ø–µ—Ä–µ–∫—É–ø–ª–µ–Ω–Ω–æ—Å—Ç–∏
                divergence == 'bearish' or  # –ú–µ–¥–≤–µ–∂—å—è –¥–∏–≤–µ—Ä–≥–µ–Ω—Ü–∏—è
                (df.get('stoch_k', pd.Series()).iloc[-1] > 70 and
                 df.get('stoch_k', pd.Series()).iloc[-1] < df.get('stoch_d', pd.Series()).iloc[
                   -1])):  # Stoch –ø–µ—Ä–µ—Å–µ—á–µ–Ω–∏–µ

              logger.info(f"‚úÖ –ò–î–ï–ê–õ–¨–ù–´–ô –≤—Ö–æ–¥ SELL: —Å–æ–ø—Ä–æ—Ç–∏–≤–ª–µ–Ω–∏–µ + {reversal_pattern} –ø–∞—Ç—Ç–µ—Ä–Ω + –∏–Ω–¥–∏–∫–∞—Ç–æ—Ä—ã")
              return True

          # 2. –•–û–†–û–®–ò–ô –í–•–û–î: –°—Ç—Ä—É–∫—Ç—É—Ä–∞ —Ä—ã–Ω–∫–∞ –º–µ–¥–≤–µ–∂—å—è + –æ—Ç–∫–∞—Ç –∫ —É—Ä–æ–≤–Ω—é
          if market_structure == 'downtrend' and near_resistance:
            if df['rsi'].iloc[-1] > 50 and volume_spike:
              logger.info(f"‚úÖ –•–û–†–û–®–ò–ô –≤—Ö–æ–¥ SELL: –Ω–∏—Å—Ö–æ–¥—è—â–∏–π —Ç—Ä–µ–Ω–¥ + –æ—Ç–∫–∞—Ç –∫ —Å–æ–ø—Ä–æ—Ç–∏–≤–ª–µ–Ω–∏—é")
              return True

          # 3. –ü–†–ò–ï–ú–õ–ï–ú–´–ô –í–•–û–î: –°–∏–ª—å–Ω—ã–π –∏–º–ø—É–ª—å—Å –æ—Ç —É—Ä–æ–≤–Ω—è
          if near_resistance:
            last_3_candles = df.tail(3)
            price_momentum = (last_3_candles['high'].max() - last_3_candles['close'].iloc[-1]) / last_3_candles[
              'high'].max()

            if price_momentum > 0.005 and volume_spike:
              logger.info(f"‚úÖ –ü–†–ò–ï–ú–õ–ï–ú–´–ô –≤—Ö–æ–¥ SELL: –∏–º–ø—É–ª—å—Å –æ—Ç —Å–æ–ø—Ä–æ—Ç–∏–≤–ª–µ–Ω–∏—è —Å –æ–±—ä–µ–º–æ–º")
              return True

        # –ï—Å–ª–∏ –Ω–∏ –æ–¥–Ω–æ —É—Å–ª–æ–≤–∏–µ –Ω–µ –≤—ã–ø–æ–ª–Ω–µ–Ω–æ - –ù–ï –í–•–û–î–ò–ú
        logger.debug(f"–í—Ö–æ–¥ –Ω–µ –ø–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω. –ñ–¥–µ–º –ª—É—á—à–∏—Ö —É—Å–ª–æ–≤–∏–π...")
        return False

      except Exception as e:
        logger.error(f"–û—à–∏–±–∫–∞ –≤ —É–ª—É—á—à–µ–Ω–Ω–æ–º —Ç—Ä–∏–≥–≥–µ—Ä–µ LTF: {e}", exc_info=True)
        return False

  def _find_support_resistance_levels(self, df: pd.DataFrame) -> tuple:
    """
    –ù–∞—Ö–æ–¥–∏—Ç —É—Ä–æ–≤–Ω–∏ –ø–æ–¥–¥–µ—Ä–∂–∫–∏ –∏ —Å–æ–ø—Ä–æ—Ç–∏–≤–ª–µ–Ω–∏—è –Ω–∞ –æ—Å–Ω–æ–≤–µ –ª–æ–∫–∞–ª—å–Ω—ã—Ö —ç–∫—Å—Ç—Ä–µ–º—É–º–æ–≤
    """
    window = 10  # –û–∫–Ω–æ –¥–ª—è –ø–æ–∏—Å–∫–∞ –ª–æ–∫–∞–ª—å–Ω—ã—Ö —ç–∫—Å—Ç—Ä–µ–º—É–º–æ–≤

    # –ü–æ–∏—Å–∫ –ª–æ–∫–∞–ª—å–Ω—ã—Ö –º–∞–∫—Å–∏–º—É–º–æ–≤ (—Å–æ–ø—Ä–æ—Ç–∏–≤–ª–µ–Ω–∏—è)
    highs = df['high'].values
    resistance_levels = []

    for i in range(window, len(highs) - window):
      if highs[i] == max(highs[i - window:i + window + 1]):
        resistance_levels.append(highs[i])

    # –ü–æ–∏—Å–∫ –ª–æ–∫–∞–ª—å–Ω—ã—Ö –º–∏–Ω–∏–º—É–º–æ–≤ (–ø–æ–¥–¥–µ—Ä–∂–∫–∏)
    lows = df['low'].values
    support_levels = []

    for i in range(window, len(lows) - window):
      if lows[i] == min(lows[i - window:i + window + 1]):
        support_levels.append(lows[i])

    # –§–∏–ª—å—Ç—Ä—É–µ–º –±–ª–∏–∑–∫–∏–µ —É—Ä–æ–≤–Ω–∏ (–æ–±—ä–µ–¥–∏–Ω—è–µ–º –≤ –∫–ª–∞—Å—Ç–µ—Ä—ã)
    def cluster_levels(levels, threshold=0.002):  # 0.2% –ø–æ—Ä–æ–≥
      if not levels:
        return []

      clustered = []
      sorted_levels = sorted(levels)
      current_cluster = [sorted_levels[0]]

      for level in sorted_levels[1:]:
        if (level - current_cluster[-1]) / current_cluster[-1] < threshold:
          current_cluster.append(level)
        else:
          clustered.append(sum(current_cluster) / len(current_cluster))
          current_cluster = [level]

      clustered.append(sum(current_cluster) / len(current_cluster))
      return clustered

    support_levels = cluster_levels(support_levels)
    resistance_levels = cluster_levels(resistance_levels)

    # –°–æ—Ä—Ç–∏—Ä—É–µ–º –∏ –≤–æ–∑–≤—Ä–∞—â–∞–µ–º –±–ª–∏–∂–∞–π—à–∏–µ –∫ —Ç–µ–∫—É—â–µ–π —Ü–µ–Ω–µ
    current_price = df['close'].iloc[-1]
    support_levels = sorted([s for s in support_levels if s < current_price], reverse=True)
    resistance_levels = sorted([r for r in resistance_levels if r > current_price])

    return support_levels[:5], resistance_levels[:5]  # –¢–æ–ø-5 —É—Ä–æ–≤–Ω–µ–π

  def _analyze_market_structure(self, df: pd.DataFrame) -> str:
    """
    –ê–Ω–∞–ª–∏–∑–∏—Ä—É–µ—Ç —Å—Ç—Ä—É–∫—Ç—É—Ä—É —Ä—ã–Ω–∫–∞ (Higher Highs/Lower Lows)
    """
    # –ù–∞—Ö–æ–¥–∏–º —Å–≤–∏–Ω–≥-—Ç–æ—á–∫–∏
    swing_highs = []
    swing_lows = []

    for i in range(2, len(df) - 2):
      # Swing high
      if (df['high'].iloc[i] > df['high'].iloc[i - 1] and
          df['high'].iloc[i] > df['high'].iloc[i - 2] and
          df['high'].iloc[i] > df['high'].iloc[i + 1] and
          df['high'].iloc[i] > df['high'].iloc[i + 2]):
        swing_highs.append((i, df['high'].iloc[i]))

      # Swing low
      if (df['low'].iloc[i] < df['low'].iloc[i - 1] and
          df['low'].iloc[i] < df['low'].iloc[i - 2] and
          df['low'].iloc[i] < df['low'].iloc[i + 1] and
          df['low'].iloc[i] < df['low'].iloc[i + 2]):
        swing_lows.append((i, df['low'].iloc[i]))

    # –ê–Ω–∞–ª–∏–∑–∏—Ä—É–µ–º –ø–æ—Å–ª–µ–¥–Ω–∏–µ —Å–≤–∏–Ω–≥–∏
    if len(swing_highs) >= 2 and len(swing_lows) >= 2:
      # Higher Highs –∏ Higher Lows = Uptrend
      if (swing_highs[-1][1] > swing_highs[-2][1] and
          swing_lows[-1][1] > swing_lows[-2][1]):
        return 'uptrend'

      # Lower Highs –∏ Lower Lows = Downtrend
      elif (swing_highs[-1][1] < swing_highs[-2][1] and
            swing_lows[-1][1] < swing_lows[-2][1]):
        return 'downtrend'

    return 'sideways'

  def _check_reversal_patterns(self, df: pd.DataFrame, signal_type: SignalType) -> str:
    """
    –ü—Ä–æ–≤–µ—Ä—è–µ—Ç –Ω–∞–ª–∏—á–∏–µ —Ä–∞–∑–≤–æ—Ä–æ—Ç–Ω—ã—Ö —Å–≤–µ—á–Ω—ã—Ö –ø–∞—Ç—Ç–µ—Ä–Ω–æ–≤
    """
    if len(df) < 3:
      return 'none'

    # –ü–æ—Å–ª–µ–¥–Ω–∏–µ 3 —Å–≤–µ—á–∏ –¥–ª—è –∞–Ω–∞–ª–∏–∑–∞
    last_3 = df.tail(3)

    # –î–ª—è –ø–æ–∫—É–ø–∫–∏ –∏—â–µ–º –±—ã—á—å–∏ –ø–∞—Ç—Ç–µ—Ä–Ω—ã
    if signal_type == SignalType.BUY:
      # –ú–æ–ª–æ—Ç (Hammer)
      last_candle = last_3.iloc[-1]
      body = abs(last_candle['close'] - last_candle['open'])
      lower_shadow = min(last_candle['open'], last_candle['close']) - last_candle['low']
      upper_shadow = last_candle['high'] - max(last_candle['open'], last_candle['close'])

      if lower_shadow > body * 2 and upper_shadow < body * 0.5:
        return 'bullish'

      # –ë—ã—á—å–µ –ø–æ–≥–ª–æ—â–µ–Ω–∏–µ
      if len(last_3) >= 2:
        prev_candle = last_3.iloc[-2]
        if (prev_candle['close'] < prev_candle['open'] and  # –ü—Ä–µ–¥—ã–¥—É—â–∞—è –º–µ–¥–≤–µ–∂—å—è
            last_candle['close'] > last_candle['open'] and  # –¢–µ–∫—É—â–∞—è –±—ã—á—å—è
            last_candle['open'] <= prev_candle['close'] and  # –û—Ç–∫—Ä—ã—Ç–∏–µ –Ω–∏–∂–µ –∑–∞–∫—Ä—ã—Ç–∏—è –ø—Ä–µ–¥—ã–¥—É—â–µ–π
            last_candle['close'] > prev_candle['open']):  # –ó–∞–∫—Ä—ã—Ç–∏–µ –≤—ã—à–µ –æ—Ç–∫—Ä—ã—Ç–∏—è –ø—Ä–µ–¥—ã–¥—É—â–µ–π
          return 'bullish'

    # –î–ª—è –ø—Ä–æ–¥–∞–∂–∏ –∏—â–µ–º –º–µ–¥–≤–µ–∂—å–∏ –ø–∞—Ç—Ç–µ—Ä–Ω—ã
    else:
      # –ü–∞–¥–∞—é—â–∞—è –∑–≤–µ–∑–¥–∞ / –ü–æ–≤–µ—à–µ–Ω–Ω—ã–π
      last_candle = last_3.iloc[-1]
      body = abs(last_candle['close'] - last_candle['open'])
      upper_shadow = last_candle['high'] - max(last_candle['open'], last_candle['close'])
      lower_shadow = min(last_candle['open'], last_candle['close']) - last_candle['low']

      if upper_shadow > body * 2 and lower_shadow < body * 0.5:
        return 'bearish'

      # –ú–µ–¥–≤–µ–∂—å–µ –ø–æ–≥–ª–æ—â–µ–Ω–∏–µ
      if len(last_3) >= 2:
        prev_candle = last_3.iloc[-2]
        if (prev_candle['close'] > prev_candle['open'] and  # –ü—Ä–µ–¥—ã–¥—É—â–∞—è –±—ã—á—å—è
            last_candle['close'] < last_candle['open'] and  # –¢–µ–∫—É—â–∞—è –º–µ–¥–≤–µ–∂—å—è
            last_candle['open'] >= prev_candle['close'] and  # –û—Ç–∫—Ä—ã—Ç–∏–µ –≤—ã—à–µ –∑–∞–∫—Ä—ã—Ç–∏—è –ø—Ä–µ–¥—ã–¥—É—â–µ–π
            last_candle['close'] < prev_candle['open']):  # –ó–∞–∫—Ä—ã—Ç–∏–µ –Ω–∏–∂–µ –æ—Ç–∫—Ä—ã—Ç–∏—è –ø—Ä–µ–¥—ã–¥—É—â–µ–π
          return 'bearish'

    return 'none'

  def _check_divergence(self, df: pd.DataFrame, signal_type: SignalType) -> str:
    """
    –ü—Ä–æ–≤–µ—Ä—è–µ—Ç –¥–∏–≤–µ—Ä–≥–µ–Ω—Ü–∏—é –º–µ–∂–¥—É —Ü–µ–Ω–æ–π –∏ –æ—Å—Ü–∏–ª–ª—è—Ç–æ—Ä–∞–º–∏ (RSI/MACD)
    """
    if len(df) < 20:
      return 'none'

    # –ù–∞—Ö–æ–¥–∏–º –ø–æ—Å–ª–µ–¥–Ω–∏–µ –ª–æ–∫–∞–ª—å–Ω—ã–µ —ç–∫—Å—Ç—Ä–µ–º—É–º—ã
    window = 5

    if signal_type == SignalType.BUY:
      # –ò—â–µ–º –±—ã—á—å—é –¥–∏–≤–µ—Ä–≥–µ–Ω—Ü–∏—é (—Ü–µ–Ω–∞ –¥–µ–ª–∞–µ—Ç Lower Low, RSI –¥–µ–ª–∞–µ—Ç Higher Low)
      price_lows = []
      rsi_lows = []

      for i in range(window, len(df) - window):
        if df['low'].iloc[i] == df['low'].iloc[i - window:i + window + 1].min():
          price_lows.append((i, df['low'].iloc[i]))
          rsi_lows.append((i, df['rsi'].iloc[i]))

      if len(price_lows) >= 2:
        # –°—Ä–∞–≤–Ω–∏–≤–∞–µ–º –ø–æ—Å–ª–µ–¥–Ω–∏–µ –¥–≤–∞ –º–∏–Ω–∏–º—É–º–∞
        if (price_lows[-1][1] < price_lows[-2][1] and  # –¶–µ–Ω–∞: Lower Low
            rsi_lows[-1][1] > rsi_lows[-2][1]):  # RSI: Higher Low
          return 'bullish'

    else:  # SELL
      # –ò—â–µ–º –º–µ–¥–≤–µ–∂—å—é –¥–∏–≤–µ—Ä–≥–µ–Ω—Ü–∏—é (—Ü–µ–Ω–∞ –¥–µ–ª–∞–µ—Ç Higher High, RSI –¥–µ–ª–∞–µ—Ç Lower High)
      price_highs = []
      rsi_highs = []

      for i in range(window, len(df) - window):
        if df['high'].iloc[i] == df['high'].iloc[i - window:i + window + 1].max():
          price_highs.append((i, df['high'].iloc[i]))
          rsi_highs.append((i, df['rsi'].iloc[i]))

      if len(price_highs) >= 2:
        if (price_highs[-1][1] > price_highs[-2][1] and  # –¶–µ–Ω–∞: Higher High
            rsi_highs[-1][1] < rsi_highs[-2][1]):  # RSI: Lower High
          return 'bearish'

    return 'none'

  # def calculate_mfi_manual(self, high, low, close, volume, length=14):
  #   """–†—É—á–Ω–æ–π —Ä–∞—Å—á–µ—Ç MFI –µ—Å–ª–∏ pandas_ta –Ω–µ —Ä–∞–±–æ—Ç–∞–µ—Ç"""
  #   try:
  #     typical_price = (high + low + close) / 3
  #     money_flow = typical_price * volume
  #
  #     # –û–ø—Ä–µ–¥–µ–ª—è–µ–º –Ω–∞–ø—Ä–∞–≤–ª–µ–Ω–∏–µ –ø–æ—Ç–æ–∫–∞
  #     money_flow_positive = money_flow.where(typical_price > typical_price.shift(1), 0)
  #     money_flow_negative = money_flow.where(typical_price < typical_price.shift(1), 0)
  #
  #     # –°—É–º–º–∏—Ä—É–µ–º –∑–∞ –ø–µ—Ä–∏–æ–¥
  #     positive_flow = money_flow_positive.rolling(window=length).sum()
  #     negative_flow = money_flow_negative.rolling(window=length).sum()
  #
  #     # –†–∞—Å—Å—á–∏—Ç—ã–≤–∞–µ–º MFI
  #     money_ratio = positive_flow / (negative_flow + 1e-9)
  #     mfi = 100 - (100 / (1 + money_ratio))
  #
  #     return mfi
  #   except:
  #     return pd.Series([50] * len(close))  # –í–æ–∑–≤—Ä–∞—â–∞–µ–º –Ω–µ–π—Ç—Ä–∞–ª—å–Ω–æ–µ –∑–Ω–∞—á–µ–Ω–∏–µ

  async def initialize_with_optimization(self):
      """
      –û–ø—Ç–∏–º–∏–∑–∏—Ä–æ–≤–∞–Ω–Ω–∞—è –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è —Å–∏—Å—Ç–µ–º—ã —Å –ø—Ä–µ–¥–∑–∞–≥—Ä—É–∑–∫–æ–π –∫—ç—à–µ–π
      """
      logger.info("–ù–∞—á–∞–ª–æ –æ–ø—Ç–∏–º–∏–∑–∏—Ä–æ–≤–∞–Ω–Ω–æ–π –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏–∏ —Å–∏—Å—Ç–µ–º—ã...")

      # 1. –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä—É–µ–º –±–∞–∑–æ–≤—ã–µ –∫–æ–º–ø–æ–Ω–µ–Ω—Ç—ã
      await self.initialize()

      if not self.active_symbols:
        return

      # 2. –ü—Ä–µ–¥–∑–∞–≥—Ä—É–∂–∞–µ–º –¥–∞–Ω–Ω—ã–µ –≤ –∫—ç—à –¥–ª—è –∞–∫—Ç–∏–≤–Ω—ã—Ö —Å–∏–º–≤–æ–ª–æ–≤
      logger.info("–ü—Ä–µ–¥–∑–∞–≥—Ä—É–∑–∫–∞ –¥–∞–Ω–Ω—ã—Ö –≤ –∫—ç—à...")

      # –û–ø—Ä–µ–¥–µ–ª—è–µ–º —Ç–∞–π–º—Ñ—Ä–µ–π–º—ã –¥–ª—è –ø—Ä–µ–¥–∑–∞–≥—Ä—É–∑–∫–∏
      preload_timeframes = [
        Timeframe.FIFTEEN_MINUTES,  # –î–ª—è —Ç–æ—á–µ–∫ –≤—Ö–æ–¥–∞
        Timeframe.ONE_HOUR,  # –î–ª—è –æ—Å–Ω–æ–≤–Ω—ã—Ö —Å–∏–≥–Ω–∞–ª–æ–≤
        Timeframe.FOUR_HOURS,  # –î–ª—è –ø–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–∏—è —Ç—Ä–µ–Ω–¥–æ–≤
      ]

      # –ü—Ä–µ–¥–∑–∞–≥—Ä—É–∂–∞–µ–º –¥–∞–Ω–Ω—ã–µ –ø–∞—Ä–∞–ª–ª–µ–ª—å–Ω–æ
      await self.data_fetcher.preload_cache(
        symbols=self.active_symbols[:10],  # –¢–æ–ø-10 —Å–∏–º–≤–æ–ª–æ–≤
        timeframes=preload_timeframes
      )

      # 3. –ü—Ä–µ–¥–∑–∞–≥—Ä—É–∂–∞–µ–º –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é –æ–± –∏–Ω—Å—Ç—Ä—É–º–µ–Ω—Ç–∞—Ö
      logger.info("–ü—Ä–µ–¥–∑–∞–≥—Ä—É–∑–∫–∞ –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏–∏ –æ–± –∏–Ω—Å—Ç—Ä—É–º–µ–Ω—Ç–∞—Ö...")
      instrument_tasks = [
        self.data_fetcher.get_instrument_info(symbol)
        for symbol in self.active_symbols
      ]
      await asyncio.gather(*instrument_tasks, return_exceptions=True)

      # 4. –û–ø—Ç–∏–º–∏–∑–∏—Ä—É–µ–º –ø–∞—Ä–∞–º–µ—Ç—Ä—ã –∫–æ–Ω–Ω–µ–∫—Ç–æ—Ä–∞ –¥–ª—è –∞–∫—Ç–∏–≤–Ω—ã—Ö —Å–∏–º–≤–æ–ª–æ–≤
      if len(self.active_symbols) > 20:
        # –£–≤–µ–ª–∏—á–∏–≤–∞–µ–º –ª–∏–º–∏—Ç—ã –¥–ª—è –±–æ–ª—å—à–æ–≥–æ –∫–æ–ª–∏—á–µ—Å—Ç–≤–∞ —Å–∏–º–≤–æ–ª–æ–≤
        self.connector.semaphore = asyncio.Semaphore(30)
        logger.info("–£–≤–µ–ª–∏—á–µ–Ω—ã –ª–∏–º–∏—Ç—ã –ø–∞—Ä–∞–ª–ª–µ–ª—å–Ω—ã—Ö –∑–∞–ø—Ä–æ—Å–æ–≤ –¥–ª—è –±–æ–ª—å—à–æ–≥–æ –∫–æ–ª–∏—á–µ—Å—Ç–≤–∞ —Å–∏–º–≤–æ–ª–æ–≤")

      # 5. –í—ã–≤–æ–¥–∏–º —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫—É –∫—ç—à–∞
      cache_stats = self.data_fetcher.get_cache_stats()
      logger.info(f"–°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞ –∫—ç—à–∞ –ø–æ—Å–ª–µ –ø—Ä–µ–¥–∑–∞–≥—Ä—É–∑–∫–∏: {cache_stats}")

      if self.sar_strategy:
        try:
          # –ó–∞–ø—É—Å–∫–∞–µ–º –ø–µ—Ä–≤–æ–Ω–∞—á–∞–ª—å–Ω–æ–µ –æ–±–Ω–æ–≤–ª–µ–Ω–∏–µ —Å–∏–º–≤–æ–ª–æ–≤
          initial_symbols = await self.sar_strategy.update_monitored_symbols(self.data_fetcher)
          logger.info(f"üéØ SAR —Å—Ç—Ä–∞—Ç–µ–≥–∏—è –≥–æ—Ç–æ–≤–∞ –∫ —Ä–∞–±–æ—Ç–µ —Å {len(initial_symbols)} —Å–∏–º–≤–æ–ª–∞–º–∏")

          # –°–æ—Ö—Ä–∞–Ω—è–µ–º –Ω–∞—á–∞–ª—å–Ω—ã–π —Å—Ç–∞—Ç—É—Å
          sar_status = self.sar_strategy.get_strategy_status()
          self.state_manager.set_custom_data('sar_strategy_status', sar_status)

        except Exception as e:
          logger.error(f"–û—à–∏–±–∫–∞ –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏–∏ SAR —Å—Ç—Ä–∞—Ç–µ–≥–∏–∏: {e}")
      else:
        logger.warning("SAR —Å—Ç—Ä–∞—Ç–µ–≥–∏—è –Ω–µ –±—ã–ª–∞ –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä–æ–≤–∞–Ω–∞")

      logger.info("üöÄ –í—Å–µ –∫–æ–º–ø–æ–Ω–µ–Ω—Ç—ã —Å–∏—Å—Ç–µ–º—ã, –≤–∫–ª—é—á–∞—è SAR —Å—Ç—Ä–∞—Ç–µ–≥–∏—é, –≥–æ—Ç–æ–≤—ã –∫ —Ä–∞–±–æ—Ç–µ")


      logger.info("–û–ø—Ç–∏–º–∏–∑–∏—Ä–æ–≤–∞–Ω–Ω–∞—è –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è –∑–∞–≤–µ—Ä—à–µ–Ω–∞")

  async def update_focus_list(self):
    """–û–±–Ω–æ–≤–ª—è–µ—Ç —Å–ø–∏—Å–æ–∫ –ø—Ä–∏–æ—Ä–∏—Ç–µ—Ç–Ω—ã—Ö —Å–∏–º–≤–æ–ª–æ–≤ –¥–ª—è –º–æ–Ω–∏—Ç–æ—Ä–∏–Ω–≥–∞"""
    try:
      priority_config = self.config.get('general_settings', {}).get('priority_monitoring', {})
      if not priority_config.get('enabled', True):
        return

      logger.info("üîÑ –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ —Å–ø–∏—Å–∫–∞ –ø—Ä–∏–æ—Ä–∏—Ç–µ—Ç–Ω—ã—Ö —Å–∏–º–≤–æ–ª–æ–≤...")

      # –ü–æ–ª—É—á–∞–µ–º –¥–∞–Ω–Ω—ã–µ –æ –≤–æ–ª–∞—Ç–∏–ª—å–Ω–æ—Å—Ç–∏ –¥–ª—è –≤—Å–µ—Ö —Å–∏–º–≤–æ–ª–æ–≤ –∏–∑ watchlist
      volatility_data = await self.data_fetcher.get_symbols_volatility_batch(
        self.watchlist_symbols,
        limit=priority_config.get('focus_list_size', 20) * 2  # –ë–µ—Ä–µ–º —Å –∑–∞–ø–∞—Å–æ–º
      )

      if not volatility_data:
        logger.warning("–ù–µ —É–¥–∞–ª–æ—Å—å –ø–æ–ª—É—á–∏—Ç—å –¥–∞–Ω–Ω—ã–µ –æ –≤–æ–ª–∞—Ç–∏–ª—å–Ω–æ—Å—Ç–∏")
        return

      # –§–∏–ª—å—Ç—Ä—É–µ–º –ø–æ –∫—Ä–∏—Ç–µ—Ä–∏—è–º
      focus_candidates = []

      volatility_threshold = priority_config.get('volatility_threshold_percent', 3.0)
      volume_spike_ratio = priority_config.get('volume_spike_ratio', 2.0)
      atr_spike_ratio = priority_config.get('atr_spike_ratio', 2.0)

      for item in volatility_data:
        symbol = item['symbol']

        # –ö—Ä–∏—Ç–µ—Ä–∏–π 1: –ò–∑–º–µ–Ω–µ–Ω–∏–µ —Ü–µ–Ω—ã –∑–∞ 24—á > –ø–æ—Ä–æ–≥–∞
        if abs(item['price_change_24h']) < volatility_threshold:
          continue

        # –ö—Ä–∏—Ç–µ—Ä–∏–π 2: ATR –≤—ã—à–µ –Ω–æ—Ä–º—ã
        if item['atr_percent'] < 1.0:  # –ú–∏–Ω–∏–º—É–º 1% ATR
          continue

        # –î–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω–∞—è –ø—Ä–æ–≤–µ—Ä–∫–∞: –Ω–µ –±–µ—Ä–µ–º –∞–Ω–æ–º–∞–ª—å–Ω—ã–µ –ø–∞–º–ø—ã
        if abs(item['price_change_24h']) > 100:  # –ë–æ–ª–µ–µ 30% –∑–∞ –¥–µ–Ω—å - –ø–æ–¥–æ–∑—Ä–∏—Ç–µ–ª—å–Ω–æ
          logger.warning(f"–ü—Ä–æ–ø—É—Å–∫–∞–µ–º {symbol} - –∞–Ω–æ–º–∞–ª—å–Ω–æ–µ –¥–≤–∏–∂–µ–Ω–∏–µ {item['price_change_24h']:.1f}%")
          continue

        focus_candidates.append(item)

      # –°–æ—Ä—Ç–∏—Ä—É–µ–º –ø–æ –≤–æ–ª–∞—Ç–∏–ª—å–Ω–æ—Å—Ç–∏ –∏ –±–µ—Ä–µ–º —Ç–æ–ø
      focus_candidates.sort(key=lambda x: x['volatility_score'], reverse=True)
      new_focus_list = [item['symbol'] for item in focus_candidates[:priority_config.get('focus_list_size', 40)]]

      # –û–±–Ω–æ–≤–ª—è–µ–º focus list
      old_focus = set(self.focus_list_symbols)
      new_focus = set(new_focus_list)

      added = new_focus - old_focus
      removed = old_focus - new_focus

      if added:
        logger.info(f"‚ûï –î–æ–±–∞–≤–ª–µ–Ω—ã –≤ –ø—Ä–∏–æ—Ä–∏—Ç–µ—Ç: {', '.join(added)}")
      if removed:
        logger.info(f"‚ûñ –£–¥–∞–ª–µ–Ω—ã –∏–∑ –ø—Ä–∏–æ—Ä–∏—Ç–µ—Ç–∞: {', '.join(removed)}")

      self.focus_list_symbols = new_focus_list
      self.last_focus_update = datetime.now()

      # –°–æ—Ö—Ä–∞–Ω—è–µ–º –≤ state manager –¥–ª—è –æ—Ç–æ–±—Ä–∞–∂–µ–Ω–∏—è
      self.state_manager.set_custom_data('focus_list', {
        'symbols': self.focus_list_symbols,
        'updated': self.last_focus_update.isoformat(),
        'stats': {
          'total': len(self.focus_list_symbols),
          'top_movers': focus_candidates[:5] if focus_candidates else []
        }
      })

      logger.info(f"‚úÖ Focus list –æ–±–Ω–æ–≤–ª–µ–Ω: {len(self.focus_list_symbols)} —Å–∏–º–≤–æ–ª–æ–≤")

    except Exception as e:
      logger.error(f"–û—à–∏–±–∫–∞ –æ–±–Ω–æ–≤–ª–µ–Ω–∏—è focus list: {e}")

  async def _monitoring_loop_optimized(self):
    """
    –û–ø—Ç–∏–º–∏–∑–∏—Ä–æ–≤–∞–Ω–Ω—ã–π –º–æ–Ω–∏—Ç–æ—Ä–∏–Ω–≥ —Å –±–∞—Ç—á–∏–Ω–≥–æ–º –∑–∞–ø—Ä–æ—Å–æ–≤
    """
    logger.info("–ó–∞–ø—É—Å–∫ –æ–ø—Ç–∏–º–∏–∑–∏—Ä–æ–≤–∞–Ω–Ω–æ–≥–æ —Ü–∏–∫–ª–∞ –º–æ–Ω–∏—Ç–æ—Ä–∏–Ω–≥–∞...")

    monitoring_interval = self.config.get('general_settings', {}).get('monitoring_interval_seconds', 45)
    batch_size = 5  # –û–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ–º —Å–∏–º–≤–æ–ª—ã –±–∞—Ç—á–∞–º–∏

    # –°—á–µ—Ç—á–∏–∫–∏ –¥–ª—è –æ—Ç—Å–ª–µ–∂–∏–≤–∞–Ω–∏—è
    cycle_count = 0
    last_activity_time = datetime.now()

    await self.position_manager.load_open_positions()
    # –ü–µ—Ä–∏–æ–¥–∏—á–µ—Å–∫–∞—è –ø—Ä–æ–≤–µ—Ä–∫–∞ –∑–¥–æ—Ä–æ–≤—å—è —Å–∏—Å—Ç–µ–º—ã
    current_time = time.time()
    if (hasattr(self, 'get_system_health') and
        current_time - self._last_health_check > self._health_check_interval):
      try:
        health_status = await self.get_system_health()
        if health_status.get('status') != 'healthy':
          logger.warning(f"–ü—Ä–æ–±–ª–µ–º—ã —Å–æ –∑–¥–æ—Ä–æ–≤—å–µ–º —Å–∏—Å—Ç–µ–º—ã: {health_status}")
        self._last_health_check = current_time
      except Exception as e:
        logger.error(f"–û—à–∏–±–∫–∞ –ø—Ä–æ–≤–µ—Ä–∫–∏ –∑–¥–æ—Ä–æ–≤—å—è —Å–∏—Å—Ç–µ–º—ã: {e}")

    while self.is_running:
      try:
        cycle_start_time = datetime.now()
        cycle_count += 1

        # # –ü–†–û–í–ï–†–ö–ê –ò –ó–ê–ü–£–°–ö RL-–°–¢–†–ê–¢–ï–ì–ò–ò (–∏–º–µ–µ—Ç –Ω–∞–∏–≤—ã—Å—à–∏–π –ø—Ä–∏–æ—Ä–∏—Ç–µ—Ç)
        # # –ï–µ –º–æ–∂–Ω–æ –≤–∫–ª—é—á–∞—Ç—å/–≤—ã–∫–ª—é—á–∞—Ç—å —á–µ—Ä–µ–∑ –∫–æ–Ω—Ñ–∏–≥
        # if self.finrl_strategy and self.config.get('general_settings', {}).get('use_finrl_strategy', False):
        #
        #   # 1. –°–æ–±–∏—Ä–∞–µ–º —Ç–µ–∫—É—â–µ–µ —Å–æ—Å—Ç–æ—è–Ω–∏–µ –¥–ª—è –≤—Å–µ—Ö –∞–∫—Ç–∏–≤–Ω—ã—Ö —Å–∏–º–≤–æ–ª–æ–≤
        #   portfolio_data_tasks = [self.data_fetcher.get_historical_candles(s, Timeframe.ONE_HOUR, 200) for s in self.active_symbols]
        #   portfolio_data_results = await asyncio.gather(*portfolio_data_tasks)
        #
        #   valid_dfs = []
        #   for i, df in enumerate(portfolio_data_results):
        #     if df is not None and not df.empty:
        #       df['symbol'] = self.active_symbols[i]
        #       valid_dfs.append(df)
        #
        #   if valid_dfs:
        #     current_portfolio_state = pd.concat(valid_dfs).sort_values(['timestamp', 'symbol']).reset_index(drop=True)
        #
        #     # 2. –ü–æ–ª—É—á–∞–µ–º –Ω–∞–±–æ—Ä —Å–∏–≥–Ω–∞–ª–æ–≤ –æ—Ç RL-–∞–≥–µ–Ω—Ç–∞
        #     rl_signals = await self.finrl_strategy.generate_portfolio_actions(current_portfolio_state)
        #
        #     # 3. –ò–°–ü–û–õ–ù–Ø–ï–ú –°–ò–ì–ù–ê–õ–´, –ò–°–ü–û–õ–¨–ó–£–Ø –°–£–©–ï–°–¢–í–£–Æ–©–ò–ô –ú–ï–¢–û–î
        #     if rl_signals:
        #       logger.info(f"–ü–æ–ª—É—á–µ–Ω–æ {len(rl_signals)} –¥–µ–π—Å—Ç–≤–∏–π –æ—Ç FinRL –∞–≥–µ–Ω—Ç–∞. –û—Ç–ø—Ä–∞–≤–∫–∞ –Ω–∞ –∏—Å–ø–æ–ª–Ω–µ–Ω–∏–µ...")
        #
        #       execution_tasks = []
        #       for signal in rl_signals:
        #         # –°–æ–∑–¥–∞–µ–º –∑–∞–¥–∞—á—É –Ω–∞ –∏—Å–ø–æ–ª–Ω–µ–Ω–∏–µ –¥–ª—è –∫–∞–∂–¥–æ–≥–æ —Å–∏–≥–Ω–∞–ª–∞
        #         task = self.trade_executor.execute_trade(
        #           signal=signal,
        #           symbol=signal.symbol,
        #           quantity=signal.quantity  # –ü—Ä–µ–¥–ø–æ–ª–∞–≥–∞–µ—Ç—Å—è, —á—Ç–æ —Å—Ç—Ä–∞—Ç–µ–≥–∏—è —Ä–∞—Å—Å—á–∏—Ç–∞–ª–∞ quantity
        #         )
        #         execution_tasks.append(task)
        #
        #       # –ê—Å–∏–Ω—Ö—Ä–æ–Ω–Ω–æ –∏—Å–ø–æ–ª–Ω—è–µ–º –≤—Å–µ –æ—Ä–¥–µ—Ä–∞
        #       await asyncio.gather(*execution_tasks, return_exceptions=True)
        #
        #     # –ü—Ä–æ–ø—É—Å–∫–∞–µ–º –æ—Å—Ç–∞–ª—å–Ω–æ–π —Ü–∏–∫–ª, —Ç–∞–∫ –∫–∞–∫ RL-–∞–≥–µ–Ω—Ç —É–ø—Ä–∞–≤–ª—è–µ—Ç –≤—Å–µ–º –ø–æ—Ä—Ç—Ñ–µ–ª–µ–º
        #   await asyncio.sleep(monitoring_interval)
        #   continue


        # –ü—Ä–æ–≤–µ—Ä–∫–∞ –Ω–∞ –∑–∞–≤–∏—Å–∞–Ω–∏–µ
        if (datetime.now() - last_activity_time).seconds > 300:  # 5 –º–∏–Ω—É—Ç
          logger.warning("–û–±–Ω–∞—Ä—É–∂–µ–Ω–æ –≤–æ–∑–º–æ–∂–Ω–æ–µ –∑–∞–≤–∏—Å–∞–Ω–∏–µ, –ø–µ—Ä–µ–∑–∞–≥—Ä—É–∂–∞–µ–º –ø–æ–∑–∏—Ü–∏–∏")
          await self.position_manager.load_open_positions()

        # –û–±–Ω–æ–≤–ª—è–µ–º focus list –µ—Å–ª–∏ –ø–æ—Ä–∞
        if self.priority_monitoring_enabled:
          priority_config = self.config.get('general_settings', {}).get('priority_monitoring', {})
          update_interval = priority_config.get('update_interval_minutes', 15)

          if (datetime.now() - self.last_focus_update).total_seconds() > update_interval * 60:
            await self.update_focus_list()

        # –ü—Ä–æ–≤–µ—Ä—è–µ–º –ø—Ä–∏–æ—Ä–∏—Ç–µ—Ç–Ω—ã–µ —Å–∏–º–≤–æ–ª—ã —á–∞—â–µ
        if self.focus_list_symbols and cycle_count % 3 == 1:  # –ö–∞–∂–¥—ã–π 3-–π —Ü–∏–∫–ª
          logger.debug(f"üéØ –ë—ã—Å—Ç—Ä–∞—è –ø—Ä–æ–≤–µ—Ä–∫–∞ {len(self.focus_list_symbols)} –ø—Ä–∏–æ—Ä–∏—Ç–µ—Ç–Ω—ã—Ö —Å–∏–º–≤–æ–ª–æ–≤")

          # –û–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ–º focus list —Å–∏–º–≤–æ–ª—ã
          for symbol in self.focus_list_symbols:
            if not self.is_running:
              break

            await self._monitor_symbol_for_entry_enhanced(symbol)
            await asyncio.sleep(1)

        # –û–±–Ω–æ–≤–ª—è–µ–º –±–∞–ª–∞–Ω—Å –æ–¥–∏–Ω —Ä–∞–∑ –∑–∞ —Ü–∏–∫–ª
        await self.update_account_balance()
        # –û–±–Ω–æ–≤–ª—è–µ–º –º–µ—Ç—Ä–∏–∫–∏ –±–∞–ª–∞–Ω—Å–∞ –¥–ª—è –¥–∞—à–±–æ—Ä–¥–∞
        if self.account_balance:
          self.state_manager.update_metrics(self.account_balance)

        # –£–ø—Ä–∞–≤–ª—è–µ–º –æ—Ç–∫—Ä—ã—Ç—ã–º–∏ –ø–æ–∑–∏—Ü–∏—è–º–∏

        await self._update_dashboard_metrics()
        # –ü–µ—Ä–∏–æ–¥–∏—á–µ—Å–∫–∞—è –ø—Ä–æ–≤–µ—Ä–∫–∞ –æ—Ä–¥–µ—Ä–æ–≤ (–∫–∞–∂–¥—ã–µ 30 —Å–µ–∫—É–Ω–¥)
        if cycle_count % 3 == 0:
          await self.position_manager.track_pending_orders()
        # –ü–µ—Ä–∏–æ–¥–∏—á–µ—Å–∫–∏–π –º–æ–Ω–∏—Ç–æ—Ä–∏–Ω–≥ PSAR –∏–Ω–¥–∏–∫–∞—Ç–æ—Ä–æ–≤ (–∫–∞–∂–¥—ã–µ 30 —Å–µ–∫—É–Ω–¥)
        if cycle_count % 3 == 0:
          await self.position_manager.monitor_sar_indicators()


        # –†–∞–∑–±–∏–≤–∞–µ–º —Å–∏–º–≤–æ–ª—ã –Ω–∞ –±–∞—Ç—á–∏ –¥–ª—è –ø–∞—Ä–∞–ª–ª–µ–ª—å–Ω–æ–π –æ–±—Ä–∞–±–æ—Ç–∫–∏
        for i in range(0, len(self.active_symbols), batch_size):
          if not self.is_running:
            break

          batch = self.active_symbols[i:i + batch_size]

          # –ü–∞—Ä–∞–ª–ª–µ–ª—å–Ω–∞—è –æ–±—Ä–∞–±–æ—Ç–∫–∞ –±–∞—Ç—á–∞ —Å–∏–º–≤–æ–ª–æ–≤
          tasks = []

          # 1. –ü—Ä–æ–≤–µ—Ä—è–µ–º –æ–∂–∏–¥–∞—é—â–∏–µ —Å–∏–≥–Ω–∞–ª—ã
          for symbol in batch:
            if symbol in self.state_manager.get_pending_signals():
              tasks.append(self._check_pending_signal_for_entry(symbol))

          # 2. –ú–æ–Ω–∏—Ç–æ—Ä–∏–º –æ—Ç–∫—Ä—ã—Ç—ã–µ –ø–æ–∑–∏—Ü–∏–∏
          for symbol in batch:
            if symbol in self.position_manager.open_positions:
              tasks.append(self.position_manager.monitor_single_position(symbol))

          # 3. –ò—â–µ–º –Ω–æ–≤—ã–µ —Å–∏–≥–Ω–∞–ª—ã –¥–ª—è —Å–∏–º–≤–æ–ª–æ–≤ –±–µ–∑ –ø–æ–∑–∏—Ü–∏–π
          for symbol in batch:
            if (symbol not in self.position_manager.open_positions and
                symbol not in self.state_manager.get_pending_signals()):
              # –ò—Å–ø–æ–ª—å–∑—É–µ–º enhanced –≤–µ—Ä—Å–∏—é –µ—Å–ª–∏ –º–æ–¥–µ–ª–∏ –∑–∞–≥—Ä—É–∂–µ–Ω—ã
              if self.enhanced_ml_model and self.anomaly_detector:
                tasks.append(self._monitor_symbol_for_entry_enhanced(symbol))
              # else:
              #   tasks.append(self._monitor_symbol_for_entry(symbol))


          # –í—ã–ø–æ–ª–Ω—è–µ–º –≤—Å–µ –∑–∞–¥–∞—á–∏ –±–∞—Ç—á–∞ –ø–∞—Ä–∞–ª–ª–µ–ª—å–Ω–æ
          if tasks:
            results = await asyncio.gather(*tasks, return_exceptions=True)

            # –õ–æ–≥–∏—Ä—É–µ–º –æ—à–∏–±–∫–∏, –µ—Å–ª–∏ –µ—Å—Ç—å
            for result in results:
              if isinstance(result, Exception):
                logger.error(f"–û—à–∏–±–∫–∞ –≤ –º–æ–Ω–∏—Ç–æ—Ä–∏–Ω–≥–µ: {result}")

        # # –£–ø—Ä–∞–≤–ª—è–µ–º –æ—Ç–∫—Ä—ã—Ç—ã–º–∏ –ø–æ–∑–∏—Ü–∏—è–º–∏
        await self.position_manager.manage_open_positions(self.account_balance)
        # –°–≤–µ—Ä—è–µ–º –∑–∞–∫—Ä—ã—Ç—ã–µ —Å–¥–µ–ª–∫–∏
        await self.position_manager.reconcile_filled_orders()
        # –û–±–Ω–æ–≤–ª—è–µ–º —Å–æ—Å—Ç–æ—è–Ω–∏–µ –¥–ª—è –¥–∞—à–±–æ—Ä–¥–∞
        self.state_manager.update_open_positions(self.position_manager.open_positions)

        if self.sar_strategy:
          asyncio.create_task(self.cleanup_sar_cache_task())
          try:
            sar_status = self.sar_strategy.get_strategy_status()
            self.state_manager.set_custom_data('sar_strategy_status', sar_status)
          except Exception as e:
            logger.error(f"–û—à–∏–±–∫–∞ –æ–±–Ω–æ–≤–ª–µ–Ω–∏—è —Å—Ç–∞—Ç—É—Å–∞ SAR: {e}")

        if self.sar_strategy:
          asyncio.create_task(self.update_sar_symbols_task())

        if hasattr(self, 'update_signal_outcomes'):
          await self.update_signal_outcomes()

        # –í—ã–≤–æ–¥–∏–º —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫—É –ø—Ä–æ–∏–∑–≤–æ–¥–∏—Ç–µ–ª—å–Ω–æ—Å—Ç–∏ –∫–∞–∂–¥—ã–µ 10 —Ü–∏–∫–ª–æ–≤
        if hasattr(self, '_monitoring_cycles'):
          self._monitoring_cycles += 1
        else:
          self._monitoring_cycles = 1

        if self._monitoring_cycles % 10 == 0:
          await self._log_performance_stats()

        if self._monitoring_cycles % 20 == 0:
          await self.display_ml_statistics()

          # ======================= –ò–°–ü–†–ê–í–õ–ï–ù–ò–ï –ó–î–ï–°–¨ =======================
          # –≠—Ç–æ—Ç –±–ª–æ–∫ –±—ã–ª –¥–æ–±–∞–≤–ª–µ–Ω, —á—Ç–æ–±—ã –ø—Ä–∞–≤–∏–ª—å–Ω–æ –æ–±—Ä–∞–±–∞—Ç—ã–≤–∞—Ç—å –∫–æ–º–∞–Ω–¥—ã
        command_data = self.state_manager.get_command()
        if command_data:
          command_name = command_data.get('name')
          logger.info(f"–ü–æ–ª—É—á–µ–Ω–∞ –Ω–æ–≤–∞—è –∫–æ–º–∞–Ω–¥–∞ –∏–∑ –¥–∞—à–±–æ—Ä–¥–∞: {command_name}")

          if command_name == 'generate_report':
            if self.retraining_manager:
              self.retraining_manager.export_performance_report()

          elif command_name == 'update_strategies':
            # –û–±–Ω–æ–≤–ª—è–µ–º –∞–∫—Ç–∏–≤–Ω—ã–µ —Å—Ç—Ä–∞—Ç–µ–≥–∏–∏
            active_strategies = self.state_manager.get_custom_data('active_strategies')
            if active_strategies and hasattr(self, 'adaptive_selector'):
              for strategy_name, is_active in active_strategies.items():
                self.adaptive_selector.active_strategies[strategy_name] = is_active
              logger.info(f"–°—Ç—Ä–∞—Ç–µ–≥–∏–∏ –æ–±–Ω–æ–≤–ª–µ–Ω—ã: {active_strategies}")

          elif command_name == 'retrain_model':
            # –ó–∞–ø—É—Å–∫–∞–µ–º –ø–µ—Ä–µ–æ–±—É—á–µ–Ω–∏–µ
            if self.retraining_manager:
              asyncio.create_task(self.retraining_manager.retrain_model(
                self.active_symbols, timeframe=Timeframe.ONE_HOUR
              ))
              logger.info("–ó–∞–ø—É—â–µ–Ω–æ –ø–µ—Ä–µ–æ–±—É—á–µ–Ω–∏–µ –º–æ–¥–µ–ª–∏")

          elif command_name == 'update_ml_models':
            # –û–±–Ω–æ–≤–ª—è–µ–º —Å–æ—Å—Ç–æ—è–Ω–∏–µ ML –º–æ–¥–µ–ª–µ–π
            ml_state = self.state_manager.get_custom_data('ml_models_state')
            if ml_state:
              self.use_enhanced_ml = ml_state.get('use_enhanced_ml', True)
              self.use_base_ml = ml_state.get('use_base_ml', True)
              logger.info(f"ML –º–æ–¥–µ–ª–∏ –æ–±–Ω–æ–≤–ª–µ–Ω—ã: enhanced={self.use_enhanced_ml}, base={self.use_base_ml}")

          elif command_name == 'export_regime_statistics':
            await self.export_regime_statistics()

          elif command_name == 'get_regime_statistics':
            symbol = command_data.get('data', {}).get('symbol')
            if symbol:
              stats = self.market_regime_detector.get_regime_statistics(symbol)
              self.state_manager.set_custom_data(f"regime_stats_{symbol}", stats)

          # –û–±—Ä–∞–±–æ—Ç–∫–∞ –∫–æ–º–∞–Ω–¥—ã —ç–∫—Å–ø–æ—Ä—Ç–∞ –æ—Ç—á–µ—Ç–∞ SAR
          elif command_name == 'export_sar_report':
            if hasattr(self, 'sar_strategy') and self.sar_strategy:
              report_path = self.sar_strategy.export_performance_report()
              if report_path:
                logger.info(f"–û—Ç—á–µ—Ç SAR —Å—Ç—Ä–∞—Ç–µ–≥–∏–∏ —Å–æ—Ö—Ä–∞–Ω–µ–Ω: {report_path}")

          elif command_name == 'reload_sar_config':
            logger.info("üîÑ –ü–µ—Ä–µ–∑–∞–≥—Ä—É–∑–∫–∞ –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏–∏ SAR —Å—Ç—Ä–∞—Ç–µ–≥–∏–∏...")
            try:
              if self.sar_strategy:
                # –ü–µ—Ä–µ–∑–∞–≥—Ä—É–∂–∞–µ–º –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏—é
                new_config = self.config_manager.load_config()
                new_sar_config = new_config.get('stop_and_reverse_strategy', {})

                # –û–±–Ω–æ–≤–ª—è–µ–º –ø–∞—Ä–∞–º–µ—Ç—Ä—ã —Å—Ç—Ä–∞—Ç–µ–≥–∏–∏
                for key, value in new_sar_config.items():
                  if hasattr(self.sar_strategy, key):
                    setattr(self.sar_strategy, key, value)

                # –û–±–Ω–æ–≤–ª—è–µ–º —Å—Ç–∞—Ç—É—Å –≤ state_manager
                sar_status = self.sar_strategy.get_strategy_status()
                self.state_manager.set_custom_data('sar_strategy_status', sar_status)

                logger.info("‚úÖ –ö–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏—è SAR —Å—Ç—Ä–∞—Ç–µ–≥–∏–∏ –ø–µ—Ä–µ–∑–∞–≥—Ä—É–∂–µ–Ω–∞")
              else:
                logger.warning("SAR —Å—Ç—Ä–∞—Ç–µ–≥–∏—è –Ω–µ –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä–æ–≤–∞–Ω–∞")
            except Exception as e:
              logger.error(f"–û—à–∏–±–∫–∞ –ø–µ—Ä–µ–∑–∞–≥—Ä—É–∑–∫–∏ SAR –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏–∏: {e}")

          # –û—á–∏—â–∞–µ–º –∫–æ–º–∞–Ω–¥—É –ø–æ—Å–ª–µ –≤—ã–ø–æ–ª–Ω–µ–Ω–∏—è
          self.state_manager.clear_command()

          if hasattr(self, 'adaptive_selector') and self.adaptive_selector:
            try:
              performance_summary = self.adaptive_selector.get_performance_summary()

              # –ò–∑–≤–ª–µ–∫–∞–µ–º —Ç–æ–ª—å–∫–æ –≤–µ—Å–∞ –¥–ª—è —É–¥–æ–±—Å—Ç–≤–∞
              weights = {}
              for strategy_name, perf in performance_summary.items():
                weights[strategy_name] = perf.get('weight', 1.0)

              self.state_manager.set_custom_data('adaptive_weights', weights)
              self.state_manager.set_custom_data('strategy_performance_summary', performance_summary)
              logger.debug(f"–ê–¥–∞–ø—Ç–∏–≤–Ω—ã–µ –≤–µ—Å–∞ –æ–±–Ω–æ–≤–ª–µ–Ω—ã: {len(weights)} —Å—Ç—Ä–∞—Ç–µ–≥–∏–π")
            except Exception as e:
              logger.error(f"–û—à–∏–±–∫–∞ –æ–±–Ω–æ–≤–ª–µ–Ω–∏—è –∞–¥–∞–ø—Ç–∏–≤–Ω—ã—Ö –≤–µ—Å–æ–≤: {e}")

          # –û–±–Ω–æ–≤–ª—è–µ–º –º–µ—Ç—Ä–∏–∫–∏ SAR —Å—Ç—Ä–∞—Ç–µ–≥–∏–∏ –¥–ª—è –¥–∞—à–±–æ—Ä–¥–∞
          if hasattr(self, 'sar_strategy') and self.sar_strategy:
            try:
              sar_metrics = self.sar_strategy.get_dashboard_metrics()
              self.state_manager.set_custom_data('sar_strategy_performance', sar_metrics)
              logger.debug(f"SAR –º–µ—Ç—Ä–∏–∫–∏ –æ–±–Ω–æ–≤–ª–µ–Ω—ã –¥–ª—è –¥–∞—à–±–æ—Ä–¥–∞: {len(sar_metrics)} –ø–∞—Ä–∞–º–µ—Ç—Ä–æ–≤")
            except Exception as e:
              logger.error(f"–û—à–∏–±–∫–∞ –æ–±–Ω–æ–≤–ª–µ–Ω–∏—è SAR –º–µ—Ç—Ä–∏–∫: {e}")

          interval = self.config.get('general_settings', {}).get('monitoring_interval_seconds', 30)
          await asyncio.sleep(interval)

        # –û–∂–∏–¥–∞–Ω–∏–µ –ø–µ—Ä–µ–¥ —Å–ª–µ–¥—É—é—â–∏–º —Ü–∏–∫–ª–æ–º
        await asyncio.sleep(monitoring_interval)

      except asyncio.CancelledError:
        logger.info("–ú–æ–Ω–∏—Ç–æ—Ä–∏–Ω–≥ –æ—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω –ø–æ –∑–∞–ø—Ä–æ—Å—É")
        break
      except Exception as e:
        logger.error(f"–û—à–∏–±–∫–∞ –≤ –æ–ø—Ç–∏–º–∏–∑–∏—Ä–æ–≤–∞–Ω–Ω–æ–º —Ü–∏–∫–ª–µ –º–æ–Ω–∏—Ç–æ—Ä–∏–Ω–≥–∞: {e}", exc_info=True)
        await asyncio.sleep(monitoring_interval)

  async def _fast_position_monitoring_loop(self):
    """
    –ë—ã—Å—Ç—Ä—ã–π —Ü–∏–∫–ª –¥–ª—è —á–∞—Å—Ç–æ–≥–æ –º–æ–Ω–∏—Ç–æ—Ä–∏–Ω–≥–∞ –æ—Ç–∫—Ä—ã—Ç—ã—Ö –ø–æ–∑–∏—Ü–∏–π.
    –ü—Ä–æ–≤–µ—Ä—è–µ—Ç –∫—Ä–∏—Ç–∏—á–µ—Å–∫–∏–µ —É—Å–ª–æ–≤–∏—è –≤—ã—Ö–æ–¥–∞ –∫–∞–∂–¥—ã–µ 5-10 —Å–µ–∫—É–Ω–¥.
    """
    # –ñ–¥–µ–º –Ω–µ–º–Ω–æ–≥–æ –ø–µ—Ä–µ–¥ –Ω–∞—á–∞–ª–æ–º, —á—Ç–æ–±—ã –æ—Å–Ω–æ–≤–Ω–æ–π —Ü–∏–∫–ª —É—Å–ø–µ–ª –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä–æ–≤–∞—Ç—å—Å—è
    await asyncio.sleep(5)

    while self.is_running:
      try:
        if self.position_manager.open_positions:
          logger.debug(f"–ë—ã—Å—Ç—Ä–∞—è –ø—Ä–æ–≤–µ—Ä–∫–∞ {len(self.position_manager.open_positions)} –ø–æ–∑–∏—Ü–∏–π...")

          # –ü–æ–ª—É—á–∞–µ–º —Ç–µ–∫—É—â–∏–π –±–∞–ª–∞–Ω—Å –¥–ª—è —Ä–∏—Å–∫-–º–µ–Ω–µ–¥–∂–º–µ–Ω—Ç–∞
          account_balance = self.account_balance

          # –°–æ–∑–¥–∞–µ–º –∑–∞–¥–∞—á–∏ –¥–ª—è –ø–∞—Ä–∞–ª–ª–µ–ª—å–Ω–æ–π –ø—Ä–æ–≤–µ—Ä–∫–∏ –∫–∞–∂–¥–æ–π –ø–æ–∑–∏—Ü–∏–∏
          tasks = []
          for symbol in list(self.position_manager.open_positions.keys()):
            task = self._check_critical_exit_conditions(symbol, account_balance)
            tasks.append(task)

          # –í—ã–ø–æ–ª–Ω—è–µ–º –≤—Å–µ –ø—Ä–æ–≤–µ—Ä–∫–∏ –ø–∞—Ä–∞–ª–ª–µ–ª—å–Ω–æ
          if tasks:
            await asyncio.gather(*tasks, return_exceptions=True)

        # –ñ–¥–µ–º –ø–µ—Ä–µ–¥ —Å–ª–µ–¥—É—é—â–µ–π –ø—Ä–æ–≤–µ—Ä–∫–æ–π
        await asyncio.sleep(5)  # –ü—Ä–æ–≤–µ—Ä–∫–∞ –∫–∞–∂–¥—ã–µ 5 —Å–µ–∫—É–Ω–¥

      except asyncio.CancelledError:
        logger.info("–ë—ã—Å—Ç—Ä—ã–π —Ü–∏–∫–ª –º–æ–Ω–∏—Ç–æ—Ä–∏–Ω–≥–∞ –æ—Ç–º–µ–Ω–µ–Ω")
        break
      except Exception as e:
        logger.error(f"–û—à–∏–±–∫–∞ –≤ –±—ã—Å—Ç—Ä–æ–º —Ü–∏–∫–ª–µ –º–æ–Ω–∏—Ç–æ—Ä–∏–Ω–≥–∞: {e}", exc_info=True)
        await asyncio.sleep(10)

  async def _check_critical_exit_conditions(self, symbol: str, account_balance: Optional[RiskMetrics]):
    """
    –ü—Ä–æ–≤–µ—Ä—è–µ—Ç –∫—Ä–∏—Ç–∏—á–µ—Å–∫–∏–µ —É—Å–ª–æ–≤–∏—è –¥–ª—è –Ω–µ–º–µ–¥–ª–µ–Ω–Ω–æ–≥–æ –≤—ã—Ö–æ–¥–∞ –∏–∑ –ø–æ–∑–∏—Ü–∏–∏.
    –í—ã–∑—ã–≤–∞–µ—Ç—Å—è –∏–∑ –±—ã—Å—Ç—Ä–æ–≥–æ —Ü–∏–∫–ª–∞ –º–æ–Ω–∏—Ç–æ—Ä–∏–Ω–≥–∞.
    """
    try:
      position_data = self.position_manager.open_positions.get(symbol)
      if not position_data:
        return

      # –ü–æ–ª—É—á–∞–µ–º —Ç–µ–∫—É—â—É—é —Ü–µ–Ω—É
      ticker = await self.connector.fetch_ticker(symbol)
      if not ticker:
        return

      current_price = ticker.get('last', 0)
      if current_price <= 0:
        return

      # 1. –ë–´–°–¢–†–ê–Ø –ø—Ä–æ–≤–µ—Ä–∫–∞ SAR —Ä–∞–∑–≤–æ—Ä–æ—Ç–∞ (–ø—Ä–∏–æ—Ä–∏—Ç–µ—Ç)
      if self.sar_strategy and position_data.get('strategy_name') == 'Stop_and_Reverse':
        # –î–ª—è SAR –ø–æ–∑–∏—Ü–∏–π –ø—Ä–æ–≤–µ—Ä—è–µ–º —Ä–∞–∑–≤–æ—Ä–æ—Ç —Ç—Ä–µ–Ω–¥–∞ –≤ –ø–µ—Ä–≤—É—é –æ—á–µ—Ä–µ–¥—å
        quick_data = await self.data_fetcher.get_historical_candles(symbol, Timeframe.FIVE_MINUTES, limit=50)
        if not quick_data.empty:
          sar_signal = await self.sar_strategy.check_exit_conditions(
            symbol, quick_data, position_data
          )

          if sar_signal and sar_signal.is_reversal and sar_signal.confidence >= 0.6:
            logger.info(f"üö® –ë—ã—Å—Ç—Ä—ã–π –º–æ–Ω–∏—Ç–æ—Ä–∏–Ω–≥: –æ–±–Ω–∞—Ä—É–∂–µ–Ω SAR —Ä–∞–∑–≤–æ—Ä–æ—Ç –¥–ª—è {symbol}")
            # –ó–∞–ø—É—Å–∫–∞–µ–º –ø–æ–ª–Ω—É—é –ø—Ä–æ–≤–µ—Ä–∫—É —á–µ—Ä–µ–∑ manage_open_positions
            await self.position_manager.manage_open_positions(account_balance)
            return

      # 2. –ü—Ä–æ–≤–µ—Ä–∫–∞ –∂–µ—Å—Ç–∫–æ–≥–æ SL/TP
      exit_reason = self.position_manager._check_sl_tp(position_data, current_price)

      # 3. –ü—Ä–æ–≤–µ—Ä–∫–∞ –∫—Ä–∏—Ç–∏—á–µ—Å–∫–æ–π –ø—Ä–æ—Å–∞–¥–∫–∏ (–µ—Å–ª–∏ —Ü–µ–Ω–∞ —É–ø–∞–ª–∞ –±–æ–ª–µ–µ —á–µ–º –Ω–∞ X%)
      if not exit_reason:
        open_price = float(position_data.get('open_price', 0))
        if open_price > 0:
          side = position_data.get('side')
          price_change_pct = ((current_price - open_price) / open_price) * 100

          # –ö—Ä–∏—Ç–∏—á–µ—Å–∫–∞—è –ø—Ä–æ—Å–∞–¥–∫–∞ - 5% (–º–æ–∂–Ω–æ –Ω–∞—Å—Ç—Ä–æ–∏—Ç—å)
          critical_loss_pct = 5.0

          if (side == 'BUY' and price_change_pct < -critical_loss_pct) or \
              (side == 'SELL' and price_change_pct > critical_loss_pct):
            exit_reason = f"–ö—Ä–∏—Ç–∏—á–µ—Å–∫–∞—è –ø—Ä–æ—Å–∞–¥–∫–∞: {abs(price_change_pct):.2f}%"

      # –ï—Å–ª–∏ –Ω–∞–π–¥–µ–Ω–∞ –ø—Ä–∏—á–∏–Ω–∞ –¥–ª—è –≤—ã—Ö–æ–¥–∞ - –∑–∞–∫—Ä—ã–≤–∞–µ–º –ø–æ–∑–∏—Ü–∏—é
      if exit_reason:
        logger.warning(f"‚ö†Ô∏è –°–†–û–ß–ù–´–ô –í–´–•–û–î –¥–ª—è {symbol}: {exit_reason}")
        await self.trade_executor.close_position(symbol=symbol)

    except Exception as e:
      logger.error(f"–û—à–∏–±–∫–∞ –ø—Ä–∏ –ø—Ä–æ–≤–µ—Ä–∫–µ –∫—Ä–∏—Ç–∏—á–µ—Å–∫–∏—Ö —É—Å–ª–æ–≤–∏–π –¥–ª—è {symbol}: {e}")

  async def _fast_pending_signals_loop(self):
    """
    –ù–û–í–´–ô –ú–ï–¢–û–î: –ë—ã—Å—Ç—Ä—ã–π —Ü–∏–∫–ª –ø—Ä–æ–≤–µ—Ä–∫–∏ pending signals –∫–∞–∂–¥—ã–µ 10 —Å–µ–∫—É–Ω–¥
    """
    logger.info("–ó–∞–ø—É—Å–∫ –±—ã—Å—Ç—Ä–æ–≥–æ —Ü–∏–∫–ª–∞ –ø—Ä–æ–≤–µ—Ä–∫–∏ pending signals...")

    while self.is_running:
      try:
        pending_signals = self.state_manager.get_pending_signals()

        if pending_signals:
          logger.debug(f"–ë—ã—Å—Ç—Ä–∞—è –ø—Ä–æ–≤–µ—Ä–∫–∞ {len(pending_signals)} –æ–∂–∏–¥–∞—é—â–∏—Ö —Å–∏–≥–Ω–∞–ª–æ–≤...")

          # –ü—Ä–æ–≤–µ—Ä—è–µ–º –≤—Å–µ pending signals –ø–∞—Ä–∞–ª–ª–µ–ª—å–Ω–æ
          tasks = []
          for symbol in list(pending_signals.keys()):
            tasks.append(self._check_pending_signal_for_entry(symbol))

          if tasks:
            results = await asyncio.gather(*tasks, return_exceptions=True)

            # –õ–æ–≥–∏—Ä—É–µ–º –æ—à–∏–±–∫–∏
            for i, result in enumerate(results):
              if isinstance(result, Exception):
                logger.error(f"–û—à–∏–±–∫–∞ –±—ã—Å—Ç—Ä–æ–π –ø—Ä–æ–≤–µ—Ä–∫–∏: {result}")

        # –ñ–¥–µ–º 10 —Å–µ–∫—É–Ω–¥ –ø–µ—Ä–µ–¥ —Å–ª–µ–¥—É—é—â–µ–π –ø—Ä–æ–≤–µ—Ä–∫–æ–π
        await asyncio.sleep(10)

      except asyncio.CancelledError:
        logger.info("–ë—ã—Å—Ç—Ä—ã–π —Ü–∏–∫–ª –ø—Ä–æ–≤–µ—Ä–∫–∏ pending signals –æ—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω")
        break
      except Exception as e:
        logger.error(f"–û—à–∏–±–∫–∞ –≤ –±—ã—Å—Ç—Ä–æ–º —Ü–∏–∫–ª–µ –ø—Ä–æ–≤–µ—Ä–∫–∏: {e}")
        await asyncio.sleep(10)

  async def _check_pending_signal_for_entry(self, symbol: str):
    """
    –£–õ–£–ß–®–ï–ù–ù–ê–Ø –í–ï–†–°–ò–Ø: –ü—Ä–æ–≤–µ—Ä—è–µ—Ç –æ–∂–∏–¥–∞—é—â–∏–π —Å–∏–≥–Ω–∞–ª –Ω–∞ –æ–ø—Ç–∏–º–∞–ª—å–Ω—É—é —Ç–æ—á–∫—É –≤—Ö–æ–¥–∞
    —Å –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ–º –∞–Ω–∞–ª–∏–∑–∞ —É—Ä–æ–≤–Ω–µ–π –∏ –ø–∞—Ç—Ç–µ—Ä–Ω–æ–≤
    """
    pending_signals = self.state_manager.get_pending_signals()

    if symbol not in pending_signals:
      return

    try:
      signal_data = pending_signals[symbol]

      # –ü—Ä–æ–≤–µ—Ä—è–µ–º —Ç–∞–π–º–∞—É—Ç —Å–∏–≥–Ω–∞–ª–∞ (—É–≤–µ–ª–∏—á–∏–≤–∞–µ–º –¥–æ 4 —á–∞—Å–æ–≤ –¥–ª—è –æ–∂–∏–¥–∞–Ω–∏—è –ª—É—á—à–µ–≥–æ –≤—Ö–æ–¥–∞)
      # signal_time = datetime.fromisoformat(signal_data['metadata']['signal_time'])
      # signal_age = datetime.now(timezone.utc) - signal_time
      signal_time_str = signal_data['metadata']['signal_time']
      # –°–Ω–∞—á–∞–ª–∞ –ø–∞—Ä—Å–∏–º —Å—Ç—Ä–æ–∫—É –≤ "–Ω–∞–∏–≤–Ω–æ–µ" –≤—Ä–µ–º—è
      signal_time_naive = datetime.fromisoformat(signal_time_str)
      # –ó–∞—Ç–µ–º —è–≤–Ω–æ —É–∫–∞–∑—ã–≤–∞–µ–º, —á—Ç–æ —ç—Ç–æ –≤—Ä–µ–º—è –≤ UTC
      signal_time = signal_time_naive.replace(tzinfo=timezone.utc)

      signal_age = datetime.now(timezone.utc) - signal_time


      if signal_age > timedelta(hours=2):
        logger.info(f"–°–∏–≥–Ω–∞–ª –¥–ª—è {symbol} —É—Å—Ç–∞—Ä–µ–ª ({signal_age}), —É–¥–∞–ª—è–µ–º –∏–∑ –æ—á–µ—Ä–µ–¥–∏")
        del pending_signals[symbol]
        self.state_manager.update_pending_signals(pending_signals)
        return

      # –ü–æ–ª—É—á–∞–µ–º –Ω–∞—Å—Ç—Ä–æ–π–∫–∏ LTF
      strategy_settings = self.config.get('strategy_settings', {})
      ltf_str = strategy_settings.get('ltf_entry_timeframe', '5m')

      timeframe_map = {
        "1m": Timeframe.ONE_MINUTE,
        "5m": Timeframe.FIVE_MINUTES,
        "15m": Timeframe.FIFTEEN_MINUTES
      }
      ltf_timeframe = timeframe_map.get(ltf_str, Timeframe.FIVE_MINUTES)

      # –ü–æ–ª—É—á–∞–µ–º –¥–∞–Ω–Ω—ã–µ LTF —Å –±–æ–ª—å—à–µ–π –∏—Å—Ç–æ—Ä–∏–µ–π –¥–ª—è –∞–Ω–∞–ª–∏–∑–∞ —É—Ä–æ–≤–Ω–µ–π
      logger.debug(f"–ü—Ä–æ–≤–µ—Ä–∫–∞ –æ–ø—Ç–∏–º–∞–ª—å–Ω–æ–≥–æ –≤—Ö–æ–¥–∞ –¥–ª—è {symbol} –Ω–∞ {ltf_str}...")
      ltf_data = await self.data_fetcher.get_historical_candles(symbol, ltf_timeframe, limit=200)

      if ltf_data.empty or len(ltf_data) < 50:
        logger.debug(f"–ù–µ–¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ –¥–∞–Ω–Ω—ã—Ö LTF –¥–ª—è {symbol}")
        return

      # –í–æ—Å—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º —Ç–∏–ø —Å–∏–≥–Ω–∞–ª–∞
      signal_type = SignalType[signal_data['signal_type']]

      # === –ê–ù–ê–õ–ò–ó –¢–ï–ö–£–©–ï–ô –†–´–ù–û–ß–ù–û–ô –°–ò–¢–£–ê–¶–ò–ò ===
      current_price = ltf_data['close'].iloc[-1]

      # –ü—Ä–æ–≤–µ—Ä—è–µ–º, –Ω–µ —É—à–ª–∞ –ª–∏ —Ü–µ–Ω–∞ —Å–ª–∏—à–∫–æ–º –¥–∞–ª–µ–∫–æ –æ—Ç –ø–µ—Ä–≤–æ–Ω–∞—á–∞–ª—å–Ω–æ–≥–æ —Å–∏–≥–Ω–∞–ª–∞
      original_price = signal_data['price']
      price_deviation = abs(current_price - original_price) / original_price

      # –ï—Å–ª–∏ —Ü–µ–Ω–∞ —É—à–ª–∞ –±–æ–ª–µ–µ —á–µ–º –Ω–∞ 1,5% - –ø–µ—Ä–µ—Å–º–∞—Ç—Ä–∏–≤–∞–µ–º —Ü–µ–ª–µ—Å–æ–æ–±—Ä–∞–∑–Ω–æ—Å—Ç—å –≤—Ö–æ–¥–∞
      if price_deviation > 0.015:
        logger.warning(f"–¶–µ–Ω–∞ {symbol} —Å–∏–ª—å–Ω–æ –æ—Ç–∫–ª–æ–Ω–∏–ª–∞—Å—å –æ—Ç —Å–∏–≥–Ω–∞–ª–∞ ({price_deviation:.1%})")

        # –î–ª—è BUY: –µ—Å–ª–∏ —Ü–µ–Ω–∞ –≤—ã—Ä–æ—Å–ª–∞ —Å–∏–ª—å–Ω–æ - –æ—Ç–º–µ–Ω—è–µ–º
        if signal_type == SignalType.BUY and current_price > original_price * 1.02:
          logger.info(f"–û—Ç–º–µ–Ω—è–µ–º BUY —Å–∏–≥–Ω–∞–ª –¥–ª—è {symbol} - —Ü–µ–Ω–∞ —É—à–ª–∞ –≤–≤–µ—Ä—Ö")
          del pending_signals[symbol]
          self.state_manager.update_pending_signals(pending_signals)
          return

        # –î–ª—è SELL: –µ—Å–ª–∏ —Ü–µ–Ω–∞ —É–ø–∞–ª–∞ —Å–∏–ª—å–Ω–æ - –æ—Ç–º–µ–Ω—è–µ–º
        if signal_type == SignalType.SELL and current_price < original_price * 0.98:
          logger.info(f"–û—Ç–º–µ–Ω—è–µ–º SELL —Å–∏–≥–Ω–∞–ª –¥–ª—è {symbol} - —Ü–µ–Ω–∞ —É—à–ª–∞ –≤–Ω–∏–∑")
          del pending_signals[symbol]
          self.state_manager.update_pending_signals(pending_signals)
          return

      # === –ü–†–û–í–ï–†–ö–ê –û–ü–¢–ò–ú–ê–õ–¨–ù–û–°–¢–ò –¢–ï–ö–£–©–ï–ì–û –ú–û–ú–ï–ù–¢–ê ===

      # 1. –ê–Ω–∞–ª–∏–∑–∏—Ä—É–µ–º –Ω–µ–¥–∞–≤–Ω–µ–µ –¥–≤–∏–∂–µ–Ω–∏–µ —Ü–µ–Ω—ã
      recent_movement = self._analyze_recent_price_movement(ltf_data)

      # 2. –ü—Ä–æ–≤–µ—Ä—è–µ–º —É—Å–ª–æ–≤–∏—è –≤—Ö–æ–¥–∞ —Å —É—á–µ—Ç–æ–º –≤–æ–∑—Ä–∞—Å—Ç–∞ —Å–∏–≥–Ω–∞–ª–∞
      age_minutes = signal_age.total_seconds() / 60

      # –ü–æ—Å—Ç–µ–ø–µ–Ω–Ω–æ —Å–º—è–≥—á–∞–µ–º —Ç—Ä–µ–±–æ–≤–∞–Ω–∏—è —Å–æ –≤—Ä–µ–º–µ–Ω–µ–º
      if age_minutes < 30:
        # –ü–µ—Ä–≤—ã–µ 30 –º–∏–Ω—É—Ç - –∂–¥–µ–º –∏–¥–µ–∞–ª—å–Ω—ã—Ö —É—Å–ª–æ–≤–∏–π
        trigger_result = self._check_ltf_entry_trigger(ltf_data, signal_type)
      elif age_minutes < 60:
        # 30-60 –º–∏–Ω—É—Ç - –Ω–µ–º–Ω–æ–≥–æ —Å–º—è–≥—á–∞–µ–º —Ç—Ä–µ–±–æ–≤–∞–Ω–∏—è
        trigger_result = self._check_ltf_entry_trigger_relaxed(ltf_data, signal_type, level=1)
      elif age_minutes < 120:
        # 1-2 —á–∞—Å–∞ - –µ—â–µ –±–æ–ª—å—à–µ —Å–º—è–≥—á–∞–µ–º
        trigger_result = self._check_ltf_entry_trigger_relaxed(ltf_data, signal_type, level=2)
      else:
        # 2-4 —á–∞—Å–∞ - –º–∏–Ω–∏–º–∞–ª—å–Ω—ã–µ —Ç—Ä–µ–±–æ–≤–∞–Ω–∏—è
        trigger_result = self._check_ltf_entry_trigger_relaxed(ltf_data, signal_type, level=3)

      if trigger_result:
        logger.info(f"‚úÖ –û–ü–¢–ò–ú–ê–õ–¨–ù–´–ô –≤—Ö–æ–¥ –¥–ª—è {symbol} –Ω–∞–π–¥–µ–Ω –ø–æ—Å–ª–µ {age_minutes:.0f} –º–∏–Ω—É—Ç –æ–∂–∏–¥–∞–Ω–∏—è!")
        logger.info(f"  - –¢–∏–ø –≤—Ö–æ–¥–∞: {trigger_result}")
        logger.info(f"  - –î–≤–∏–∂–µ–Ω–∏–µ –æ—Ç —Å–∏–≥–Ω–∞–ª–∞: {price_deviation:.1%}")

        # –ö–æ—Ä—Ä–µ–∫—Ç–∏—Ä—É–µ–º —Ä–∞–∑–º–µ—Ä –ø–æ–∑–∏—Ü–∏–∏ –≤ –∑–∞–≤–∏—Å–∏–º–æ—Å—Ç–∏ –æ—Ç –∫–∞—á–µ—Å—Ç–≤–∞ –≤—Ö–æ–¥–∞
        size_multiplier = 1.0
        if age_minutes > 120:  # –°—Ç–∞—Ä—ã–π —Å–∏–≥–Ω–∞–ª
          size_multiplier = 0.7
        elif recent_movement == 'strong_adverse':  # –°–∏–ª—å–Ω–æ–µ –Ω–µ–±–ª–∞–≥–æ–ø—Ä–∏—è—Ç–Ω–æ–µ –¥–≤–∏–∂–µ–Ω–∏–µ
          size_multiplier = 0.5

        # –í–æ—Å—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º –ø–æ–ª–Ω—ã–π TradingSignal
        trading_signal = TradingSignal(
          signal_type=signal_type,
          symbol=signal_data['symbol'],
          price=current_price,  # –ò—Å–ø–æ–ª—å–∑—É–µ–º —Ç–µ–∫—É—â—É—é —Ü–µ–Ω—É!
          confidence=signal_data['confidence'],
          strategy_name=signal_data['strategy_name'],
          timestamp=datetime.now(),  # –û–±–Ω–æ–≤–ª—è–µ–º –≤—Ä–µ–º—è
          stop_loss=signal_data.get('stop_loss'),
          take_profit=signal_data.get('take_profit'),
          metadata={
            **signal_data.get('metadata', {}),
            'original_price': original_price,
            'entry_delay_minutes': age_minutes,
            'entry_type': trigger_result,
            'size_multiplier': size_multiplier
          }
        )

        # –ò—Å–ø–æ–ª–Ω—è–µ–º —Å–¥–µ–ª–∫—É —Å —Å–∫–æ—Ä—Ä–µ–∫—Ç–∏—Ä–æ–≤–∞–Ω–Ω—ã–º —Ä–∞–∑–º–µ—Ä–æ–º
        approved_size = signal_data['metadata']['approved_size']
        final_size = approved_size * size_multiplier

        success, order_details = await self.trade_executor.execute_trade(
          trading_signal, symbol, final_size
        )

        if success:
          logger.info(f"‚úÖ –°–¥–µ–ª–∫–∞ –ø–æ {symbol} —É—Å–ø–µ—à–Ω–æ –∏—Å–ø–æ–ª–Ω–µ–Ω–∞ —á–µ—Ä–µ–∑ –æ–ø—Ç–∏–º–∞–ª—å–Ω—ã–π LTF –≤—Ö–æ–¥")
          if order_details:
            self.position_manager.add_position_to_cache(order_details)

          # –£–¥–∞–ª—è–µ–º –∏–∑ –æ—á–µ—Ä–µ–¥–∏
          del pending_signals[symbol]
          self.state_manager.update_pending_signals(pending_signals)

          # –°–∏–Ω—Ö—Ä–æ–Ω–∏–∑–∏—Ä—É–µ–º —Å Shadow Trading
          if self.shadow_trading and order_details:
            asyncio.create_task(
              self.shadow_trading.signal_tracker.sync_with_real_trades(
                symbol,
                {
                  'open_price': order_details.get('open_price'),
                  'close_price': order_details.get('open_price'),
                  'profit_loss': 0,
                  'profit_pct': 0
                }
              )
            )
        else:
          logger.error(f"–ù–µ —É–¥–∞–ª–æ—Å—å –∏—Å–ø–æ–ª–Ω–∏—Ç—å —Å–¥–µ–ª–∫—É –¥–ª—è {symbol}")
      else:
        # –õ–æ–≥–∏—Ä—É–µ–º –ø—Ä–∏—á–∏–Ω—É, –ø–æ—á–µ–º—É –Ω–µ –≤—Ö–æ–¥–∏–º
        if age_minutes < 30:
          logger.debug(f"–ñ–¥–µ–º –∏–¥–µ–∞–ª—å–Ω—ã—Ö —É—Å–ª–æ–≤–∏–π –¥–ª—è {symbol} (–≤–æ–∑—Ä–∞—Å—Ç: {age_minutes:.0f}–º)")
        else:
          logger.debug(f"–ü–æ–∫–∞ –Ω–µ—Ç –ø–æ–¥—Ö–æ–¥—è—â–∏—Ö —É—Å–ª–æ–≤–∏–π –¥–ª—è {symbol} (–≤–æ–∑—Ä–∞—Å—Ç: {age_minutes:.0f}–º)")

    except Exception as e:
      logger.error(f"–û—à–∏–±–∫–∞ –ø—Ä–æ–≤–µ—Ä–∫–∏ pending —Å–∏–≥–Ω–∞–ª–∞ –¥–ª—è {symbol}: {e}", exc_info=True)

  def _analyze_recent_price_movement(self, df: pd.DataFrame) -> str:
      """
      –ê–Ω–∞–ª–∏–∑–∏—Ä—É–µ—Ç –Ω–µ–¥–∞–≤–Ω–µ–µ –¥–≤–∏–∂–µ–Ω–∏–µ —Ü–µ–Ω—ã –¥–ª—è –æ—Ü–µ–Ω–∫–∏ —Ä—ã–Ω–æ—á–Ω—ã—Ö —É—Å–ª–æ–≤–∏–π
      """
      if len(df) < 10:
        return 'unknown'

      # –ê–Ω–∞–ª–∏–∑–∏—Ä—É–µ–º –ø–æ—Å–ª–µ–¥–Ω–∏–µ 10 —Å–≤–µ—á–µ–π
      recent = df.tail(10)

      # –†–∞—Å—á–µ—Ç –æ–±—â–µ–≥–æ –¥–≤–∏–∂–µ–Ω–∏—è
      total_move = (recent['close'].iloc[-1] - recent['close'].iloc[0]) / recent['close'].iloc[0]

      # –†–∞—Å—á–µ—Ç –≤–æ–ª–∞—Ç–∏–ª—å–Ω–æ—Å—Ç–∏
      avg_candle_range = ((recent['high'] - recent['low']) / recent['close']).mean()

      # –û–ø—Ä–µ–¥–µ–ª—è–µ–º —Ç–∏–ø –¥–≤–∏–∂–µ–Ω–∏—è
      if abs(total_move) > 0.02:  # –ë–æ–ª–µ–µ 2% –¥–≤–∏–∂–µ–Ω–∏—è
        if total_move > 0:
          return 'strong_up' if avg_candle_range < 0.005 else 'volatile_up'
        else:
          return 'strong_down' if avg_candle_range < 0.005 else 'volatile_down'
      else:
        return 'sideways' if avg_candle_range < 0.003 else 'choppy'

  def _check_ltf_entry_trigger_relaxed(self, data: pd.DataFrame, signal_type: SignalType, level: int = 1) -> str:
    """
    –ü—Ä–æ–≤–µ—Ä—è–µ—Ç —Ç—Ä–∏–≥–≥–µ—Ä —Å –ø–æ—Å—Ç–µ–ø–µ–Ω–Ω–æ —Å–º—è–≥—á–∞—é—â–∏–º–∏—Å—è —Ç—Ä–µ–±–æ–≤–∞–Ω–∏—è–º–∏
    Level 1: –ù–µ–º–Ω–æ–≥–æ —Å–º—è–≥—á–µ–Ω–Ω—ã–µ —É—Å–ª–æ–≤–∏—è (30-60 –º–∏–Ω—É—Ç)
    Level 2: –£–º–µ—Ä–µ–Ω–Ω–æ —Å–º—è–≥—á–µ–Ω–Ω—ã–µ —É—Å–ª–æ–≤–∏—è (1-2 —á–∞—Å–∞)
    Level 3: –ú–∏–Ω–∏–º–∞–ª—å–Ω—ã–µ —Ç—Ä–µ–±–æ–≤–∞–Ω–∏—è (2+ —á–∞—Å–∞)
    """
    if data.empty or len(data) < 30:
      return None

    try:
      df = data.copy()

      # –û—á–∏—Å—Ç–∫–∞ –¥–∞–Ω–Ω—ã—Ö
      required_cols = ['open', 'high', 'low', 'close', 'volume']
      for col in required_cols:
        if col in df.columns:
          df[col] = pd.to_numeric(df[col], errors='coerce')
      df.dropna(subset=required_cols, inplace=True)

      if len(df) < 30:
        return None

      # –†–∞—Å—á–µ—Ç –∏–Ω–¥–∏–∫–∞—Ç–æ—Ä–æ–≤
      df['rsi'] = ta.rsi(df['close'], length=14)
      df['volume_sma'] = df['volume'].rolling(20).mean()
      current_price = df['close'].iloc[-1]

      # –ê–Ω–∞–ª–∏–∑ –∏–º–ø—É–ª—å—Å–∞
      price_change_5 = (df['close'].iloc[-1] - df['close'].iloc[-6]) / df['close'].iloc[-6]
      volume_ratio = df['volume'].iloc[-1] / df['volume_sma'].iloc[-1]

      if signal_type == SignalType.BUY:
        # Level 1: –°–º—è–≥—á–µ–Ω–Ω—ã–µ —É—Å–ª–æ–≤–∏—è
        if level == 1:
          if (df['rsi'].iloc[-1] < 50 and  # RSI –Ω–µ –ø–µ—Ä–µ–∫—É–ø–ª–µ–Ω
              price_change_5 > -0.005 and  # –ù–µ—Ç —Å–∏–ª—å–Ω–æ–≥–æ –ø–∞–¥–µ–Ω–∏—è
              volume_ratio > 0.8):  # –ü—Ä–∏–µ–º–ª–µ–º—ã–π –æ–±—ä–µ–º
            return 'relaxed_buy_1'

        # Level 2: –ï—â–µ –±–æ–ª–µ–µ –º—è–≥–∫–∏–µ —É—Å–ª–æ–≤–∏—è
        elif level == 2:
          if (df['rsi'].iloc[-1] < 60 and  # RSI —É–º–µ—Ä–µ–Ω–Ω—ã–π
              price_change_5 > -0.01):  # –ù–µ—Ç —Ä–µ–∑–∫–æ–≥–æ –ø–∞–¥–µ–Ω–∏—è
            return 'relaxed_buy_2'

        # Level 3: –ú–∏–Ω–∏–º–∞–ª—å–Ω—ã–µ —É—Å–ª–æ–≤–∏—è
        else:
          if df['rsi'].iloc[-1] < 70:  # –¢–æ–ª—å–∫–æ –Ω–µ —Å–∏–ª—å–Ω–æ –ø–µ—Ä–µ–∫—É–ø–ª–µ–Ω
            return 'emergency_buy'

      else:  # SELL
        # Level 1: –°–º—è–≥—á–µ–Ω–Ω—ã–µ —É—Å–ª–æ–≤–∏—è
        if level == 1:
          if (df['rsi'].iloc[-1] > 50 and  # RSI –Ω–µ –ø–µ—Ä–µ–ø—Ä–æ–¥–∞–Ω
              price_change_5 < 0.005 and  # –ù–µ—Ç —Å–∏–ª—å–Ω–æ–≥–æ —Ä–æ—Å—Ç–∞
              volume_ratio > 0.8):  # –ü—Ä–∏–µ–º–ª–µ–º—ã–π –æ–±—ä–µ–º
            return 'relaxed_sell_1'

        # Level 2: –ï—â–µ –±–æ–ª–µ–µ –º—è–≥–∫–∏–µ —É—Å–ª–æ–≤–∏—è
        elif level == 2:
          if (df['rsi'].iloc[-1] > 40 and  # RSI —É–º–µ—Ä–µ–Ω–Ω—ã–π
              price_change_5 < 0.01):  # –ù–µ—Ç —Ä–µ–∑–∫–æ–≥–æ —Ä–æ—Å—Ç–∞
            return 'relaxed_sell_2'

        # Level 3: –ú–∏–Ω–∏–º–∞–ª—å–Ω—ã–µ —É—Å–ª–æ–≤–∏—è
        else:
          if df['rsi'].iloc[-1] > 30:  # –¢–æ–ª—å–∫–æ –Ω–µ —Å–∏–ª—å–Ω–æ –ø–µ—Ä–µ–ø—Ä–æ–¥–∞–Ω
            return 'emergency_sell'

      return None

    except Exception as e:
      logger.error(f"–û—à–∏–±–∫–∞ –≤ relaxed —Ç—Ä–∏–≥–≥–µ—Ä–µ: {e}")
      return None

  async def _log_performance_stats(self):
    """
    –í—ã–≤–æ–¥–∏—Ç —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫—É –ø—Ä–æ–∏–∑–≤–æ–¥–∏—Ç–µ–ª—å–Ω–æ—Å—Ç–∏ —Å–∏—Å—Ç–µ–º—ã
    """
    # –°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞ –∫—ç—à–∞ DataFetcher
    cache_stats = self.data_fetcher.get_cache_stats()
    logger.info(f"üìä –°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞ –∫—ç—à–∞ DataFetcher: Hit rate: {cache_stats['hit_rate']:.2%}, "
                f"Hits: {cache_stats['cache_hits']}, Misses: {cache_stats['cache_misses']}")

    # –°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞ –∑–∞–ø—Ä–æ—Å–æ–≤ Bybit
    if hasattr(self.connector, 'request_stats'):
      total_requests = sum(self.connector.request_stats.values())
      logger.info(f"üìä –í—Å–µ–≥–æ API –∑–∞–ø—Ä–æ—Å–æ–≤: {total_requests}")

      # –¢–æ–ø-5 endpoint'–æ–≤ –ø–æ –∫–æ–ª–∏—á–µ—Å—Ç–≤—É –∑–∞–ø—Ä–æ—Å–æ–≤
      top_endpoints = sorted(
        self.connector.request_stats.items(),
        key=lambda x: x[1],
        reverse=True
      )[:5]

      if top_endpoints:
        logger.info("üìä –¢–æ–ø-5 API endpoints:")
        for endpoint, count in top_endpoints:
          logger.info(f"  - {endpoint}: {count} –∑–∞–ø—Ä–æ—Å–æ–≤")

  async def cleanup_caches(self):
    """
    –ü–µ—Ä–∏–æ–¥–∏—á–µ—Å–∫–∞—è –æ—á–∏—Å—Ç–∫–∞ –∫—ç—à–µ–π –¥–ª—è –æ—Å–≤–æ–±–æ–∂–¥–µ–Ω–∏—è –ø–∞–º—è—Ç–∏
    """
    while self.is_running:
      try:
        await asyncio.sleep(3600)  # –ö–∞–∂–¥—ã–π —á–∞—Å

        logger.info("–ó–∞–ø—É—Å–∫ –æ—á–∏—Å—Ç–∫–∏ –∫—ç—à–µ–π...")

        # –û—á–∏—â–∞–µ–º —É—Å—Ç–∞—Ä–µ–≤—à–∏–µ –¥–∞–Ω–Ω—ã–µ –≤ DataFetcher
        self.data_fetcher._clean_expired_cache()

        # –û—á–∏—â–∞–µ–º –∫—ç—à –±–∞–∑—ã –¥–∞–Ω–Ω—ã—Ö –¥–ª—è —Å—Ç–∞—Ä—ã—Ö –¥–∞–Ω–Ω—ã—Ö
        self.db_manager.clear_cache()

        # –°–æ–±–∏—Ä–∞–µ–º –º—É—Å–æ—Ä
        import gc
        gc.collect()

        logger.info("–û—á–∏—Å—Ç–∫–∞ –∫—ç—à–µ–π –∑–∞–≤–µ—Ä—à–µ–Ω–∞")

      except asyncio.CancelledError:
        break
      except Exception as e:
        logger.error(f"–û—à–∏–±–∫–∞ –ø—Ä–∏ –æ—á–∏—Å—Ç–∫–µ –∫—ç—à–µ–π: {e}")

  async def _periodic_retraining(self):
      """–ü–µ—Ä–∏–æ–¥–∏—á–µ—Å–∫–æ–µ –ø–µ—Ä–µ–æ–±—É—á–µ–Ω–∏–µ –º–æ–¥–µ–ª–µ–π"""
      while self.is_running:
        try:
          # –ñ–¥–µ–º 24 —á–∞—Å–∞ –ø–µ—Ä–µ–¥ –ø–µ—Ä–µ–æ–±—É—á–µ–Ω–∏–µ–º
          await asyncio.sleep(86400)

          logger.info("–ó–∞–ø—É—Å–∫ –ø–µ—Ä–∏–æ–¥–∏—á–µ—Å–∫–æ–≥–æ –ø–µ—Ä–µ–æ–±—É—á–µ–Ω–∏—è –º–æ–¥–µ–ª–µ–π...")

          # –ó–∞–ø—É—Å–∫–∞–µ–º –ø–µ—Ä–µ–æ–±—É—á–µ–Ω–∏–µ –≤ —Ñ–æ–Ω–µ
          if self.retraining_manager:
            if hasattr(feature_engineer, 'reset_scaler'):
              feature_engineer.reset_scaler()
              logger.info("–°–±—Ä–æ—à–µ–Ω feature_engineer –ø–µ—Ä–µ–¥ –ø–µ—Ä–∏–æ–¥–∏—á–µ—Å–∫–∏–º –ø–µ—Ä–µ–æ–±—É—á–µ–Ω–∏–µ–º")
            asyncio.create_task(
              self.retraining_manager.check_and_retrain_if_needed(
                self.active_symbols[:10]  # –¢–æ–ø 10 —Å–∏–º–≤–æ–ª–æ–≤
              )
            )

        except asyncio.CancelledError:
          break
        except Exception as e:
          logger.error(f"–û—à–∏–±–∫–∞ –ø—Ä–∏ –ø–µ—Ä–∏–æ–¥–∏—á–µ—Å–∫–æ–º –ø–µ—Ä–µ–æ–±—É—á–µ–Ω–∏–∏: {e}")

  async def _periodic_time_sync(self):
    """–ü–µ—Ä–∏–æ–¥–∏—á–µ—Å–∫–∞—è —Å–∏–Ω—Ö—Ä–æ–Ω–∏–∑–∞—Ü–∏—è –≤—Ä–µ–º–µ–Ω–∏"""
    while self.is_running:
      try:
        await asyncio.sleep(3600)  # –ö–∞–∂–¥—ã–π —á–∞—Å

        logger.info("–ù–∞—á–∞–ª–æ –ø–µ—Ä–∏–æ–¥–∏—á–µ—Å–∫–æ–π —Å–∏–Ω—Ö—Ä–æ–Ω–∏–∑–∞—Ü–∏–∏ –≤—Ä–µ–º–µ–Ω–∏...")
        await self.connector.sync_time()
        logger.info("‚úÖ –°–∏–Ω—Ö—Ä–æ–Ω–∏–∑–∞—Ü–∏—è –≤—Ä–µ–º–µ–Ω–∏ –∑–∞–≤–µ—Ä—à–µ–Ω–∞ —É—Å–ø–µ—à–Ω–æ")

      except asyncio.CancelledError:
        logger.info("–ü–µ—Ä–∏–æ–¥–∏—á–µ—Å–∫–∞—è —Å–∏–Ω—Ö—Ä–æ–Ω–∏–∑–∞—Ü–∏—è –≤—Ä–µ–º–µ–Ω–∏ –æ—Ç–º–µ–Ω–µ–Ω–∞")
        break
      except Exception as e:
        logger.error(f"–û—à–∏–±–∫–∞ –ø—Ä–∏ —Å–∏–Ω—Ö—Ä–æ–Ω–∏–∑–∞—Ü–∏–∏ –≤—Ä–µ–º–µ–Ω–∏: {e}")
        # –ü—Ä–æ–¥–æ–ª–∂–∞–µ–º —Ä–∞–±–æ—Ç—É –¥–∞–∂–µ –ø—Ä–∏ –æ—à–∏–±–∫–µ
        await asyncio.sleep(60)  # –ü–æ–¥–æ–∂–¥–µ–º –º–∏–Ω—É—Ç—É –ø–µ—Ä–µ–¥ —Å–ª–µ–¥—É—é—â–µ–π –ø–æ–ø—ã—Ç–∫–æ–π

  async def start_optimized(self):
    """
    –û–ø—Ç–∏–º–∏–∑–∏—Ä–æ–≤–∞–Ω–Ω—ã–π –∑–∞–ø—É—Å–∫ —Å–∏—Å—Ç–µ–º—ã
    """
    try:
      # –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è —Å –æ–ø—Ç–∏–º–∏–∑–∞—Ü–∏–µ–π
      await self.initialize_with_optimization()

      if not self.active_symbols:
        logger.error("–ù–µ—Ç –∞–∫—Ç–∏–≤–Ω—ã—Ö —Å–∏–º–≤–æ–ª–æ–≤ –¥–ª—è —Ç–æ—Ä–≥–æ–≤–ª–∏")
        return

      # –°–∏–Ω—Ö—Ä–æ–Ω–∏–∑–∞—Ü–∏—è –≤—Ä–µ–º–µ–Ω–∏
      await self.connector.sync_time()

      # –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è –ë–î
      await self.db_manager._create_tables_if_not_exist()

      # –ü—Ä–æ–≤–µ—Ä—è–µ–º –ë–î –ø–µ—Ä–µ–¥ –∑–∞–ø—É—Å–∫–æ–º
      health = await self.db_monitor.check_database_health()
      if health['status'] != 'healthy':
        logger.warning(f"–ë–î –Ω–µ –≤ –æ–ø—Ç–∏–º–∞–ª—å–Ω–æ–º —Å–æ—Å—Ç–æ—è–Ω–∏–∏ –ø—Ä–∏ –∑–∞–ø—É—Å–∫–µ: {health}")
      else:
        logger.info("‚úÖ –ë–î –ø—Ä–æ–≤–µ—Ä–µ–Ω–∞, —Å–æ—Å—Ç–æ—è–Ω–∏–µ –Ω–æ—Ä–º–∞–ª—å–Ω–æ–µ")


      leverage = self.config.get('trade_settings', {}).get('leverage', 10)
      logger.info(f"–£—Å—Ç–∞–Ω–æ–≤–∫–∞ –ø–ª–µ—á–∞ {leverage} –¥–ª—è {len(self.active_symbols)} —Å–∏–º–≤–æ–ª–æ–≤...")

      await self._set_leverage_for_all_symbols(leverage)

      if not await self._ensure_model_exists():
        logger.critical("–ù–µ —É–¥–∞–ª–æ—Å—å —Å–æ–∑–¥–∞—Ç—å –ø–µ—Ä–≤–∏—á–Ω—É—é ML –º–æ–¥–µ–ª—å. –ó–∞–ø—É—Å–∫ –æ—Ç–º–µ–Ω–µ–Ω.")
        return

      # –ó–∞–≥—Ä—É–∑–∫–∞ –æ—Ç–∫—Ä—ã—Ç—ã—Ö –ø–æ–∑–∏—Ü–∏–π
      await self.position_manager.load_open_positions()

      logger.info("–ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è —Ä–µ–∂–∏–º–æ–≤ —Ä—ã–Ω–∫–∞...")
      initial_regimes = {}
      for symbol in self.active_symbols[:20]:  # –¢–æ–ø 20 —Å–∏–º–≤–æ–ª–æ–≤
        try:
          regime = await self.get_market_regime(symbol)
          if regime:
            initial_regimes[symbol] = {
              'regime': regime.primary_regime.value,
              'confidence': regime.confidence,
              'trend_strength': regime.trend_strength,
              'volatility': regime.volatility_level,
              'duration': 'Just started'
            }
        except Exception as e:
          logger.debug(f"–ù–µ —É–¥–∞–ª–æ—Å—å –æ–ø—Ä–µ–¥–µ–ª–∏—Ç—å —Ä–µ–∂–∏–º –¥–ª—è {symbol}: {e}")

      if initial_regimes:
        self.state_manager.set_custom_data('market_regimes', initial_regimes)
        logger.info(f"‚úÖ –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä–æ–≤–∞–Ω—ã —Ä–µ–∂–∏–º—ã –¥–ª—è {len(initial_regimes)} —Å–∏–º–≤–æ–ª–æ–≤")

      # –ó–∞–ø—É—Å–∫ —Ñ–æ–Ω–æ–≤—ã—Ö –∑–∞–¥–∞—á
      self.is_running = True

      # –û–±–Ω–æ–≤–ª—è–µ–º —Å—Ç–∞—Ç—É—Å
      self.state_manager.set_status('running')

      logger.info("–ó–∞–ø—É—Å–∫–∞–µ–º —Ñ–æ–Ω–æ–≤—ã–µ –∑–∞–¥–∞—á–∏...")

      # 1. –û—Å–Ω–æ–≤–Ω–æ–π –æ–ø—Ç–∏–º–∏–∑–∏—Ä–æ–≤–∞–Ω–Ω—ã–π –º–æ–Ω–∏—Ç–æ—Ä–∏–Ω–≥
      self._monitoring_task = asyncio.create_task(self._monitoring_loop_optimized())
      logger.info("‚úÖ –ó–∞–ø—É—â–µ–Ω –æ—Å–Ω–æ–≤–Ω–æ–π —Ü–∏–∫–ª –º–æ–Ω–∏—Ç–æ—Ä–∏–Ω–≥–∞")

      # 2. –ë—ã—Å—Ç—Ä—ã–π –º–æ–Ω–∏—Ç–æ—Ä–∏–Ω–≥ –ø–æ–∑–∏—Ü–∏–π
      self._fast_monitoring_task = asyncio.create_task(self._fast_position_monitoring_loop())
      logger.info("‚úÖ –ó–∞–ø—É—â–µ–Ω –±—ã—Å—Ç—Ä—ã–π —Ü–∏–∫–ª –º–æ–Ω–∏—Ç–æ—Ä–∏–Ω–≥–∞ –ø–æ–∑–∏—Ü–∏–π")

      # 3. –ü–µ—Ä–∏–æ–¥–∏—á–µ—Å–∫–æ–µ –ø–µ—Ä–µ–æ–±—É—á–µ–Ω–∏–µ –º–æ–¥–µ–ª–µ–π
      self._retraining_task = asyncio.create_task(self._periodic_retraining())
      logger.info("‚úÖ –ó–∞–ø—É—â–µ–Ω–æ –ø–µ—Ä–∏–æ–¥–∏—á–µ—Å–∫–æ–µ –ø–µ—Ä–µ–æ–±—É—á–µ–Ω–∏–µ")

      # 4. –ü–µ—Ä–∏–æ–¥–∏—á–µ—Å–∫–∞—è —Å–∏–Ω—Ö—Ä–æ–Ω–∏–∑–∞—Ü–∏—è –≤—Ä–µ–º–µ–Ω–∏
      self._time_sync_task = asyncio.create_task(self._periodic_time_sync())
      self._time_sync_loop_task = asyncio.create_task(self._time_sync_loop())
      logger.info("‚úÖ –ó–∞–ø—É—â–µ–Ω–∞ —Å–∏–Ω—Ö—Ä–æ–Ω–∏–∑–∞—Ü–∏—è –≤—Ä–µ–º–µ–Ω–∏")

      # 5. –ü–µ—Ä–∏–æ–¥–∏—á–µ—Å–∫–∞—è –æ—á–∏—Å—Ç–∫–∞ –∫—ç—à–µ–π
      self._cache_cleanup_task = asyncio.create_task(self.cleanup_caches())
      logger.info("‚úÖ –ó–∞–ø—É—â–µ–Ω–∞ –æ—á–∏—Å—Ç–∫–∞ –∫—ç—à–µ–π")

      # 6. –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ –∫–æ—Ä—Ä–µ–ª—è—Ü–∏–π –ø–æ—Ä—Ç—Ñ–µ–ª—è
      self._correlation_task = asyncio.create_task(self._update_portfolio_correlations())
      logger.info("‚úÖ –ó–∞–ø—É—â–µ–Ω–æ –æ–±–Ω–æ–≤–ª–µ–Ω–∏–µ –∫–æ—Ä—Ä–µ–ª—è—Ü–∏–π")

      # 7. –ü–µ—Ä–∏–æ–¥–∏—á–µ—Å–∫–∞—è –æ—Ü–µ–Ω–∫–∞ —Å—Ç—Ä–∞—Ç–µ–≥–∏–π
      self._evaluation_task = asyncio.create_task(self.periodic_strategy_evaluation())
      logger.info("‚úÖ –ó–∞–ø—É—â–µ–Ω–∞ –æ—Ü–µ–Ω–∫–∞ —Å—Ç—Ä–∞—Ç–µ–≥–∏–π")

      # 8. –ü–µ—Ä–∏–æ–¥–∏—á–µ—Å–∫–∏–π –∞–Ω–∞–ª–∏–∑ —Ä–µ–∂–∏–º–æ–≤ —Ä—ã–Ω–∫–∞
      self._regime_analysis_task = asyncio.create_task(self.periodic_regime_analysis())
      logger.info("‚úÖ –ó–∞–ø—É—â–µ–Ω –ø–µ—Ä–∏–æ–¥–∏—á–µ—Å–∫–∏–π –∞–Ω–∞–ª–∏–∑ —Ä–µ–∂–∏–º–æ–≤ —Ä—ã–Ω–∫–∞")

      # 9. –ù–û–í–ê–Ø –ó–ê–î–ê–ß–ê: –ë—ã—Å—Ç—Ä–∞—è –ø—Ä–æ–≤–µ—Ä–∫–∞ pending signals
      self._fast_pending_check_task = asyncio.create_task(self._fast_pending_signals_loop())
      logger.info("‚úÖ –ó–∞–ø—É—â–µ–Ω–∞ –±—ã—Å—Ç—Ä–∞—è –ø—Ä–æ–≤–µ—Ä–∫–∞ pending signals")

      # 10. –ó–∞–ø—É—Å–∫ —Ä–µ–≤–∞–ª–∏–¥–∞—Ü–∏–∏ –∫–∞–∂–¥—ã–µ 5 –º–∏–Ω—É—Ç
      self._revalidation_task = asyncio.create_task(self._revalidation_loop())

      logger.info("üöÄ –í—Å–µ —Ñ–æ–Ω–æ–≤—ã–µ –∑–∞–¥–∞—á–∏ —É—Å–ø–µ—à–Ω–æ –∑–∞–ø—É—â–µ–Ω—ã")


      # –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ —Å—Ç–∞—Ç—É—Å–∞
      self.state_manager.set_status('running', os.getpid())

      # –î–æ–±–∞–≤–∏—Ç—å –∑–∞–¥–∞—á—É –ø—Ä–æ–≤–µ—Ä–∫–∏ ROI
      self._roi_check_task = asyncio.create_task(self.periodic_roi_check())

      monitoring_task = asyncio.create_task(self._database_monitoring_loop())
      self._monitoring_tasks.append(monitoring_task)

      logger.info("üöÄ –°–∏—Å—Ç–µ–º–∞ –∑–∞–ø—É—â–µ–Ω–∞ —Å –º–æ–Ω–∏—Ç–æ—Ä–∏–Ω–≥–æ–º –ë–î")

      try:
        from analytics.roi_analytics import ROIAnalytics
        roi_analytics = ROIAnalytics(self.db_manager)

        logger.info("=== –ê–ù–ê–õ–ò–¢–ò–ö–ê ROI –ù–ê–°–¢–†–û–ï–ö ===")

        # –ê–Ω–∞–ª–∏–∑ –∑–∞ –ø–æ—Å–ª–µ–¥–Ω–∏–µ 7 –¥–Ω–µ–π
        weekly_analysis = await roi_analytics.analyze_roi_performance(days=7)
        if 'error' not in weekly_analysis:
          logger.info(f"üìä –°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞ –∑–∞ 7 –¥–Ω–µ–π:")
          logger.info(f"  –°–¥–µ–ª–æ–∫: {weekly_analysis['total_trades']}")
          logger.info(f"  –í–∏–Ω—Ä–µ–π—Ç: {weekly_analysis['win_rate']:.1f}%")
          logger.info(f"  –û–±—â–∏–π PnL: {weekly_analysis['total_pnl']:.2f}")
          logger.info(f"  SL —Å—Ä–∞–±–∞—Ç—ã–≤–∞–Ω–∏–π: {weekly_analysis['sl_hit_rate']:.1f}%")
          logger.info(f"  TP –¥–æ—Å—Ç–∏–∂–µ–Ω–∏–π: {weekly_analysis['tp_hit_rate']:.1f}%")
          logger.info(f"  üí° {weekly_analysis['recommendation']}")

      except Exception as analytics_error:
        logger.warning(f"–ù–µ —É–¥–∞–ª–æ—Å—å –∑–∞–≥—Ä—É–∑–∏—Ç—å ROI –∞–Ω–∞–ª–∏—Ç–∏–∫—É: {analytics_error}")

      logger.info("‚úÖ –¢–æ—Ä–≥–æ–≤–∞—è —Å–∏—Å—Ç–µ–º–∞ —É—Å–ø–µ—à–Ω–æ –∑–∞–ø—É—â–µ–Ω–∞ –≤ –æ–ø—Ç–∏–º–∏–∑–∏—Ä–æ–≤–∞–Ω–Ω–æ–º —Ä–µ–∂–∏–º–µ")

    except Exception as e:
      logger.critical(f"–ö—Ä–∏—Ç–∏—á–µ—Å–∫–∞—è –æ—à–∏–±–∫–∞ –ø—Ä–∏ –∑–∞–ø—É—Å–∫–µ —Å–∏—Å—Ç–µ–º—ã: {e}", exc_info=True)
      self.is_running = False
      raise

  async def _revalidation_loop(self):
    """–¶–∏–∫–ª –ø–µ—Ä–∏–æ–¥–∏—á–µ—Å–∫–æ–π —Ä–µ–≤–∞–ª–∏–¥–∞—Ü–∏–∏ pending —Å–∏–≥–Ω–∞–ª–æ–≤"""
    logger.info("–ó–∞–ø—É—Å–∫ —Ü–∏–∫–ª–∞ –ø–µ—Ä–∏–æ–¥–∏—á–µ—Å–∫–æ–π —Ä–µ–≤–∞–ª–∏–¥–∞—Ü–∏–∏...")

    while self.is_running:
      try:
        await asyncio.sleep(300)  # 5 –º–∏–Ω—É—Ç
        await self._revalidate_pending_signals()
      except Exception as e:
        logger.error(f"–û—à–∏–±–∫–∞ –≤ —Ü–∏–∫–ª–µ —Ä–µ–≤–∞–ª–∏–¥–∞—Ü–∏–∏: {e}")

  async def _revalidate_pending_signals(self):
      """
      –ü–µ—Ä–∏–æ–¥–∏—á–µ—Å–∫–∞—è —Ä–µ–≤–∞–ª–∏–¥–∞—Ü–∏—è –≤—Å–µ—Ö pending —Å–∏–≥–Ω–∞–ª–æ–≤
      –í—ã–∑—ã–≤–∞–µ—Ç—Å—è –∫–∞–∂–¥—ã–µ 5 –º–∏–Ω—É—Ç
      """
      try:
        pending_signals = self.state_manager.get_pending_signals()

        if not pending_signals:
          return

        logger.info(f"üîÑ –†–µ–≤–∞–ª–∏–¥–∞—Ü–∏—è {len(pending_signals)} –æ–∂–∏–¥–∞—é—â–∏—Ö —Å–∏–≥–Ω–∞–ª–æ–≤...")

        for symbol, signal_data in list(pending_signals.items()):
          try:
            # –ü—Ä–æ–≤–µ—Ä—è–µ–º –≤–æ–∑—Ä–∞—Å—Ç
            signal_time_str = signal_data['metadata']['signal_time']
            signal_time_naive = datetime.fromisoformat(signal_time_str)
            # –Ø–≤–Ω–æ —É–∫–∞–∑—ã–≤–∞–µ–º, —á—Ç–æ —ç—Ç–æ –≤—Ä–µ–º—è –≤ UTC
            signal_time = signal_time_naive.replace(tzinfo=timezone.utc)

            age_hours = (datetime.now(timezone.utc) - signal_time).total_seconds() / 3600

            # –ï—Å–ª–∏ —Å—Ç–∞—Ä—à–µ 4 —á–∞—Å–æ–≤ - —É–¥–∞–ª—è–µ–º
            if age_hours > 1:
              logger.warning(f"‚ùå –£–¥–∞–ª—è–µ–º —É—Å—Ç–∞—Ä–µ–≤—à–∏–π —Å–∏–≥–Ω–∞–ª {symbol} (–≤–æ–∑—Ä–∞—Å—Ç: {age_hours:.1f}—á)")
              del pending_signals[symbol]
              continue

            # –ü—Ä–æ–≤–µ—Ä—è–µ–º –∞–∫—Ç—É–∞–ª—å–Ω–æ—Å—Ç—å —Ü–µ–Ω—ã
            current_data = await self.data_fetcher.get_historical_candles(
              symbol, Timeframe.FIFTEEN_MINUTES, limit=20
            )

            if current_data.empty:
              continue

            current_price = current_data['close'].iloc[-1]
            original_price = signal_data['price']
            deviation = abs(current_price - original_price) / original_price

            # –û–±–Ω–æ–≤–ª—è–µ–º –º–µ—Ç–∞–¥–∞–Ω–Ω—ã–µ
            signal_data['metadata']['current_price'] = current_price
            signal_data['metadata']['price_deviation'] = deviation
            signal_data['metadata']['last_revalidation'] = datetime.now().isoformat()

            # –ï—Å–ª–∏ –æ—Ç–∫–ª–æ–Ω–µ–Ω–∏–µ —Å–ª–∏—à–∫–æ–º –±–æ–ª—å—à–æ–µ - –ø–æ–º–µ—á–∞–µ–º –¥–ª—è –ø—Ä–∏–æ—Ä–∏—Ç–µ—Ç–Ω–æ–π –ø—Ä–æ–≤–µ—Ä–∫–∏
            if deviation > 0.02:  # 2%
              signal_data['metadata']['needs_urgent_check'] = True
              logger.warning(f"‚ö†Ô∏è {symbol}: –±–æ–ª—å—à–æ–µ –æ—Ç–∫–ª–æ–Ω–µ–Ω–∏–µ —Ü–µ–Ω—ã ({deviation:.1%})")

          except Exception as e:
            logger.error(f"–û—à–∏–±–∫–∞ —Ä–µ–≤–∞–ª–∏–¥–∞—Ü–∏–∏ —Å–∏–≥–Ω–∞–ª–∞ {symbol}: {e}")

        # –°–æ—Ö—Ä–∞–Ω—è–µ–º –æ–±–Ω–æ–≤–ª–µ–Ω–Ω—ã–µ –¥–∞–Ω–Ω—ã–µ
        self.state_manager.update_pending_signals(pending_signals)

      except Exception as e:
        logger.error(f"–û—à–∏–±–∫–∞ –≤ –ø—Ä–æ—Ü–µ—Å—Å–µ —Ä–µ–≤–∞–ª–∏–¥–∞—Ü–∏–∏: {e}")

  async def _check_pending_signals_with_priority(self):
    """
    –ü—Ä–æ–≤–µ—Ä—è–µ—Ç pending —Å–∏–≥–Ω–∞–ª—ã —Å —É—á–µ—Ç–æ–º –ø—Ä–∏–æ—Ä–∏—Ç–µ—Ç–æ–≤
    –í—ã–∑—ã–≤–∞–µ—Ç—Å—è –ø–æ—Å–ª–µ –∑–∞–∫—Ä—ã—Ç–∏—è –ø–æ–∑–∏—Ü–∏–π
    """
    try:
      pending_signals = self.state_manager.get_pending_signals()

      if not pending_signals:
        return

      # –°–æ—Ä—Ç–∏—Ä—É–µ–º –ø–æ –ø—Ä–∏–æ—Ä–∏—Ç–µ—Ç—É
      signal_list = []
      for symbol, sig_data in pending_signals.items():
        sig_age = (datetime.now() - datetime.fromisoformat(sig_data['metadata']['signal_time'])).total_seconds() / 3600
        priority = sig_data['confidence'] * (1 + sig_age * 0.1)

        # –î–æ–±–∞–≤–ª—è–µ–º –±–æ–Ω—É—Å –∑–∞ —Å—Ä–æ—á–Ω–æ—Å—Ç—å
        if sig_data['metadata'].get('needs_urgent_check', False):
          priority *= 1.5

        signal_list.append((symbol, priority, sig_data))

      signal_list.sort(key=lambda x: x[1], reverse=True)

      # –ü—Ä–æ–≤–µ—Ä—è–µ–º —Ç–æ–ø —Å–∏–≥–Ω–∞–ª—ã
      for symbol, priority, sig_data in signal_list[:3]:
        logger.info(f"üéØ –ü—Ä–æ–≤–µ—Ä–∫–∞ –ø—Ä–∏–æ—Ä–∏—Ç–µ—Ç–Ω–æ–≥–æ —Å–∏–≥–Ω–∞–ª–∞ {symbol} (–ø—Ä–∏–æ—Ä–∏—Ç–µ—Ç: {priority:.2f})")

        # –ó–∞–ø—É—Å–∫–∞–µ–º –ø—Ä–æ–≤–µ—Ä–∫—É
        await self._check_pending_signal_for_entry(symbol)

        # –ù–µ–±–æ–ª—å—à–∞—è –ø–∞—É–∑–∞ –º–µ–∂–¥—É –ø—Ä–æ–≤–µ—Ä–∫–∞–º–∏
        await asyncio.sleep(5)

    except Exception as e:
      logger.error(f"–û—à–∏–±–∫–∞ –ø—Ä–æ–≤–µ—Ä–∫–∏ —Å–∏–≥–Ω–∞–ª–æ–≤ —Å –ø—Ä–∏–æ—Ä–∏—Ç–µ—Ç–∞–º–∏: {e}")


  async def _set_leverage_for_all_symbols(self, leverage: int):
    """–£—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ—Ç –ø–ª–µ—á–æ –¥–ª—è –≤—Å–µ—Ö —Å–∏–º–≤–æ–ª–æ–≤ —Å –æ–ø—Ç–∏–º–∏–∑–∞—Ü–∏–µ–π –∏ –ø—Ä–µ–¥–æ—Ç–≤—Ä–∞—â–µ–Ω–∏–µ–º –¥—É–±–ª–∏—Ä–æ–≤–∞–Ω–∏—è"""
    if not self.active_symbols:
      logger.warning("–ù–µ—Ç –∞–∫—Ç–∏–≤–Ω—ã—Ö —Å–∏–º–≤–æ–ª–æ–≤ –¥–ª—è —É—Å—Ç–∞–Ω–æ–≤–∫–∏ –ø–ª–µ—á–∞")
      return

    # –ü—Ä–æ–≤–µ—Ä—è–µ–º, –Ω—É–∂–Ω–æ –ª–∏ —É—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞—Ç—å –ø–ª–µ—á–æ
    already_set = getattr(self, '_leverage_already_set', set())
    symbols_to_set = [s for s in self.active_symbols if s not in already_set]

    if not symbols_to_set:
      logger.info("–ü–ª–µ—á–æ —É–∂–µ —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–æ –¥–ª—è –≤—Å–µ—Ö –∞–∫—Ç–∏–≤–Ω—ã—Ö —Å–∏–º–≤–æ–ª–æ–≤")
      return

    successful_leverages = 0

    # –£—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º –ø–ª–µ—á–æ –±–∞—Ç—á–∞–º–∏ –ø–æ 10 —Å–∏–º–≤–æ–ª–æ–≤
    batch_size = 10
    for i in range(0, len(symbols_to_set), batch_size):
      batch = symbols_to_set[i:i + batch_size]

      # –ü–∞—Ä–∞–ª–ª–µ–ª—å–Ω–∞—è —É—Å—Ç–∞–Ω–æ–≤–∫–∞ –ø–ª–µ—á–∞ –¥–ª—è –±–∞—Ç—á–∞
      tasks = []
      for symbol in batch:
        tasks.append(self._set_single_leverage(symbol, leverage))

      results = await asyncio.gather(*tasks, return_exceptions=True)

      # –ü–æ–¥—Å—á–∏—Ç—ã–≤–∞–µ–º —É—Å–ø–µ—à–Ω—ã–µ —É—Å—Ç–∞–Ω–æ–≤–∫–∏
      for j, result in enumerate(results):
        symbol = batch[j]
        if isinstance(result, Exception):
          logger.warning(f"–û—à–∏–±–∫–∞ —É—Å—Ç–∞–Ω–æ–≤–∫–∏ –ø–ª–µ—á–∞ –¥–ª—è {symbol}: {result}")
        elif result:
          successful_leverages += 1
          already_set.add(symbol)

      # –ó–∞–¥–µ—Ä–∂–∫–∞ –º–µ–∂–¥—É –±–∞—Ç—á–∞–º–∏
      if i + batch_size < len(symbols_to_set):
        await asyncio.sleep(1.0)  # 1 —Å–µ–∫—É–Ω–¥–∞ –º–µ–∂–¥—É –±–∞—Ç—á–∞–º–∏

    # –°–æ—Ö—Ä–∞–Ω—è–µ–º —Å–æ—Å—Ç–æ—è–Ω–∏–µ —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–Ω—ã—Ö –ø–ª–µ—á
    self._leverage_already_set = already_set

    logger.info(f"–ü–ª–µ—á–æ —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–æ –¥–ª—è {successful_leverages}/{len(symbols_to_set)} –Ω–æ–≤—ã—Ö —Å–∏–º–≤–æ–ª–æ–≤")
    logger.info(f"–í—Å–µ–≥–æ —Å–∏–º–≤–æ–ª–æ–≤ —Å —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–Ω—ã–º –ø–ª–µ—á–æ–º: {len(already_set)}")

  async def _set_single_leverage(self, symbol: str, leverage: int) -> bool:
    """–£—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ—Ç –ø–ª–µ—á–æ –¥–ª—è –æ–¥–Ω–æ–≥–æ —Å–∏–º–≤–æ–ª–∞"""
    try:
      result = await self.connector.set_leverage(symbol, leverage, leverage)
      if result:
        logger.debug(f"–ü–ª–µ—á–æ {leverage}x —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–æ –¥–ª—è {symbol}")
        return True
      else:
        logger.warning(f"–ù–µ —É–¥–∞–ª–æ—Å—å —É—Å—Ç–∞–Ω–æ–≤–∏—Ç—å –ø–ª–µ—á–æ –¥–ª—è {symbol}")
        return False
    except Exception as e:
      logger.error(f"–û—à–∏–±–∫–∞ —É—Å—Ç–∞–Ω–æ–≤–∫–∏ –ø–ª–µ—á–∞ –¥–ª—è {symbol}: {e}")
      return False

  async def _database_monitoring_loop(self):
      """–¶–∏–∫–ª –º–æ–Ω–∏—Ç–æ—Ä–∏–Ω–≥–∞ –ë–î"""
      while self.is_running:
        try:
          await asyncio.sleep(300)  # –ü—Ä–æ–≤–µ—Ä–∫–∞ –∫–∞–∂–¥—ã–µ 5 –º–∏–Ω—É—Ç

          health = await self.db_monitor.check_database_health()

          # –õ–æ–≥–∏—Ä—É–µ–º —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫—É
          stats = health.get('stats', {})
          if stats.get('total_operations', 0) > 0:
            error_rate = (stats.get('failed_operations', 0) / stats['total_operations']) * 100
            lock_rate = (stats.get('lock_errors', 0) / stats['total_operations']) * 100

            logger.info(f"üìä –°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞ –ë–î: –æ–ø–µ—Ä–∞—Ü–∏–π={stats['total_operations']}, "
                        f"–æ—à–∏–±–æ–∫={error_rate:.1f}%, –±–ª–æ–∫–∏—Ä–æ–≤–æ–∫={lock_rate:.1f}%")

          # –ê–ª–µ—Ä—Ç—ã –ø—Ä–∏ –ø—Ä–æ–±–ª–µ–º–∞—Ö
          if health['status'] != 'healthy':
            logger.warning(f"‚ö†Ô∏è –ü—Ä–æ–±–ª–µ–º—ã —Å –ë–î: {health['message']}")

          if stats.get('lock_errors', 0) > 50:
            logger.error(f"üö® –ö—Ä–∏—Ç–∏—á–µ—Å–∫–æ–µ –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ –±–ª–æ–∫–∏—Ä–æ–≤–æ–∫ –ë–î: {stats['lock_errors']}")

        except Exception as e:
          logger.error(f"–û—à–∏–±–∫–∞ –≤ —Ü–∏–∫–ª–µ –º–æ–Ω–∏—Ç–æ—Ä–∏–Ω–≥–∞ –ë–î: {e}")
          await asyncio.sleep(60)

  async def get_system_health(self) -> Dict[str, Any]:
    """–ü–æ–ª—É—á–∏—Ç—å –æ–±—â–µ–µ —Å–æ—Å—Ç–æ—è–Ω–∏–µ —Å–∏—Å—Ç–µ–º—ã –≤–∫–ª—é—á–∞—è –ë–î"""
    try:
      db_health = await self.db_monitor.check_database_health()

      return {
        'system_status': 'running' if self.is_running else 'stopped',
        'database': db_health,
        'uptime_seconds': time.time() - self.start_time if hasattr(self, 'start_time') else 0,
        'active_components': {
          'data_fetcher': hasattr(self, 'data_fetcher'),
          'trade_executor': hasattr(self, 'trade_executor'),
          'risk_manager': hasattr(self, 'risk_manager'),
          'shadow_trading': hasattr(self, 'shadow_trading')
        }
      }

    except Exception as e:
      logger.error(f"–û—à–∏–±–∫–∞ –ø–æ–ª—É—á–µ–Ω–∏—è —Å–æ—Å—Ç–æ—è–Ω–∏—è —Å–∏—Å—Ç–µ–º—ã: {e}")
      return {'error': str(e)}

  async def _check_market_anomalies(self, symbol: str, data: pd.DataFrame) -> List[AnomalyReport]:
    """
    –ü—Ä–æ–≤–µ—Ä—è–µ—Ç —Ä—ã–Ω–æ—á–Ω—ã–µ –∞–Ω–æ–º–∞–ª–∏–∏ –¥–ª—è —Å–∏–º–≤–æ–ª–∞
    """
    # –ü—Ä–æ–≤–µ—Ä—è–µ–º, –Ω—É–∂–Ω–æ –ª–∏ –≤—ã–ø–æ–ª–Ω—è—Ç—å –ø—Ä–æ–≤–µ—Ä–∫—É
    current_time = time.time()
    last_check = self._last_anomaly_check.get(symbol, 0)

    if current_time - last_check < self._anomaly_check_interval:
      return []

    self._last_anomaly_check[symbol] = current_time

    if not self.anomaly_detector:
      return []

    try:
      anomalies = self.anomaly_detector.detect_anomalies(data, symbol)

      if anomalies:
        logger.warning(f"üö® –û–±–Ω–∞—Ä—É–∂–µ–Ω—ã –∞–Ω–æ–º–∞–ª–∏–∏ –¥–ª—è {symbol}:")
        for anomaly in anomalies:
          logger.warning(f"  - {anomaly.anomaly_type.value}: {anomaly.description}")
          logger.warning(f"    –°–µ—Ä—å–µ–∑–Ω–æ—Å—Ç—å: {anomaly.severity:.2f}, –†–µ–∫–æ–º–µ–Ω–¥–∞—Ü–∏—è: {anomaly.recommended_action}")

          # –û—Ç–ø—Ä–∞–≤–ª—è–µ–º –∫—Ä–∏—Ç–∏—á–µ—Å–∫–∏–µ –∞–Ω–æ–º–∞–ª–∏–∏ –≤ —Ç–µ–ª–µ–≥—Ä–∞–º (–µ—Å–ª–∏ –ø–æ–¥–∫–ª—é—á–µ–Ω)
          if anomaly.severity > 0.8:
            signal_logger.critical(
              f"üö® –ö–†–ò–¢–ò–ß–ï–°–ö–ê–Ø –ê–ù–û–ú–ê–õ–ò–Ø {symbol}: {anomaly.anomaly_type.value}\n"
              f"{anomaly.description}\n"
              f"–î–µ–π—Å—Ç–≤–∏–µ: {anomaly.recommended_action}"
            )

      return anomalies

    except Exception as e:
      logger.error(f"–û—à–∏–±–∫–∞ –ø—Ä–∏ –ø—Ä–æ–≤–µ—Ä–∫–µ –∞–Ω–æ–º–∞–ª–∏–π –¥–ª—è {symbol}: {e}")
      return []

  async def display_ml_statistics(self):
    """–í—ã–≤–æ–¥–∏—Ç —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫—É ML –º–æ–¥–µ–ª–µ–π"""
    if self.anomaly_detector:
      stats = self.anomaly_detector.get_statistics()
      logger.info(f"üìä –°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞ –¥–µ—Ç–µ–∫—Ç–æ—Ä–∞ –∞–Ω–æ–º–∞–ª–∏–π:")
      logger.info(f"  –ü—Ä–æ–≤–µ—Ä–æ–∫: {stats['total_checks']}")
      logger.info(f"  –û–±–Ω–∞—Ä—É–∂–µ–Ω–æ –∞–Ω–æ–º–∞–ª–∏–π: {stats['anomalies_detected']}")
      logger.info(f"  –ü–æ —Ç–∏–ø–∞–º: {stats['by_type']}")

    if self.enhanced_ml_model and hasattr(self.enhanced_ml_model, 'performance_history'):
      logger.info(f"üìä –°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞ Enhanced ML:")
      logger.info(f"  –û–±—É—á–µ–Ω–∞: {self.enhanced_ml_model.is_fitted}")
      logger.info(
        f"  –ü—Ä–∏–∑–Ω–∞–∫–æ–≤: {len(self.enhanced_ml_model.selected_features) if self.enhanced_ml_model.selected_features else 0}")

  async def _update_portfolio_correlations(self):
      """–ü–µ—Ä–∏–æ–¥–∏—á–µ—Å–∫–æ–µ –æ–±–Ω–æ–≤–ª–µ–Ω–∏–µ –∫–æ—Ä—Ä–µ–ª—è—Ü–∏–π –ø–æ—Ä—Ç—Ñ–µ–ª—è"""
      while self.is_running:
        try:
          # –ñ–¥–µ–º –ø–µ—Ä–µ–¥ –ø–µ—Ä–≤—ã–º –æ–±–Ω–æ–≤–ª–µ–Ω–∏–µ–º
          await asyncio.sleep(300)  # 5 –º–∏–Ω—É—Ç –ø–æ—Å–ª–µ —Å—Ç–∞—Ä—Ç–∞

          while self.is_running:
            logger.info("–û–±–Ω–æ–≤–ª–µ–Ω–∏–µ –∫–æ—Ä—Ä–µ–ª—è—Ü–∏–π –ø–æ—Ä—Ç—Ñ–µ–ª—è...")

            # –ü–æ–ª—É—á–∞–µ–º –≤—Å–µ –∞–∫—Ç–∏–≤–Ω—ã–µ —Å–∏–º–≤–æ–ª—ã (–ø–æ–∑–∏—Ü–∏–∏ + –º–æ–Ω–∏—Ç–æ—Ä–∏–º—ã–µ)
            active_symbols = list(self.position_manager.open_positions.keys())
            monitored_symbols = self.active_symbols[:20]  # –¢–æ–ø 20

            all_symbols = list(set(active_symbols + monitored_symbols))

            if len(all_symbols) >= 2:
              # –ê–Ω–∞–ª–∏–∑–∏—Ä—É–µ–º –∫–æ—Ä—Ä–µ–ª—è—Ü–∏–∏
              correlation_report = await self.correlation_manager.analyze_portfolio_correlation(
                symbols=all_symbols,
                timeframe=Timeframe.ONE_HOUR,
                lookback_days=30
              )

              if correlation_report:
                # –õ–æ–≥–∏—Ä—É–µ–º –≤–∞–∂–Ω—É—é –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é
                risk_metrics = correlation_report.get('risk_metrics')
                if risk_metrics:
                  logger.info(f"üìä –ú–µ—Ç—Ä–∏–∫–∏ —Ä–∏—Å–∫–∞ –ø–æ—Ä—Ç—Ñ–µ–ª—è:")
                  logger.info(f"  –í–æ–ª–∞—Ç–∏–ª—å–Ω–æ—Å—Ç—å –ø–æ—Ä—Ç—Ñ–µ–ª—è: {risk_metrics.portfolio_volatility:.4f}")
                  logger.info(f"  –ö–æ—ç—Ñ—Ñ–∏—Ü–∏–µ–Ω—Ç –¥–∏–≤–µ—Ä—Å–∏—Ñ–∏–∫–∞—Ü–∏–∏: {risk_metrics.diversification_ratio:.2f}")
                  logger.info(f"  –≠—Ñ—Ñ–µ–∫—Ç–∏–≤–Ω–æ–µ –∫–æ–ª-–≤–æ –∞–∫—Ç–∏–≤–æ–≤: {risk_metrics.effective_assets:.1f}")
                  logger.info(f"  –ú–∞–∫—Å. –∫–æ—Ä—Ä–µ–ª—è—Ü–∏—è: {risk_metrics.max_correlation:.2f}")

                # –ü—Ä–æ–≤–µ—Ä—è–µ–º —Ä–µ–∫–æ–º–µ–Ω–¥–∞—Ü–∏–∏
                recommendations = correlation_report.get('recommendations', {})
                warnings = recommendations.get('warnings', [])

                for warning in warnings:
                  logger.warning(f"‚ö†Ô∏è –ö–æ—Ä—Ä–µ–ª—è—Ü–∏—è: {warning}")
                  signal_logger.warning(f"–ö–û–†–†–ï–õ–Ø–¶–ò–Ø: {warning}")

                # –ü—Ä–æ–≤–µ—Ä—è–µ–º –≤—ã—Å–æ–∫–∏–µ –∫–æ—Ä—Ä–µ–ª—è—Ü–∏–∏
                high_correlations = correlation_report.get('high_correlations', [])
                for corr_data in high_correlations[:3]:  # –¢–æ–ø 3
                  logger.warning(
                    f"üîó –í—ã—Å–æ–∫–∞—è –∫–æ—Ä—Ä–µ–ª—è—Ü–∏—è: {corr_data['symbol1']}-{corr_data['symbol2']} "
                    f"= {corr_data['correlation']:.2f}"
                  )

            # –ñ–¥–µ–º –¥–æ —Å–ª–µ–¥—É—é—â–µ–≥–æ –æ–±–Ω–æ–≤–ª–µ–Ω–∏—è
            await asyncio.sleep(self._correlation_update_interval)

        except asyncio.CancelledError:
          break
        except Exception as e:
          logger.error(f"–û—à–∏–±–∫–∞ –ø—Ä–∏ –æ–±–Ω–æ–≤–ª–µ–Ω–∏–∏ –∫–æ—Ä—Ä–µ–ª—è—Ü–∏–π: {e}")
          await asyncio.sleep(300)  # Retry —á–µ—Ä–µ–∑ 5 –º–∏–Ω—É—Ç


  def _generate_quality_recommendation(self, results: Dict[str, Any]) -> str:
    """–ì–µ–Ω–µ—Ä–∏—Ä—É–µ—Ç —Ä–µ–∫–æ–º–µ–Ω–¥–∞—Ü–∏–∏ –Ω–∞ –æ—Å–Ω–æ–≤–µ –∞–Ω–∞–ª–∏–∑–∞ –∫–∞—á–µ—Å—Ç–≤–∞"""
    if not results:
      return "–ù–µ–¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ –¥–∞–Ω–Ω—ã—Ö –¥–ª—è —Ä–µ–∫–æ–º–µ–Ω–¥–∞—Ü–∏–π"

    # –ê–Ω–∞–ª–∏–∑–∏—Ä—É–µ–º win rate –ø–æ –∫–∞—Ç–µ–≥–æ—Ä–∏—è–º
    excellent_wr = results.get('excellent', {}).get('win_rate', 0)
    good_wr = results.get('good', {}).get('win_rate', 0)
    fair_wr = results.get('fair', {}).get('win_rate', 0)

    recommendations: list[str] = []

    if excellent_wr > 70:
      recommendations.append("–û—Ç–ª–∏—á–Ω—ã–µ —Å–∏–≥–Ω–∞–ª—ã –ø–æ–∫–∞–∑—ã–≤–∞—é—Ç –≤—ã—Å–æ–∫—É—é —ç—Ñ—Ñ–µ–∫—Ç–∏–≤–Ω–æ—Å—Ç—å - —É–≤–µ–ª–∏—á—å—Ç–µ —Ä–∞–∑–º–µ—Ä—ã –ø–æ–∑–∏—Ü–∏–π –¥–ª—è –Ω–∏—Ö")

    if fair_wr > good_wr:
      recommendations.append("‚ö†Ô∏è –°–∏–≥–Ω–∞–ª—ã —Å—Ä–µ–¥–Ω–µ–≥–æ –∫–∞—á–µ—Å—Ç–≤–∞ —Ä–∞–±–æ—Ç–∞—é—Ç –ª—É—á—à–µ —Ö–æ—Ä–æ—à–∏—Ö - –ø—Ä–æ–≤–µ—Ä—å—Ç–µ –Ω–∞—Å—Ç—Ä–æ–π–∫–∏ –æ—Ü–µ–Ω–∫–∏")

    avg_wr = np.mean([r.get('win_rate', 0) for r in results.values() if r])
    if avg_wr < 50:
      recommendations.append("–û–±—â–∏–π win rate –Ω–∏–∂–µ 50% - —Ä–µ–∫–æ–º–µ–Ω–¥—É–µ—Ç—Å—è –ø–æ–≤—ã—Å–∏—Ç—å –º–∏–Ω–∏–º–∞–ª—å–Ω—ã–π –ø–æ—Ä–æ–≥ –∫–∞—á–µ—Å—Ç–≤–∞")

    # –ê–Ω–∞–ª–∏–∑–∏—Ä—É–µ–º –ø—Ä–æ–±–ª–µ–º—ã –∏ –¥–∞–µ–º —Ä–µ–∫–æ–º–µ–Ω–¥–∞—Ü–∏–∏
    if any("–æ—Ç—Å—É—Ç—Å—Ç–≤—É—é—â–∏—Ö –∑–Ω–∞—á–µ–Ω–∏–π" in issue for issue in results):
      recommendations.append(
        "‚Ä¢ –†–∞—Å—Å–º–æ—Ç—Ä–∏—Ç–µ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ –±–æ–ª–µ–µ –ø—Ä–æ–¥–≤–∏–Ω—É—Ç—ã—Ö –º–µ—Ç–æ–¥–æ–≤ –∑–∞–ø–æ–ª–Ω–µ–Ω–∏—è –ø—Ä–æ–ø—É—Å–∫–æ–≤ "
        "(–∏–Ω—Ç–µ—Ä–ø–æ–ª—è—Ü–∏—è, forward-fill —Å –æ–≥—Ä–∞–Ω–∏—á–µ–Ω–∏–µ–º)"
      )

    if any("–¥—É–±–ª–∏–∫–∞—Ç–æ–≤" in issue for issue in results):
      recommendations.append(
        "‚Ä¢ –ü—Ä–æ–≤–µ—Ä—å—Ç–µ –∏—Å—Ç–æ—á–Ω–∏–∫ –¥–∞–Ω–Ω—ã—Ö –Ω–∞ –ø—Ä–µ–¥–º–µ—Ç –¥—É–±–ª–∏—Ä–æ–≤–∞–Ω–∏—è –ø—Ä–∏ –∑–∞–≥—Ä—É–∑–∫–µ"
      )

    if any("–≤—ã–±—Ä–æ—Å–æ–≤" in issue for issue in results):
      recommendations.append(
        "‚Ä¢ –ü—Ä–∏–º–µ–Ω–∏—Ç–µ —Ä–æ–±–∞—Å—Ç–Ω–æ–µ –º–∞—Å—à—Ç–∞–±–∏—Ä–æ–≤–∞–Ω–∏–µ –∏–ª–∏ –≤–∏–Ω—Å–æ—Ä–∏–∑–∞—Ü–∏—é –¥–ª—è —É–º–µ–Ω—å—à–µ–Ω–∏—è –≤–ª–∏—è–Ω–∏—è –≤—ã–±—Ä–æ—Å–æ–≤"
      )

    if any("–æ–±—ä–µ–º –¥–∞–Ω–Ω—ã—Ö" in issue.lower() for issue in results):
      recommendations.append(
        "‚Ä¢ –£–≤–µ–ª–∏—á—å—Ç–µ –ø–µ—Ä–∏–æ–¥ –∑–∞–≥—Ä—É–∑–∫–∏ –∏—Å—Ç–æ—Ä–∏—á–µ—Å–∫–∏—Ö –¥–∞–Ω–Ω—ã—Ö –∏–ª–∏ –¥–æ–±–∞–≤—å—Ç–µ –±–æ–ª—å—à–µ —Å–∏–º–≤–æ–ª–æ–≤"
      )

    if any("–Ω–µ—Å–±–∞–ª–∞–Ω—Å–∏—Ä–æ–≤–∞–Ω–Ω–æ—Å—Ç—å" in issue for issue in results):
      recommendations.append(
        "‚Ä¢ –ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ —Ç–µ—Ö–Ω–∏–∫–∏ –±–∞–ª–∞–Ω—Å–∏—Ä–æ–≤–∫–∏ –∫–ª–∞—Å—Å–æ–≤ (SMOTE, undersampling) –∏–ª–∏ "
        "–Ω–∞—Å—Ç—Ä–æ–π—Ç–µ –≤–µ—Å–∞ –∫–ª–∞—Å—Å–æ–≤ –≤ –º–æ–¥–µ–ª–∏"
      )

    # –û–±—â–∏–µ —Ä–µ–∫–æ–º–µ–Ω–¥–∞—Ü–∏–∏
    recommendations.extend([
      "‚Ä¢ –ü—Ä–æ–≤–µ—Ä—å—Ç–µ –∫–æ—Ä—Ä–µ–∫—Ç–Ω–æ—Å—Ç—å –≤—Ä–µ–º–µ–Ω–Ω—ã—Ö –º–µ—Ç–æ–∫ –∏ –æ—Ç—Å—É—Ç—Å—Ç–≤–∏–µ –ø—Ä–æ–ø—É—Å–∫–æ–≤ –≤–æ –≤—Ä–µ–º–µ–Ω–Ω–æ–º —Ä—è–¥–µ",
      "‚Ä¢ –£–±–µ–¥–∏—Ç–µ—Å—å, —á—Ç–æ –≤—Å–µ —Ç–µ—Ö–Ω–∏—á–µ—Å–∫–∏–µ –∏–Ω–¥–∏–∫–∞—Ç–æ—Ä—ã —Ä–∞—Å—Å—á–∏—Ç–∞–Ω—ã –∫–æ—Ä—Ä–µ–∫—Ç–Ω–æ",
      "‚Ä¢ –†–∞—Å—Å–º–æ—Ç—Ä–∏—Ç–µ –¥–æ–±–∞–≤–ª–µ–Ω–∏–µ –¥–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω—ã—Ö –ø—Ä–∏–∑–Ω–∞–∫–æ–≤ –¥–ª—è —É–ª—É—á—à–µ–Ω–∏—è –∫–∞—á–µ—Å—Ç–≤–∞ –º–æ–¥–µ–ª–∏"
    ])

    if recommendations:
      return "–†–µ–∫–æ–º–µ–Ω–¥–∞—Ü–∏–∏ –ø–æ —É–ª—É—á—à–µ–Ω–∏—é –¥–∞–Ω–Ω—ã—Ö:\n" + "\n".join(recommendations)
    else:
      return "–°–∏—Å—Ç–µ–º–∞ —Ä–∞–±–æ—Ç–∞–µ—Ç –≤ –Ω–æ—Ä–º–∞–ª—å–Ω–æ–º —Ä–µ–∂–∏–º–µ. –†–µ–∫–æ–º–µ–Ω–¥–∞—Ü–∏–∏ –Ω–∞ –æ—Å–Ω–æ–≤–µ –∞–Ω–∞–ª–∏–∑–∞ –∫–∞—á–µ—Å—Ç–≤–∞."


  def set_quality_thresholds(self, min_score: float = 0.6,
                               quality_weights: Optional[Dict[str, float]] = None):
      """–ù–∞—Å—Ç—Ä–∞–∏–≤–∞–µ—Ç –ø–æ—Ä–æ–≥–∏ –∫–∞—á–µ—Å—Ç–≤–∞ –¥–ª—è —Å–∏—Å—Ç–µ–º—ã"""
      self.min_quality_score = min_score

      if quality_weights:
        self.signal_quality_analyzer.quality_weights.update(quality_weights)

      logger.info(f"–û–±–Ω–æ–≤–ª–µ–Ω—ã –ø–æ—Ä–æ–≥–∏ –∫–∞—á–µ—Å—Ç–≤–∞: –º–∏–Ω–∏–º–∞–ª—å–Ω—ã–π –±–∞–ª–ª = {min_score}")

  async def analyze_historical_signal_quality(self, days: int = 30) -> Dict[str, Any]:
    """–ê–Ω–∞–ª–∏–∑–∏—Ä—É–µ—Ç –∫–∞—á–µ—Å—Ç–≤–æ —Å–∏–≥–Ω–∞–ª–æ–≤ –∑–∞ –ø–µ—Ä–∏–æ–¥ –∏ –∏—Ö —Ä–µ–∑—É–ª—å—Ç–∞—Ç—ã"""
    logger.info(f"–ê–Ω–∞–ª–∏–∑ –∫–∞—á–µ—Å—Ç–≤–∞ —Å–∏–≥–Ω–∞–ª–æ–≤ –∑–∞ –ø–æ—Å–ª–µ–¥–Ω–∏–µ {days} –¥–Ω–µ–π...")

    # –ü–æ–ª—É—á–∞–µ–º –∑–∞–∫—Ä—ã—Ç—ã–µ —Å–¥–µ–ª–∫–∏ –∑–∞ –ø–µ—Ä–∏–æ–¥
    since_date = datetime.now() - timedelta(days=days)
    query = """
        SELECT symbol, strategy, side, open_price, close_price, 
               profit_loss, metadata, open_timestamp, close_timestamp
        FROM trades
        WHERE status = 'CLOSED' AND open_timestamp >= ?
        ORDER BY open_timestamp DESC
    """

    trades = await self.db_manager._execute(query, (since_date,), fetch='all')

    if not trades:
      return {"status": "no_trades"}

    quality_vs_performance = {
      QualityScore.EXCELLENT: {'total': 0, 'profitable': 0, 'avg_pnl': 0},
      QualityScore.GOOD: {'total': 0, 'profitable': 0, 'avg_pnl': 0},
      QualityScore.FAIR: {'total': 0, 'profitable': 0, 'avg_pnl': 0},
      QualityScore.POOR: {'total': 0, 'profitable': 0, 'avg_pnl': 0}
    }

    for trade in trades:
      try:
        metadata = json.loads(trade['metadata']) if trade['metadata'] else {}
        quality_score = metadata.get('quality_score', 0.5)
        quality_category = metadata.get('quality_category', 'fair')

        # –ù–∞—Ö–æ–¥–∏–º –∫–∞—Ç–µ–≥–æ—Ä–∏—é
        category = None
        for cat in QualityScore:
          if cat.value == quality_category:
            category = cat
            break

        if category and category in quality_vs_performance:
          stats = quality_vs_performance[category]
          stats['total'] += 1
          if trade['profit_loss'] > 0:
            stats['profitable'] += 1
          stats['avg_pnl'] += trade['profit_loss']

      except Exception as e:
        logger.debug(f"–û—à–∏–±–∫–∞ –æ–±—Ä–∞–±–æ—Ç–∫–∏ —Å–¥–µ–ª–∫–∏: {e}")
        continue

    # –í—ã—á–∏—Å–ª—è–µ–º —Å—Ä–µ–¥–Ω–∏–µ –∑–Ω–∞—á–µ–Ω–∏—è –∏ win rate
    results = {}
    for category, stats in quality_vs_performance.items():
      if stats['total'] > 0:
        results[category.value] = {
          'total_trades': stats['total'],
          'win_rate': stats['profitable'] / stats['total'] * 100,
          'avg_pnl': stats['avg_pnl'] / stats['total']
        }

    return {
      'period_days': days,
      'total_trades_analyzed': len(trades),
      'quality_performance': results,
      'recommendation': self._generate_quality_recommendation(results)
    }


  async def process_trade_feedback(self, symbol: str, trade_id: int, trade_result: Dict[str, Any]):
      """
      –û–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ—Ç –æ–±—Ä–∞—Ç–Ω—É—é —Å–≤—è–∑—å –ø–æ—Å–ª–µ –∑–∞–∫—Ä—ã—Ç–∏—è —Å–¥–µ–ª–∫–∏

      Args:
          symbol: –¢–æ—Ä–≥–æ–≤—ã–π —Å–∏–º–≤–æ–ª
          trade_id: ID —Å–¥–µ–ª–∫–∏
          trade_result: –†–µ–∑—É–ª—å—Ç–∞—Ç—ã —Å–¥–µ–ª–∫–∏ (profit_loss, strategy_name, etc.)
      """
      try:
        strategy_name = trade_result.get('strategy_name')

        # 1. –û–±–Ω–æ–≤–ª—è–µ–º –ø—Ä–æ–∏–∑–≤–æ–¥–∏—Ç–µ–ª—å–Ω–æ—Å—Ç—å —Å—Ç—Ä–∞—Ç–µ–≥–∏–∏
        if hasattr(self, 'adaptive_selector'):
          await self.adaptive_selector.update_strategy_performance(strategy_name, trade_result)

        # # 2. –°–æ—Ö—Ä–∞–Ω—è–µ–º –¥–∞–Ω–Ω—ã–µ –¥–ª—è –ø–µ—Ä–µ–æ–±—É—á–µ–Ω–∏—è ML
        if self.retraining_manager:
          await self.retraining_manager.record_trade_result(symbol, trade_result)

        # 3. –û–±–Ω–æ–≤–ª—è–µ–º –≤–µ—Å–∞ –≤ Enhanced ML (–µ—Å–ª–∏ –∏—Å–ø–æ–ª—å–∑—É–µ—Ç—Å—è)
        if self.use_enhanced_ml and self.enhanced_ml_model:
          # –°–æ—Ö—Ä–∞–Ω—è–µ–º —Ä–µ–∑—É–ª—å—Ç–∞—Ç –¥–ª—è –±—É–¥—É—â–µ–≥–æ –ø–µ—Ä–µ–æ–±—É—á–µ–Ω–∏—è
          feedback_data = {
            'symbol': symbol,
            'timestamp': datetime.now(),
            'features': trade_result.get('entry_features', {}),
            'actual_outcome': 1 if trade_result['profit_loss'] > 0 else 0,
            'predicted_outcome': trade_result.get('predicted_signal'),
            'confidence': trade_result.get('confidence')
          }

          # –ú–æ–∂–Ω–æ —Å–æ—Ö—Ä–∞–Ω–∏—Ç—å –≤ –æ—Ç–¥–µ–ª—å–Ω—É—é —Ç–∞–±–ª–∏—Ü—É –¥–ª—è –∞–Ω–∞–ª–∏–∑–∞
          self._save_ml_feedback(feedback_data)

        # 4. –ê–¥–∞–ø—Ç–∏—Ä—É–µ–º –ø–∞—Ä–∞–º–µ—Ç—Ä—ã —Ä–∏—Å–∫–∞ –Ω–∞ –æ—Å–Ω–æ–≤–µ —Ä–µ–∑—É–ª—å—Ç–∞—Ç–æ–≤
        await self._adapt_risk_parameters(symbol, trade_result)

        logger.info(f"–û–±—Ä–∞–±–æ—Ç–∞–Ω–∞ –æ–±—Ä–∞—Ç–Ω–∞—è —Å–≤—è–∑—å –¥–ª—è —Å–¥–µ–ª–∫–∏ {trade_id}: "
                    f"—Å—Ç—Ä–∞—Ç–µ–≥–∏—è={strategy_name}, —Ä–µ–∑—É–ª—å—Ç–∞—Ç={trade_result['profit_loss']:.2f}")

      except Exception as e:
        logger.error(f"–û—à–∏–±–∫–∞ –æ–±—Ä–∞–±–æ—Ç–∫–∏ –æ–±—Ä–∞—Ç–Ω–æ–π —Å–≤—è–∑–∏ –¥–ª—è —Å–¥–µ–ª–∫–∏ {trade_id}: {e}")

  def _save_ml_feedback(self, feedback_data: Dict[str, Any]):
    """–°–æ—Ö—Ä–∞–Ω—è–µ—Ç –æ–±—Ä–∞—Ç–Ω—É—é —Å–≤—è–∑—å –¥–ª—è ML –º–æ–¥–µ–ª–µ–π"""
    try:
      if not hasattr(self.db_manager, 'pool') or not self.db_manager.pool._initialized:
        logger.warning("–ü—É–ª —Å–æ–µ–¥–∏–Ω–µ–Ω–∏–π –ë–î –Ω–µ –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä–æ–≤–∞–Ω –¥–ª—è —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏—è ML feedback")
        return

      # –°–æ–∑–¥–∞–µ–º —Ç–∞–±–ª–∏—Ü—É –µ—Å–ª–∏ –Ω–µ —Å—É—â–µ—Å—Ç–≤—É–µ—Ç
      self.db_manager.conn.execute("""
              CREATE TABLE IF NOT EXISTS ml_feedback (
                  id INTEGER PRIMARY KEY AUTOINCREMENT,
                  symbol TEXT NOT NULL,
                  timestamp DATETIME NOT NULL,
                  features TEXT,
                  actual_outcome INTEGER,
                  predicted_outcome INTEGER,
                  confidence REAL,
                  created_at DATETIME DEFAULT CURRENT_TIMESTAMP
              )
          """)

      self.db_manager.conn.execute("""
              INSERT INTO ml_feedback 
              (symbol, timestamp, features, actual_outcome, predicted_outcome, confidence)
              VALUES (?, ?, ?, ?, ?, ?)
          """, (
        feedback_data['symbol'],
        feedback_data['timestamp'],
        json.dumps(feedback_data['features']),
        feedback_data['actual_outcome'],
        feedback_data['predicted_outcome'],
        feedback_data['confidence']
      ))

      self.db_manager.conn.commit()

    except Exception as e:
      logger.error(f"–û—à–∏–±–∫–∞ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏—è ML feedback: {e}")

  async def _adapt_risk_parameters(self, symbol: str, trade_result: Dict[str, Any]):
    """–ê–¥–∞–ø—Ç–∏—Ä—É–µ—Ç –ø–∞—Ä–∞–º–µ—Ç—Ä—ã —Ä–∏—Å–∫–∞ –Ω–∞ –æ—Å–Ω–æ–≤–µ —Ä–µ–∑—É–ª—å—Ç–∞—Ç–æ–≤"""
    # –ê–Ω–∞–ª–∏–∑–∏—Ä—É–µ–º —Ä–µ–∑—É–ª—å—Ç–∞—Ç—ã –ø–æ—Å–ª–µ–¥–Ω–∏—Ö N —Å–¥–µ–ª–æ–∫
    all_recent_trades = await self.db_manager.get_recent_closed_trades(limit=50)
    recent_trades = [t for t in all_recent_trades if t.get('symbol') == symbol][:20]

    if len(recent_trades) >= 10:
      wins = sum(1 for t in recent_trades if t['profit_loss'] > 0)
      win_rate = wins / len(recent_trades)

      # –ê–¥–∞–ø—Ç–∏—Ä—É–µ–º max_positions –Ω–∞ –æ—Å–Ω–æ–≤–µ win rate
      current_max_positions = self.config.get('risk_management', {}).get('max_positions_per_symbol', 3)

      if win_rate > 0.65:  # –•–æ—Ä–æ—à–∞—è –ø—Ä–æ–∏–∑–≤–æ–¥–∏—Ç–µ–ª—å–Ω–æ—Å—Ç—å
        new_max_positions = min(current_max_positions + 1, 5)
      elif win_rate < 0.35:  # –ü–ª–æ—Ö–∞—è –ø—Ä–æ–∏–∑–≤–æ–¥–∏—Ç–µ–ª—å–Ω–æ—Å—Ç—å
        new_max_positions = max(current_max_positions - 1, 1)
      else:
        new_max_positions = current_max_positions

      if new_max_positions != current_max_positions:
        self.config['risk_management']['max_positions_per_symbol'] = new_max_positions
        logger.info(f"–ê–¥–∞–ø—Ç–∏—Ä–æ–≤–∞–Ω max_positions –¥–ª—è {symbol}: {current_max_positions} -> {new_max_positions}")

  async def periodic_strategy_evaluation(self):
    """–ü–µ—Ä–∏–æ–¥–∏—á–µ—Å–∫–∞—è –æ—Ü–µ–Ω–∫–∞ –∏ –∞–¥–∞–ø—Ç–∞—Ü–∏—è —Å—Ç—Ä–∞—Ç–µ–≥–∏–π"""
    while self.is_running:
      try:
        await asyncio.sleep(3600)  # –ö–∞–∂–¥—ã–π —á–∞—Å

        if hasattr(self, 'adaptive_selector'):
          # –û—Ç–∫–ª—é—á–∞–µ–º –ø–ª–æ—Ö–æ —Ä–∞–±–æ—Ç–∞—é—â–∏–µ —Å—Ç—Ä–∞—Ç–µ–≥–∏–∏
          self.adaptive_selector.disable_poorly_performing_strategies()

          # –ü–æ–ª—É—á–∞–µ–º —Å–≤–æ–¥–∫—É –ø—Ä–æ–∏–∑–≤–æ–¥–∏—Ç–µ–ª—å–Ω–æ—Å—Ç–∏
          performance = self.adaptive_selector.get_performance_summary()

          logger.info("–ü–µ—Ä–∏–æ–¥–∏—á–µ—Å–∫–∞—è –æ—Ü–µ–Ω–∫–∞ —Å—Ç—Ä–∞—Ç–µ–≥–∏–π:")
          for strategy, metrics in performance.items():
            logger.info(f"  {strategy}: –∞–∫—Ç–∏–≤–Ω–∞={metrics['active']}, "
                        f"–≤–µ—Å={metrics['weight']:.2f}, WR={metrics['win_rate']:.2f}")

            # –≠–∫—Å–ø–æ—Ä—Ç–∏—Ä—É–µ–º –∏—Å—Ç–æ—Ä–∏—é –∞–¥–∞–ø—Ç–∞—Ü–∏–π
            self.adaptive_selector.export_adaptation_history(
              f"logs/adaptation_history_{datetime.now().strftime('%Y%m%d')}.csv"
            )

      except Exception as e:
        logger.error(f"–û—à–∏–±–∫–∞ –ø–µ—Ä–∏–æ–¥–∏—á–µ—Å–∫–æ–π –æ—Ü–µ–Ω–∫–∏ —Å—Ç—Ä–∞—Ç–µ–≥–∏–π: {e}")


  async def check_strategy_adaptation(self, symbol: str):
      """–ü—Ä–æ–≤–µ—Ä—è–µ—Ç –Ω–µ–æ–±—Ö–æ–¥–∏–º–æ—Å—Ç—å –∞–¥–∞–ø—Ç–∞—Ü–∏–∏ —Å—Ç—Ä–∞—Ç–µ–≥–∏–π –¥–ª—è —Å–∏–º–≤–æ–ª–∞"""
      if not hasattr(self, 'market_regime_detector'):
        return

      # –ü–æ–ª—É—á–∞–µ–º –ø—Ä–µ–¥—ã–¥—É—â–∏–π —Ä–µ–∂–∏–º –∏–∑ –∏—Å—Ç–æ—Ä–∏–∏
      previous_regime = None
      if symbol in self.market_regime_detector.regime_history:
        history = list(self.market_regime_detector.regime_history[symbol])
        if len(history) >= 2:
          previous_regime = history[-2].primary_regime

      # –ü—Ä–æ–≤–µ—Ä—è–µ–º –Ω–µ–æ–±—Ö–æ–¥–∏–º–æ—Å—Ç—å –∞–¥–∞–ø—Ç–∞—Ü–∏–∏
      should_adapt, reason = self.market_regime_detector.should_adapt_strategy(
        symbol, previous_regime
      )

      if should_adapt:
        logger.info(f"–ê–¥–∞–ø—Ç–∞—Ü–∏—è —Å—Ç—Ä–∞—Ç–µ–≥–∏–π –¥–ª—è {symbol}: {reason}")

        # –ü–æ–ª—É—á–∞–µ–º —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫—É —Ä–µ–∂–∏–º–æ–≤
        stats = self.market_regime_detector.get_regime_statistics(symbol)

        # –ö–æ—Ä—Ä–µ–∫—Ç–∏—Ä—É–µ–º –≤–µ—Å–∞ —Å—Ç—Ä–∞—Ç–µ–≥–∏–π –Ω–∞ –æ—Å–Ω–æ–≤–µ —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∏
        if hasattr(self, 'adaptive_selector') and stats:
          regime_distribution = stats.get('regime_distribution', {})
          # –£–≤–µ–ª–∏—á–∏–≤–∞–µ–º –≤–µ—Å —Å—Ç—Ä–∞—Ç–µ–≥–∏–π, –∫–æ—Ç–æ—Ä—ã–µ —Ö–æ—Ä–æ—à–æ —Ä–∞–±–æ—Ç–∞—é—Ç –≤ —á–∞—Å—Ç—ã—Ö —Ä–µ–∂–∏–º–∞—Ö
          for regime_name, count in regime_distribution.items():
            if count > 10:  # –ï—Å–ª–∏ —Ä–µ–∂–∏–º –≤—Å—Ç—Ä–µ—á–∞–ª—Å—è —á–∞—Å—Ç–æ
              recommended_strategies = self.market_regime_detector.regime_parameters.get(
                MarketRegime(regime_name),
                self.market_regime_detector.regime_parameters[MarketRegime.RANGING]
              ).recommended_strategies

              for strategy in recommended_strategies:
                if strategy in self.adaptive_selector.strategy_performance:
                  self.adaptive_selector._adapt_strategy_weight(strategy)

  async def export_regime_statistics(self):
    """–≠–∫—Å–ø–æ—Ä—Ç–∏—Ä—É–µ—Ç —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫—É —Ä–µ–∂–∏–º–æ–≤ –¥–ª—è –≤—Å–µ—Ö —Å–∏–º–≤–æ–ª–æ–≤"""
    export_dir = "logs/regime_statistics"
    os.makedirs(export_dir, exist_ok=True)

    timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")

    for symbol in self.active_symbols:
      if symbol in self.market_regime_detector.regime_history:
        filepath = f"{export_dir}/{symbol}_regimes_{timestamp}.csv"
        self.market_regime_detector.export_regime_data(symbol, filepath)

    logger.info(f"–°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞ —Ä–µ–∂–∏–º–æ–≤ —ç–∫—Å–ø–æ—Ä—Ç–∏—Ä–æ–≤–∞–Ω–∞ –≤ {export_dir}")

  async def periodic_roi_check(self):
    """
    –ü–µ—Ä–∏–æ–¥–∏—á–µ—Å–∫–∞—è –ø—Ä–æ–≤–µ—Ä–∫–∞ ROI –Ω–∞—Å—Ç—Ä–æ–µ–∫ (–∫–∞–∂–¥—ã–µ 24 —á–∞—Å–∞)
    """
    while self.is_running:
      try:
        await asyncio.sleep(24 * 60 * 60)  # 24 —á–∞—Å–∞

        logger.info("=== –ü–ï–†–ò–û–î–ò–ß–ï–°–ö–ê–Ø –ü–†–û–í–ï–†–ö–ê ROI –ù–ê–°–¢–†–û–ï–ö ===")

        # –ü—Ä–æ–≤–µ—Ä—è–µ–º –∞–∫—Ç—É–∞–ª—å–Ω–æ—Å—Ç—å –Ω–∞—Å—Ç—Ä–æ–µ–∫
        validation = self.risk_manager.validate_roi_parameters()

        if validation['warnings']:
          logger.warning("–û–±–Ω–∞—Ä—É–∂–µ–Ω—ã –ø—Ä–µ–¥—É–ø—Ä–µ–∂–¥–µ–Ω–∏—è –≤ ROI –Ω–∞—Å—Ç—Ä–æ–π–∫–∞—Ö:")
          for warning in validation['warnings']:
            logger.warning(f"  ‚ö†Ô∏è  {warning}")

        # –í—ã–≤–æ–¥–∏–º –∫—Ä–∞—Ç–∫–∏–π –æ—Ç—á–µ—Ç
        roi_report = self.risk_manager.get_roi_summary_report()
        logger.info("–¢–µ–∫—É—â–∏–µ ROI –Ω–∞—Å—Ç—Ä–æ–π–∫–∏:")
        for line in roi_report.split('\n')[:10]:  # –ü–µ—Ä–≤—ã–µ 10 —Å—Ç—Ä–æ–∫
          if line.strip():
            logger.info(line)

      except Exception as e:
        logger.error(f"–û—à–∏–±–∫–∞ –ø–µ—Ä–∏–æ–¥–∏—á–µ—Å–∫–æ–π –ø—Ä–æ–≤–µ—Ä–∫–∏ ROI: {e}")

  async def _handle_generate_report(self):
    """–û–±—Ä–∞–±–æ—Ç–∫–∞ –∫–æ–º–∞–Ω–¥—ã –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏ –æ—Ç—á–µ—Ç–∞"""
    try:
      logger.info("–ì–µ–Ω–µ—Ä–∞—Ü–∏—è –æ—Ç—á–µ—Ç–∞ –ø–æ –∑–∞–ø—Ä–æ—Å—É –∏–∑ –¥–∞—à–±–æ—Ä–¥–∞...")
      # –ó–¥–µ—Å—å –ª–æ–≥–∏–∫–∞ –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏ –æ—Ç—á–µ—Ç–∞
      if hasattr(self, 'shadow_trading') and self.shadow_trading:
        from main import generate_shadow_trading_reports
        await generate_shadow_trading_reports(self)
    except Exception as e:
      logger.error(f"–û—à–∏–±–∫–∞ –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏ –æ—Ç—á–µ—Ç–∞: {e}")

  async def _handle_retrain_model(self):
    """–û–±—Ä–∞–±–æ—Ç–∫–∞ –∫–æ–º–∞–Ω–¥—ã –ø–µ—Ä–µ–æ–±—É—á–µ–Ω–∏—è –º–æ–¥–µ–ª–∏"""
    try:
      logger.info("–ó–∞–ø—É—Å–∫ –ø–µ—Ä–µ–æ–±—É—á–µ–Ω–∏—è –º–æ–¥–µ–ª–∏ –ø–æ –∑–∞–ø—Ä–æ—Å—É –∏–∑ –¥–∞—à–±–æ—Ä–¥–∞...")
      if self.retraining_manager:
        # –ó–∞–ø—É—Å–∫–∞–µ–º –ø–µ—Ä–µ–æ–±—É—á–µ–Ω–∏–µ –¥–ª—è —Ç–æ–ø —Å–∏–º–≤–æ–ª–æ–≤
        top_symbols = self.active_symbols[:50]
        asyncio.create_task(
          self.retraining_manager.check_and_retrain_if_needed(top_symbols)
        )
    except Exception as e:
      logger.error(f"–û—à–∏–±–∫–∞ –∑–∞–ø—É—Å–∫–∞ –ø–µ—Ä–µ–æ–±—É—á–µ–Ω–∏—è: {e}")

  def force_data_refresh(self, symbol: str, data_fetcher) -> Optional[pd.DataFrame]:
    """
    –ü—Ä–∏–Ω—É–¥–∏—Ç–µ–ª—å–Ω–æ –æ–±–Ω–æ–≤–ª—è–µ—Ç –¥–∞–Ω–Ω—ã–µ –µ—Å–ª–∏ –æ–Ω–∏ —É—Å—Ç–∞—Ä–µ–ª–∏
    """
    try:
      logger.info(f"–ü—Ä–∏–Ω—É–¥–∏—Ç–µ–ª—å–Ω–æ–µ –æ–±–Ω–æ–≤–ª–µ–Ω–∏–µ –¥–∞–Ω–Ω—ã—Ö –¥–ª—è {symbol}")

      # –ü–æ–ª—É—á–∞–µ–º —Å–≤–µ–∂–∏–µ –¥–∞–Ω–Ω—ã–µ
      fresh_data = asyncio.run(data_fetcher.get_historical_candles(symbol, timeframe=Timeframe.ONE_HOUR, limit=100))

      if fresh_data is not None and not fresh_data.empty:
        # –ü—Ä–æ–≤–µ—Ä—è–µ–º —Å–≤–µ–∂–µ—Å—Ç—å –Ω–æ–≤—ã—Ö –¥–∞–Ω–Ω—ã—Ö
        validation = self.enhanced_ml_model.temporal_manager.validate_data_freshness(fresh_data, symbol)

        if validation['is_fresh']:
          logger.info(f"–ü–æ–ª—É—á–µ–Ω—ã —Å–≤–µ–∂–∏–µ –¥–∞–Ω–Ω—ã–µ –¥–ª—è {symbol}")
          return fresh_data
        else:
          logger.warning(f"–î–∞–∂–µ –æ–±–Ω–æ–≤–ª–µ–Ω–Ω—ã–µ –¥–∞–Ω–Ω—ã–µ –¥–ª—è {symbol} –Ω–µ —è–≤–ª—è—é—Ç—Å—è —Å–≤–µ–∂–∏–º–∏")
          return fresh_data  # –í–æ–∑–≤—Ä–∞—â–∞–µ–º –≤ –ª—é–±–æ–º —Å–ª—É—á–∞–µ
      else:
        logger.error(f"–ù–µ —É–¥–∞–ª–æ—Å—å –ø–æ–ª—É—á–∏—Ç—å –æ–±–Ω–æ–≤–ª–µ–Ω–Ω—ã–µ –¥–∞–Ω–Ω—ã–µ –¥–ª—è {symbol}")
        return None

    except Exception as e:
      logger.error(f"–û—à–∏–±–∫–∞ –ø—Ä–∏–Ω—É–¥–∏—Ç–µ–ª—å–Ω–æ–≥–æ –æ–±–Ω–æ–≤–ª–µ–Ω–∏—è –¥–∞–Ω–Ω—ã—Ö –¥–ª—è {symbol}: {e}")
      return None
